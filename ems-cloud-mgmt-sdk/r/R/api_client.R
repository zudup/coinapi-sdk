# EMS - REST API
#
# This section will provide necessary information about the `CoinAPI EMS REST API` protocol. <br/> This API is also available in the Postman application: <a href=\"https://postman.coinapi.io/\" target=\"_blank\">https://postman.coinapi.io/</a>       <br/><br/> Implemented Standards:    * [HTTP1.0](https://datatracker.ietf.org/doc/html/rfc1945)   * [HTTP1.1](https://datatracker.ietf.org/doc/html/rfc2616)   * [HTTP2.0](https://datatracker.ietf.org/doc/html/rfc7540)     ### Endpoints <table>   <thead>     <tr>       <th>Deployment method</th>       <th>Environment</th>       <th>Url</th>     </tr>   </thead>   <tbody>     <tr>       <td>Managed Cloud</td>       <td>Production</td>       <td>Use <a href=\"#ems-docs-sh\">Managed Cloud REST API /v1/locations</a> to get specific endpoints to each server site where your deployments span</td>     </tr>     <tr>       <td>Managed Cloud</td>       <td>Sandbox</td>       <td><code>https://ems-gateway-aws-eu-central-1-dev.coinapi.io/</code></td>     </tr>     <tr>       <td>Self Hosted</td>       <td>Production</td>       <td>IP Address of the <code>ems-gateway</code> container/excecutable in the closest server site to the caller location</td>     </tr>     <tr>       <td>Self Hosted</td>       <td>Sandbox</td>       <td>IP Address of the <code>ems-gateway</code> container/excecutable in the closest server site to the caller location</td>     </tr>   </tbody> </table>  ### Authentication If the software is deployed as `Self-Hosted` then API do not require authentication as inside your infrastructure, your company is responsible for the security and access controls.  <br/><br/> If the software is deployed in our `Managed Cloud`, there are 2 methods for authenticating with us, you only need to use one:   1. Custom authorization header named `X-CoinAPI-Key` with the API Key  2. Query string parameter named `apikey` with the API Key  3. <a href=\"#certificate\">TLS Client Certificate</a> from the `Managed Cloud REST API` (/v1/certificate/pem endpoint) while establishing a TLS session with us.  #### Custom authorization header You can authorize by providing additional custom header named `X-CoinAPI-Key` and API key as its value. Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY`, then the authorization header you should send to us will look like: <br/><br/> `X-CoinAPI-Key: 73034021-THIS-IS-SAMPLE-KEY` <aside class=\"success\">This method is recommended by us and you should use it in production environments.</aside> #### Query string authorization parameter You can authorize by providing an additional parameter named `apikey` with a value equal to your API key in the query string of your HTTP request. Assuming that your API key is `73034021-THIS-IS-SAMPLE-KEY` and that you want to request all balances, then your query string should look like this:  <br/><br/> `GET /v1/balances?apikey=73034021-THIS-IS-SAMPLE-KEY` <aside class=\"notice\">Query string method may be more practical for development activities.</aside> 
#
# The version of the OpenAPI document: v1
# Contact: support@coinapi.io
# Generated by: https://openapi-generator.tech


#' ApiClient Class
#'
#' Generic API client for OpenAPI client library builds.
#' OpenAPI generic API client. This client handles the client-
#' server communication, and is invariant across implementations. Specifics of
#' the methods and models for each application are generated from the OpenAPI Generator
#' templates.
#'
#' NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
#' Ref: https://openapi-generator.tech
#' Do not edit the class manually.
#'
#' @docType class
#' @title ApiClient
#' @description ApiClient Class
#' @format An \code{R6Class} generator object
#' @field base_path Base url
#' @field user_agent Default user agent
#' @field default_headers
#' @field username Username for HTTP basic authentication
#' @field password Password for HTTP basic authentication
#' @field api_keys
#' @field access_token
#' @field timeout Default timeout in seconds
#' @field retry_status_codes vector of status codes to retry
#' @field max_retry_attempts maximum number of retries for the status codes
#' @importFrom httr add_headers accept timeout content
#' @export
ApiClient  <- R6::R6Class(
  "ApiClient",
  public = list(
    # base path of all requests
    base_path = "https://ems-gateway-aws-eu-central-1-dev.coinapi.io",
    # user agent in the HTTP request
    user_agent = "OpenAPI-Generator/1.0.0/r",
    # default headers in the HTTP request
    default_headers = NULL,
    # username (HTTP basic authentication)
    username = NULL,
    # password (HTTP basic authentication)
    password = NULL,
    # API keys
    api_keys = NULL,
    # Access token
    access_token = NULL,
    # Time Out (seconds)
    timeout = NULL,
    # Vector of status codes to retry
    retry_status_codes = NULL,
    # Maximum number of retry attempts for the retry status codes
    max_retry_attempts = NULL,
    # constructor
    initialize = function(base_path=NULL, user_agent=NULL, default_headers=NULL,
                          username=NULL, password=NULL, api_keys=NULL,
                          access_token=NULL, timeout=NULL,
                          retry_status_codes=NULL, max_retry_attempts=NULL) {
      if (!is.null(base_path)) {
        self$base_path <- base_path
      }

      if (!is.null(default_headers)) {
        self$default_headers <- default_headers
      }

      if (!is.null(username)) {
        self$username <- username
      }

      if (!is.null(password)) {
        self$password <- password
      }

      if (!is.null(access_token)) {
        self$access_token <- access_token
      }

      if (!is.null(api_keys)) {
        self$api_keys <- api_keys
      } else {
        self$api_keys <- list()
      }

      if (!is.null(user_agent)) {
        self$`user_agent` <- user_agent
      }

      if (!is.null(timeout)) {
        self$timeout <- timeout
      }

      if (!is.null(retry_status_codes)) {
        self$retry_status_codes <- retry_status_codes
      }

      if (!is.null(max_retry_attempts)) {
        self$max_retry_attempts <- max_retry_attempts
      }
    },

    CallApi = function(url, method, query_params, header_params, body, ...) {

      resp <- self$Execute(url, method, query_params, header_params, body, ...)
      status_code <- httr::status_code(resp)

      if (is.null(self$max_retry_attempts)) {
        self$max_retry_attempts <- 3
      }

      if (!is.null(self$retry_status_codes)) {

        for (i in 1 : self$max_retry_attempts) {
          if (status_code %in% self$retry_status_codes) {
            Sys.sleep((2 ^ i) + stats::runif(n = 1, min = 0, max = 1))
            resp <- self$Execute(url, method, query_params, header_params, body, ...)
            status_code <- httr::status_code(resp)
          } else {
            break;
          }
        }
      }

      resp
    },

    Execute = function(url, method, query_params, header_params, body, ...) {
      headers <- httr::add_headers(c(header_params, self$default_headers))

      http_timeout <- NULL
      if (!is.null(self$timeout)) {
        http_timeout <- httr::timeout(self$timeout)
      }

      if (method == "GET") {
        httr::GET(url, query = query_params, headers, http_timeout, httr::user_agent(self$`user_agent`), ...)
      } else if (method == "POST") {
        httr::POST(url, query = query_params, headers, body = body, httr::content_type("application/json"), http_timeout, httr::user_agent(self$`user_agent`), ...)
      } else if (method == "PUT") {
        httr::PUT(url, query = query_params, headers, body = body, httr::content_type("application/json"), http_timeout, http_timeout, httr::user_agent(self$`user_agent`), ...)
      } else if (method == "PATCH") {
        httr::PATCH(url, query = query_params, headers, body = body, httr::content_type("application/json"), http_timeout, http_timeout, httr::user_agent(self$`user_agent`), ...)
      } else if (method == "HEAD") {
        httr::HEAD(url, query = query_params, headers, http_timeout, http_timeout, httr::user_agent(self$`user_agent`), ...)
      } else if (method == "DELETE") {
        httr::DELETE(url, query = query_params, headers, http_timeout, http_timeout, httr::user_agent(self$`user_agent`), ...)
      } else {
        err_msg <- "Http method must be `GET`, `HEAD`, `OPTIONS`, `POST`, `PATCH`, `PUT` or `DELETE`."
        stop(err_msg)
      }
    },

    # Deserialize the content of api response to the given type.
    deserialize = function(resp, return_type, pkg_env) {
      resp_obj <- jsonlite::fromJSON(httr::content(resp, "text", encoding = "UTF-8"))
      self$deserializeObj(resp_obj, return_type, pkg_env)
    },


    # Deserialize the response from jsonlite object based on the given type
    # by handling complex and nested types by iterating recursively
    # Example return_types will be like "array[integer]", "map(Pet)", "array[map(Tag)]", etc.,

    deserializeObj = function(obj, return_type, pkg_env) {
      return_obj <- NULL
      primitive_types <- c("character", "numeric", "integer", "logical", "complex")

      # To handle the "map" type
      if (startsWith(return_type, "map(")) {
        inner_return_type <- regmatches(return_type, regexec(pattern = "map\\((.*)\\)", return_type))[[1]][2]
        return_obj <- lapply(names(obj), function(name) {
          self$deserializeObj(obj[[name]], inner_return_type, pkg_env)
        })
        names(return_obj) <- names(obj)
      }

      # To handle the "array" type
      else if (startsWith(return_type, "array[")) {
        inner_return_type <- regmatches(return_type, regexec(pattern = "array\\[(.*)\\]", return_type))[[1]][2]
        if (c(inner_return_type) %in% primitive_types) {
          return_obj <- vector("list", length = length(obj))
          if (length(obj) > 0) {
            for (row in 1:length(obj)) {
              return_obj[[row]] <- self$deserializeObj(obj[row], inner_return_type, pkg_env)
            }
          }
        } else {
          if (!is.null(nrow(obj))) {
            return_obj <- vector("list", length = nrow(obj))
            if (nrow(obj) > 0) {
              for (row in 1:nrow(obj)) {
                return_obj[[row]] <- self$deserializeObj(obj[row, , drop = FALSE], inner_return_type, pkg_env)
              }
            }
          }
        }
      }

      # To handle model objects which are not array or map containers. Ex:"Pet"
      else if (exists(return_type, pkg_env) && !(c(return_type) %in% primitive_types)) {
        return_type <- get(return_type, envir = as.environment(pkg_env))
        return_obj <- return_type$new()
        return_obj$fromJSON(
          jsonlite::toJSON(obj, digits = NA, auto_unbox = TRUE)
        )
      }

      # To handle primitive type
      else {
        return_obj <- obj
      }
      return_obj
    }
  )
)
