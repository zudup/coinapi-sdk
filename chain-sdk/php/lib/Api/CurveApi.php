<?php
/**
 * CurveApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * OnChain API
 *
 * This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * CurveApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CurveApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'curveGetAccountDTOsHistorical' => [
            'application/json',
        ],
        'curveGetAccountsHistorical' => [
            'application/json',
        ],
        'curveGetAddLiquidityEventDTOsHistorical' => [
            'application/json',
        ],
        'curveGetAddLiquidityEventsHistorical' => [
            'application/json',
        ],
        'curveGetAdminFeeChangeLogDTOsHistorical' => [
            'application/json',
        ],
        'curveGetAdminFeeChangeLogsHistorical' => [
            'application/json',
        ],
        'curveGetAmplificationCoeffChangeLogDTOsHistorical' => [
            'application/json',
        ],
        'curveGetAmplificationCoeffChangeLogsHistorical' => [
            'application/json',
        ],
        'curveGetCoinDTOsHistorical' => [
            'application/json',
        ],
        'curveGetCoinsHistorical' => [
            'application/json',
        ],
        'curveGetContractDTOsHistorical' => [
            'application/json',
        ],
        'curveGetContractVersionDTOsHistorical' => [
            'application/json',
        ],
        'curveGetContractsHistorical' => [
            'application/json',
        ],
        'curveGetContractsVersionsHistorical' => [
            'application/json',
        ],
        'curveGetDailyVolumeDTOsHistorical' => [
            'application/json',
        ],
        'curveGetDailyVolumesHistorical' => [
            'application/json',
        ],
        'curveGetExchangeDTOsHistorical' => [
            'application/json',
        ],
        'curveGetExchangesHistorical' => [
            'application/json',
        ],
        'curveGetFeeChangeLogDTOsHistorical' => [
            'application/json',
        ],
        'curveGetFeeChangeLogsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeDepositDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeLiquidityDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeTotalWeightDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeTypeDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeTypeWeightDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeWeightDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeWeightVoteDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugeWithdrawDTOsHistorical' => [
            'application/json',
        ],
        'curveGetGaugesDepositsHistorical' => [
            'application/json',
        ],
        'curveGetGaugesHistorical' => [
            'application/json',
        ],
        'curveGetGaugesLiquidityHistorical' => [
            'application/json',
        ],
        'curveGetGaugesTotalWeightsHistorical' => [
            'application/json',
        ],
        'curveGetGaugesTypesHistorical' => [
            'application/json',
        ],
        'curveGetGaugesTypesWeightsHistorical' => [
            'application/json',
        ],
        'curveGetGaugesWeightsHistorical' => [
            'application/json',
        ],
        'curveGetGaugesWeightsVotesHistorical' => [
            'application/json',
        ],
        'curveGetGaugesWithdrawHistorical' => [
            'application/json',
        ],
        'curveGetHourlyVolumeDTOsHistorical' => [
            'application/json',
        ],
        'curveGetHourlyVolumesHistorical' => [
            'application/json',
        ],
        'curveGetLpTokenDTOsHistorical' => [
            'application/json',
        ],
        'curveGetLpTokensHistorical' => [
            'application/json',
        ],
        'curveGetPoolDTOsHistorical' => [
            'application/json',
        ],
        'curveGetPoolsHistorical' => [
            'application/json',
        ],
        'curveGetProposalDTOsHistorical' => [
            'application/json',
        ],
        'curveGetProposalVoteDTOsHistorical' => [
            'application/json',
        ],
        'curveGetProposalsHistorical' => [
            'application/json',
        ],
        'curveGetProposalsVotesHistorical' => [
            'application/json',
        ],
        'curveGetRemoveLiquidityEventDTOsHistorical' => [
            'application/json',
        ],
        'curveGetRemoveLiquidityEventsHistorical' => [
            'application/json',
        ],
        'curveGetRemoveLiquidityOneEventDTOsHistorical' => [
            'application/json',
        ],
        'curveGetRemoveLiquidityOneEventsHistorical' => [
            'application/json',
        ],
        'curveGetSystemStateDTOsHistorical' => [
            'application/json',
        ],
        'curveGetSystemStatesHistorical' => [
            'application/json',
        ],
        'curveGetTokenDTOsHistorical' => [
            'application/json',
        ],
        'curveGetTokensHistorical' => [
            'application/json',
        ],
        'curveGetTransferOwnershipEventDTOsHistorical' => [
            'application/json',
        ],
        'curveGetTransferOwnershipEventsHistorical' => [
            'application/json',
        ],
        'curveGetUnderlyingCoinDTOsHistorical' => [
            'application/json',
        ],
        'curveGetUnderlyingCoinsHistorical' => [
            'application/json',
        ],
        'curveGetVotingAppDTOsHistorical' => [
            'application/json',
        ],
        'curveGetVotingAppsHistorical' => [
            'application/json',
        ],
        'curveGetWeeklyVolumeDTOsHistorical' => [
            'application/json',
        ],
        'curveGetWeeklyVolumesHistorical' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation curveGetAccountDTOsHistorical
     *
     * AccountDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAccountDTO[]
     */
    public function curveGetAccountDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAccountDTOsHistorical'][0])
    {
        list($response) = $this->curveGetAccountDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAccountDTOsHistoricalWithHttpInfo
     *
     * AccountDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAccountDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAccountDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAccountDTOsHistorical'][0])
    {
        $request = $this->curveGetAccountDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAccountDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAccountDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAccountDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAccountDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAccountDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAccountDTOsHistoricalAsync
     *
     * AccountDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAccountDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAccountDTOsHistorical'][0])
    {
        return $this->curveGetAccountDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAccountDTOsHistoricalAsyncWithHttpInfo
     *
     * AccountDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAccountDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAccountDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAccountDTO[]';
        $request = $this->curveGetAccountDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAccountDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAccountDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAccountDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/AccountDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAccountsHistorical
     *
     * Accounts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAccountDTO[]
     */
    public function curveGetAccountsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetAccountsHistorical'][0])
    {
        list($response) = $this->curveGetAccountsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAccountsHistoricalWithHttpInfo
     *
     * Accounts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAccountDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAccountsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetAccountsHistorical'][0])
    {
        $request = $this->curveGetAccountsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAccountDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAccountDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAccountDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAccountDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAccountDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAccountsHistoricalAsync
     *
     * Accounts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAccountsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetAccountsHistorical'][0])
    {
        return $this->curveGetAccountsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAccountsHistoricalAsyncWithHttpInfo
     *
     * Accounts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAccountsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetAccountsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAccountDTO[]';
        $request = $this->curveGetAccountsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAccountsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAccountsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAccountsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetAccountsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/accounts/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAddLiquidityEventDTOsHistorical
     *
     * AddLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]
     */
    public function curveGetAddLiquidityEventDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'][0])
    {
        list($response) = $this->curveGetAddLiquidityEventDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAddLiquidityEventDTOsHistoricalWithHttpInfo
     *
     * AddLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAddLiquidityEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAddLiquidityEventDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'][0])
    {
        $request = $this->curveGetAddLiquidityEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAddLiquidityEventDTOsHistoricalAsync
     *
     * AddLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAddLiquidityEventDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'][0])
    {
        return $this->curveGetAddLiquidityEventDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAddLiquidityEventDTOsHistoricalAsyncWithHttpInfo
     *
     * AddLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAddLiquidityEventDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]';
        $request = $this->curveGetAddLiquidityEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAddLiquidityEventDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAddLiquidityEventDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/AddLiquidityEventDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAddLiquidityEventsHistorical
     *
     * AddLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id pool_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]
     */
    public function curveGetAddLiquidityEventsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventsHistorical'][0])
    {
        list($response) = $this->curveGetAddLiquidityEventsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAddLiquidityEventsHistoricalWithHttpInfo
     *
     * AddLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAddLiquidityEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAddLiquidityEventsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventsHistorical'][0])
    {
        $request = $this->curveGetAddLiquidityEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAddLiquidityEventsHistoricalAsync
     *
     * AddLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAddLiquidityEventsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventsHistorical'][0])
    {
        return $this->curveGetAddLiquidityEventsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAddLiquidityEventsHistoricalAsyncWithHttpInfo
     *
     * AddLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAddLiquidityEventsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAddLiquidityEventDTO[]';
        $request = $this->curveGetAddLiquidityEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAddLiquidityEventsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAddLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAddLiquidityEventsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAddLiquidityEventsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/addLiquidityEvents/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAdminFeeChangeLogDTOsHistorical
     *
     * AdminFeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]
     */
    public function curveGetAdminFeeChangeLogDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'][0])
    {
        list($response) = $this->curveGetAdminFeeChangeLogDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAdminFeeChangeLogDTOsHistoricalWithHttpInfo
     *
     * AdminFeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAdminFeeChangeLogDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'][0])
    {
        $request = $this->curveGetAdminFeeChangeLogDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAdminFeeChangeLogDTOsHistoricalAsync
     *
     * AdminFeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAdminFeeChangeLogDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'][0])
    {
        return $this->curveGetAdminFeeChangeLogDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAdminFeeChangeLogDTOsHistoricalAsyncWithHttpInfo
     *
     * AdminFeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAdminFeeChangeLogDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]';
        $request = $this->curveGetAdminFeeChangeLogDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAdminFeeChangeLogDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAdminFeeChangeLogDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/AdminFeeChangeLogDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAdminFeeChangeLogsHistorical
     *
     * AdminFeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]
     */
    public function curveGetAdminFeeChangeLogsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogsHistorical'][0])
    {
        list($response) = $this->curveGetAdminFeeChangeLogsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAdminFeeChangeLogsHistoricalWithHttpInfo
     *
     * AdminFeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAdminFeeChangeLogsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogsHistorical'][0])
    {
        $request = $this->curveGetAdminFeeChangeLogsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAdminFeeChangeLogsHistoricalAsync
     *
     * AdminFeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAdminFeeChangeLogsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogsHistorical'][0])
    {
        return $this->curveGetAdminFeeChangeLogsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAdminFeeChangeLogsHistoricalAsyncWithHttpInfo
     *
     * AdminFeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAdminFeeChangeLogsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAdminFeeChangeLogDTO[]';
        $request = $this->curveGetAdminFeeChangeLogsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAdminFeeChangeLogsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAdminFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAdminFeeChangeLogsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAdminFeeChangeLogsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/adminFeeChangeLogs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogDTOsHistorical
     *
     * AmplificationCoeffChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]
     */
    public function curveGetAmplificationCoeffChangeLogDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'][0])
    {
        list($response) = $this->curveGetAmplificationCoeffChangeLogDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogDTOsHistoricalWithHttpInfo
     *
     * AmplificationCoeffChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAmplificationCoeffChangeLogDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'][0])
    {
        $request = $this->curveGetAmplificationCoeffChangeLogDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogDTOsHistoricalAsync
     *
     * AmplificationCoeffChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAmplificationCoeffChangeLogDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'][0])
    {
        return $this->curveGetAmplificationCoeffChangeLogDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogDTOsHistoricalAsyncWithHttpInfo
     *
     * AmplificationCoeffChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAmplificationCoeffChangeLogDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]';
        $request = $this->curveGetAmplificationCoeffChangeLogDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAmplificationCoeffChangeLogDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAmplificationCoeffChangeLogDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/AmplificationCoeffChangeLogDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogsHistorical
     *
     * AmplificationCoeffChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]
     */
    public function curveGetAmplificationCoeffChangeLogsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'][0])
    {
        list($response) = $this->curveGetAmplificationCoeffChangeLogsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogsHistoricalWithHttpInfo
     *
     * AmplificationCoeffChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetAmplificationCoeffChangeLogsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'][0])
    {
        $request = $this->curveGetAmplificationCoeffChangeLogsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogsHistoricalAsync
     *
     * AmplificationCoeffChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAmplificationCoeffChangeLogsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'][0])
    {
        return $this->curveGetAmplificationCoeffChangeLogsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetAmplificationCoeffChangeLogsHistoricalAsyncWithHttpInfo
     *
     * AmplificationCoeffChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetAmplificationCoeffChangeLogsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveAmplificationCoeffChangeLogDTO[]';
        $request = $this->curveGetAmplificationCoeffChangeLogsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetAmplificationCoeffChangeLogsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetAmplificationCoeffChangeLogsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetAmplificationCoeffChangeLogsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/amplificationCoeffChangeLogs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetCoinDTOsHistorical
     *
     * CoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveCoinDTO[]
     */
    public function curveGetCoinDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinDTOsHistorical'][0])
    {
        list($response) = $this->curveGetCoinDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetCoinDTOsHistoricalWithHttpInfo
     *
     * CoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveCoinDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetCoinDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinDTOsHistorical'][0])
    {
        $request = $this->curveGetCoinDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveCoinDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveCoinDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveCoinDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveCoinDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveCoinDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetCoinDTOsHistoricalAsync
     *
     * CoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetCoinDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinDTOsHistorical'][0])
    {
        return $this->curveGetCoinDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetCoinDTOsHistoricalAsyncWithHttpInfo
     *
     * CoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetCoinDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveCoinDTO[]';
        $request = $this->curveGetCoinDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetCoinDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetCoinDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/CoinDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetCoinsHistorical
     *
     * Coins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveCoinDTO[]
     */
    public function curveGetCoinsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinsHistorical'][0])
    {
        list($response) = $this->curveGetCoinsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetCoinsHistoricalWithHttpInfo
     *
     * Coins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveCoinDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetCoinsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinsHistorical'][0])
    {
        $request = $this->curveGetCoinsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveCoinDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveCoinDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveCoinDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveCoinDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveCoinDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetCoinsHistoricalAsync
     *
     * Coins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetCoinsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinsHistorical'][0])
    {
        return $this->curveGetCoinsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetCoinsHistoricalAsyncWithHttpInfo
     *
     * Coins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetCoinsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveCoinDTO[]';
        $request = $this->curveGetCoinsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetCoinsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetCoinsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetCoinsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/coins/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetContractDTOsHistorical
     *
     * ContractDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveContractDTO[]
     */
    public function curveGetContractDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractDTOsHistorical'][0])
    {
        list($response) = $this->curveGetContractDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetContractDTOsHistoricalWithHttpInfo
     *
     * ContractDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveContractDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetContractDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractDTOsHistorical'][0])
    {
        $request = $this->curveGetContractDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveContractDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveContractDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveContractDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveContractDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveContractDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetContractDTOsHistoricalAsync
     *
     * ContractDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractDTOsHistorical'][0])
    {
        return $this->curveGetContractDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetContractDTOsHistoricalAsyncWithHttpInfo
     *
     * ContractDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveContractDTO[]';
        $request = $this->curveGetContractDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetContractDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetContractDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/ContractDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetContractVersionDTOsHistorical
     *
     * ContractVersionDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractVersionDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveContractVersionDTO[]
     */
    public function curveGetContractVersionDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractVersionDTOsHistorical'][0])
    {
        list($response) = $this->curveGetContractVersionDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetContractVersionDTOsHistoricalWithHttpInfo
     *
     * ContractVersionDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractVersionDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveContractVersionDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetContractVersionDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractVersionDTOsHistorical'][0])
    {
        $request = $this->curveGetContractVersionDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveContractVersionDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveContractVersionDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveContractVersionDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveContractVersionDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveContractVersionDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetContractVersionDTOsHistoricalAsync
     *
     * ContractVersionDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractVersionDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractVersionDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractVersionDTOsHistorical'][0])
    {
        return $this->curveGetContractVersionDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetContractVersionDTOsHistoricalAsyncWithHttpInfo
     *
     * ContractVersionDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractVersionDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractVersionDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractVersionDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveContractVersionDTO[]';
        $request = $this->curveGetContractVersionDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetContractVersionDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractVersionDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetContractVersionDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractVersionDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/ContractVersionDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetContractsHistorical
     *
     * Contracts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveContractDTO[]
     */
    public function curveGetContractsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsHistorical'][0])
    {
        list($response) = $this->curveGetContractsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetContractsHistoricalWithHttpInfo
     *
     * Contracts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveContractDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetContractsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsHistorical'][0])
    {
        $request = $this->curveGetContractsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveContractDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveContractDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveContractDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveContractDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveContractDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetContractsHistoricalAsync
     *
     * Contracts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsHistorical'][0])
    {
        return $this->curveGetContractsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetContractsHistoricalAsyncWithHttpInfo
     *
     * Contracts (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveContractDTO[]';
        $request = $this->curveGetContractsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetContractsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetContractsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/contracts/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetContractsVersionsHistorical
     *
     * ContractsVersions (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsVersionsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveContractVersionDTO[]
     */
    public function curveGetContractsVersionsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsVersionsHistorical'][0])
    {
        list($response) = $this->curveGetContractsVersionsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetContractsVersionsHistoricalWithHttpInfo
     *
     * ContractsVersions (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsVersionsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveContractVersionDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetContractsVersionsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsVersionsHistorical'][0])
    {
        $request = $this->curveGetContractsVersionsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveContractVersionDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveContractVersionDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveContractVersionDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveContractVersionDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveContractVersionDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetContractsVersionsHistoricalAsync
     *
     * ContractsVersions (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsVersionsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractsVersionsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsVersionsHistorical'][0])
    {
        return $this->curveGetContractsVersionsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetContractsVersionsHistoricalAsyncWithHttpInfo
     *
     * ContractsVersions (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsVersionsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetContractsVersionsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsVersionsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveContractVersionDTO[]';
        $request = $this->curveGetContractsVersionsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetContractsVersionsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetContractsVersionsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetContractsVersionsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetContractsVersionsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/contractsVersions/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetDailyVolumeDTOsHistorical
     *
     * DailyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveDailyVolumeDTO[]
     */
    public function curveGetDailyVolumeDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumeDTOsHistorical'][0])
    {
        list($response) = $this->curveGetDailyVolumeDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetDailyVolumeDTOsHistoricalWithHttpInfo
     *
     * DailyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveDailyVolumeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetDailyVolumeDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumeDTOsHistorical'][0])
    {
        $request = $this->curveGetDailyVolumeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveDailyVolumeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveDailyVolumeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetDailyVolumeDTOsHistoricalAsync
     *
     * DailyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetDailyVolumeDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumeDTOsHistorical'][0])
    {
        return $this->curveGetDailyVolumeDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetDailyVolumeDTOsHistoricalAsyncWithHttpInfo
     *
     * DailyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetDailyVolumeDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumeDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]';
        $request = $this->curveGetDailyVolumeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetDailyVolumeDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetDailyVolumeDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumeDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/DailyVolumeDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetDailyVolumesHistorical
     *
     * DailyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveDailyVolumeDTO[]
     */
    public function curveGetDailyVolumesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumesHistorical'][0])
    {
        list($response) = $this->curveGetDailyVolumesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetDailyVolumesHistoricalWithHttpInfo
     *
     * DailyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveDailyVolumeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetDailyVolumesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumesHistorical'][0])
    {
        $request = $this->curveGetDailyVolumesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveDailyVolumeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveDailyVolumeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetDailyVolumesHistoricalAsync
     *
     * DailyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetDailyVolumesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumesHistorical'][0])
    {
        return $this->curveGetDailyVolumesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetDailyVolumesHistoricalAsyncWithHttpInfo
     *
     * DailyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetDailyVolumesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveDailyVolumeDTO[]';
        $request = $this->curveGetDailyVolumesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetDailyVolumesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetDailyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetDailyVolumesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetDailyVolumesHistorical'][0])
    {







        $resourcePath = '/dapps/curve/dailyVolumes/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetExchangeDTOsHistorical
     *
     * ExchangeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveExchangeDTO[]
     */
    public function curveGetExchangeDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangeDTOsHistorical'][0])
    {
        list($response) = $this->curveGetExchangeDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetExchangeDTOsHistoricalWithHttpInfo
     *
     * ExchangeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveExchangeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetExchangeDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangeDTOsHistorical'][0])
    {
        $request = $this->curveGetExchangeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveExchangeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveExchangeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveExchangeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveExchangeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveExchangeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetExchangeDTOsHistoricalAsync
     *
     * ExchangeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetExchangeDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangeDTOsHistorical'][0])
    {
        return $this->curveGetExchangeDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetExchangeDTOsHistoricalAsyncWithHttpInfo
     *
     * ExchangeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetExchangeDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangeDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveExchangeDTO[]';
        $request = $this->curveGetExchangeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetExchangeDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetExchangeDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangeDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/ExchangeDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetExchangesHistorical
     *
     * Exchanges (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveExchangeDTO[]
     */
    public function curveGetExchangesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangesHistorical'][0])
    {
        list($response) = $this->curveGetExchangesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetExchangesHistoricalWithHttpInfo
     *
     * Exchanges (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveExchangeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetExchangesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangesHistorical'][0])
    {
        $request = $this->curveGetExchangesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveExchangeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveExchangeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveExchangeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveExchangeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveExchangeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetExchangesHistoricalAsync
     *
     * Exchanges (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetExchangesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangesHistorical'][0])
    {
        return $this->curveGetExchangesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetExchangesHistoricalAsyncWithHttpInfo
     *
     * Exchanges (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetExchangesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveExchangeDTO[]';
        $request = $this->curveGetExchangesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetExchangesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetExchangesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetExchangesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetExchangesHistorical'][0])
    {







        $resourcePath = '/dapps/curve/exchanges/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetFeeChangeLogDTOsHistorical
     *
     * FeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveFeeChangeLogDTO[]
     */
    public function curveGetFeeChangeLogDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogDTOsHistorical'][0])
    {
        list($response) = $this->curveGetFeeChangeLogDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetFeeChangeLogDTOsHistoricalWithHttpInfo
     *
     * FeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveFeeChangeLogDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetFeeChangeLogDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogDTOsHistorical'][0])
    {
        $request = $this->curveGetFeeChangeLogDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetFeeChangeLogDTOsHistoricalAsync
     *
     * FeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetFeeChangeLogDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogDTOsHistorical'][0])
    {
        return $this->curveGetFeeChangeLogDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetFeeChangeLogDTOsHistoricalAsyncWithHttpInfo
     *
     * FeeChangeLogDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetFeeChangeLogDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]';
        $request = $this->curveGetFeeChangeLogDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetFeeChangeLogDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetFeeChangeLogDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/FeeChangeLogDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetFeeChangeLogsHistorical
     *
     * FeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveFeeChangeLogDTO[]
     */
    public function curveGetFeeChangeLogsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogsHistorical'][0])
    {
        list($response) = $this->curveGetFeeChangeLogsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetFeeChangeLogsHistoricalWithHttpInfo
     *
     * FeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveFeeChangeLogDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetFeeChangeLogsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogsHistorical'][0])
    {
        $request = $this->curveGetFeeChangeLogsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetFeeChangeLogsHistoricalAsync
     *
     * FeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetFeeChangeLogsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogsHistorical'][0])
    {
        return $this->curveGetFeeChangeLogsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetFeeChangeLogsHistoricalAsyncWithHttpInfo
     *
     * FeeChangeLogs (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetFeeChangeLogsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveFeeChangeLogDTO[]';
        $request = $this->curveGetFeeChangeLogsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetFeeChangeLogsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetFeeChangeLogsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetFeeChangeLogsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetFeeChangeLogsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/feeChangeLogs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeDTOsHistorical
     *
     * GaugeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeDTO[]
     */
    public function curveGetGaugeDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeDTOsHistoricalWithHttpInfo
     *
     * GaugeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeDTOsHistoricalAsync
     *
     * GaugeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDTOsHistorical'][0])
    {
        return $this->curveGetGaugeDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeDTO[]';
        $request = $this->curveGetGaugeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeDepositDTOsHistorical
     *
     * GaugeDepositDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDepositDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeDepositDTO[]
     */
    public function curveGetGaugeDepositDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDepositDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeDepositDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeDepositDTOsHistoricalWithHttpInfo
     *
     * GaugeDepositDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDepositDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeDepositDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeDepositDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDepositDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeDepositDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeDepositDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeDepositDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeDepositDTOsHistoricalAsync
     *
     * GaugeDepositDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDepositDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeDepositDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDepositDTOsHistorical'][0])
    {
        return $this->curveGetGaugeDepositDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeDepositDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeDepositDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDepositDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeDepositDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDepositDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]';
        $request = $this->curveGetGaugeDepositDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeDepositDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeDepositDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeDepositDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeDepositDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeDepositDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeLiquidityDTOsHistorical
     *
     * GaugeLiquidityDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]
     */
    public function curveGetGaugeLiquidityDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeLiquidityDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeLiquidityDTOsHistoricalWithHttpInfo
     *
     * GaugeLiquidityDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeLiquidityDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeLiquidityDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeLiquidityDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeLiquidityDTOsHistoricalAsync
     *
     * GaugeLiquidityDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeLiquidityDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'][0])
    {
        return $this->curveGetGaugeLiquidityDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeLiquidityDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeLiquidityDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeLiquidityDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]';
        $request = $this->curveGetGaugeLiquidityDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeLiquidityDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeLiquidityDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeLiquidityDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeLiquidityDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeTotalWeightDTOsHistorical
     *
     * GaugeTotalWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]
     */
    public function curveGetGaugeTotalWeightDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeTotalWeightDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeTotalWeightDTOsHistoricalWithHttpInfo
     *
     * GaugeTotalWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeTotalWeightDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeTotalWeightDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeTotalWeightDTOsHistoricalAsync
     *
     * GaugeTotalWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeTotalWeightDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'][0])
    {
        return $this->curveGetGaugeTotalWeightDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeTotalWeightDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeTotalWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeTotalWeightDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]';
        $request = $this->curveGetGaugeTotalWeightDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeTotalWeightDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeTotalWeightDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTotalWeightDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeTotalWeightDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeTypeDTOsHistorical
     *
     * GaugeTypeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeTypeDTO[]
     */
    public function curveGetGaugeTypeDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeTypeDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeTypeDTOsHistoricalWithHttpInfo
     *
     * GaugeTypeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeTypeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeTypeDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeTypeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeTypeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeTypeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeTypeDTOsHistoricalAsync
     *
     * GaugeTypeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeTypeDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeDTOsHistorical'][0])
    {
        return $this->curveGetGaugeTypeDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeTypeDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeTypeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeTypeDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]';
        $request = $this->curveGetGaugeTypeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeTypeDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeTypeDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeTypeDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeTypeWeightDTOsHistorical
     *
     * GaugeTypeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]
     */
    public function curveGetGaugeTypeWeightDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeTypeWeightDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeTypeWeightDTOsHistoricalWithHttpInfo
     *
     * GaugeTypeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeTypeWeightDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeTypeWeightDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeTypeWeightDTOsHistoricalAsync
     *
     * GaugeTypeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeTypeWeightDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'][0])
    {
        return $this->curveGetGaugeTypeWeightDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeTypeWeightDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeTypeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeTypeWeightDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]';
        $request = $this->curveGetGaugeTypeWeightDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeTypeWeightDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeTypeWeightDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeTypeWeightDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeTypeWeightDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeWeightDTOsHistorical
     *
     * GaugeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeWeightDTO[]
     */
    public function curveGetGaugeWeightDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeWeightDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeWeightDTOsHistoricalWithHttpInfo
     *
     * GaugeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeWeightDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeWeightDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeWeightDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeWeightDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeWeightDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeWeightDTOsHistoricalAsync
     *
     * GaugeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeWeightDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightDTOsHistorical'][0])
    {
        return $this->curveGetGaugeWeightDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeWeightDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeWeightDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeWeightDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]';
        $request = $this->curveGetGaugeWeightDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeWeightDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeWeightDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeWeightDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeWeightVoteDTOsHistorical
     *
     * GaugeWeightVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]
     */
    public function curveGetGaugeWeightVoteDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeWeightVoteDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeWeightVoteDTOsHistoricalWithHttpInfo
     *
     * GaugeWeightVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeWeightVoteDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeWeightVoteDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeWeightVoteDTOsHistoricalAsync
     *
     * GaugeWeightVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeWeightVoteDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'][0])
    {
        return $this->curveGetGaugeWeightVoteDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeWeightVoteDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeWeightVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeWeightVoteDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]';
        $request = $this->curveGetGaugeWeightVoteDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeWeightVoteDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeWeightVoteDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWeightVoteDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeWeightVoteDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugeWithdrawDTOsHistorical
     *
     * GaugeWithdrawDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]
     */
    public function curveGetGaugeWithdrawDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'][0])
    {
        list($response) = $this->curveGetGaugeWithdrawDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugeWithdrawDTOsHistoricalWithHttpInfo
     *
     * GaugeWithdrawDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeWithdrawDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugeWithdrawDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'][0])
    {
        $request = $this->curveGetGaugeWithdrawDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugeWithdrawDTOsHistoricalAsync
     *
     * GaugeWithdrawDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeWithdrawDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'][0])
    {
        return $this->curveGetGaugeWithdrawDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugeWithdrawDTOsHistoricalAsyncWithHttpInfo
     *
     * GaugeWithdrawDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugeWithdrawDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]';
        $request = $this->curveGetGaugeWithdrawDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugeWithdrawDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugeWithdrawDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugeWithdrawDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/GaugeWithdrawDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesDepositsHistorical
     *
     * GaugesDeposits (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesDepositsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeDepositDTO[]
     */
    public function curveGetGaugesDepositsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesDepositsHistorical'][0])
    {
        list($response) = $this->curveGetGaugesDepositsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesDepositsHistoricalWithHttpInfo
     *
     * GaugesDeposits (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesDepositsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeDepositDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesDepositsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesDepositsHistorical'][0])
    {
        $request = $this->curveGetGaugesDepositsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeDepositDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeDepositDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesDepositsHistoricalAsync
     *
     * GaugesDeposits (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesDepositsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesDepositsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesDepositsHistorical'][0])
    {
        return $this->curveGetGaugesDepositsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesDepositsHistoricalAsyncWithHttpInfo
     *
     * GaugesDeposits (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesDepositsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesDepositsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesDepositsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeDepositDTO[]';
        $request = $this->curveGetGaugesDepositsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesDepositsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesDepositsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesDepositsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesDepositsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesDeposits/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesHistorical
     *
     * Gauges (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeDTO[]
     */
    public function curveGetGaugesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugesHistorical'][0])
    {
        list($response) = $this->curveGetGaugesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesHistoricalWithHttpInfo
     *
     * Gauges (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugesHistorical'][0])
    {
        $request = $this->curveGetGaugesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesHistoricalAsync
     *
     * Gauges (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugesHistorical'][0])
    {
        return $this->curveGetGaugesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesHistoricalAsyncWithHttpInfo
     *
     * Gauges (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeDTO[]';
        $request = $this->curveGetGaugesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetGaugesHistorical'][0])
    {







        $resourcePath = '/dapps/curve/gauges/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesLiquidityHistorical
     *
     * GaugesLiquidity (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesLiquidityHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]
     */
    public function curveGetGaugesLiquidityHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesLiquidityHistorical'][0])
    {
        list($response) = $this->curveGetGaugesLiquidityHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesLiquidityHistoricalWithHttpInfo
     *
     * GaugesLiquidity (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesLiquidityHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeLiquidityDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesLiquidityHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesLiquidityHistorical'][0])
    {
        $request = $this->curveGetGaugesLiquidityHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesLiquidityHistoricalAsync
     *
     * GaugesLiquidity (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesLiquidityHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesLiquidityHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesLiquidityHistorical'][0])
    {
        return $this->curveGetGaugesLiquidityHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesLiquidityHistoricalAsyncWithHttpInfo
     *
     * GaugesLiquidity (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesLiquidityHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesLiquidityHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesLiquidityHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeLiquidityDTO[]';
        $request = $this->curveGetGaugesLiquidityHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesLiquidityHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesLiquidityHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesLiquidityHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesLiquidityHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesLiquidity/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesTotalWeightsHistorical
     *
     * GaugesTotalWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTotalWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]
     */
    public function curveGetGaugesTotalWeightsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTotalWeightsHistorical'][0])
    {
        list($response) = $this->curveGetGaugesTotalWeightsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesTotalWeightsHistoricalWithHttpInfo
     *
     * GaugesTotalWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTotalWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesTotalWeightsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTotalWeightsHistorical'][0])
    {
        $request = $this->curveGetGaugesTotalWeightsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesTotalWeightsHistoricalAsync
     *
     * GaugesTotalWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTotalWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesTotalWeightsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTotalWeightsHistorical'][0])
    {
        return $this->curveGetGaugesTotalWeightsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesTotalWeightsHistoricalAsyncWithHttpInfo
     *
     * GaugesTotalWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTotalWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesTotalWeightsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTotalWeightsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeTotalWeightDTO[]';
        $request = $this->curveGetGaugesTotalWeightsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesTotalWeightsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTotalWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesTotalWeightsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTotalWeightsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesTotalWeights/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesTypesHistorical
     *
     * GaugesTypes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeTypeDTO[]
     */
    public function curveGetGaugesTypesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesHistorical'][0])
    {
        list($response) = $this->curveGetGaugesTypesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesTypesHistoricalWithHttpInfo
     *
     * GaugesTypes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeTypeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesTypesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesHistorical'][0])
    {
        $request = $this->curveGetGaugesTypesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeTypeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeTypeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesTypesHistoricalAsync
     *
     * GaugesTypes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesTypesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesHistorical'][0])
    {
        return $this->curveGetGaugesTypesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesTypesHistoricalAsyncWithHttpInfo
     *
     * GaugesTypes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesTypesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeDTO[]';
        $request = $this->curveGetGaugesTypesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesTypesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesTypesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesTypes/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesTypesWeightsHistorical
     *
     * GaugesTypesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]
     */
    public function curveGetGaugesTypesWeightsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesWeightsHistorical'][0])
    {
        list($response) = $this->curveGetGaugesTypesWeightsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesTypesWeightsHistoricalWithHttpInfo
     *
     * GaugesTypesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesTypesWeightsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesWeightsHistorical'][0])
    {
        $request = $this->curveGetGaugesTypesWeightsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesTypesWeightsHistoricalAsync
     *
     * GaugesTypesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesTypesWeightsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesWeightsHistorical'][0])
    {
        return $this->curveGetGaugesTypesWeightsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesTypesWeightsHistoricalAsyncWithHttpInfo
     *
     * GaugesTypesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesTypesWeightsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesWeightsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeTypeWeightDTO[]';
        $request = $this->curveGetGaugesTypesWeightsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesTypesWeightsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesTypesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesTypesWeightsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesTypesWeightsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesTypesWeights/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesWeightsHistorical
     *
     * GaugesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeWeightDTO[]
     */
    public function curveGetGaugesWeightsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsHistorical'][0])
    {
        list($response) = $this->curveGetGaugesWeightsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesWeightsHistoricalWithHttpInfo
     *
     * GaugesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeWeightDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesWeightsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsHistorical'][0])
    {
        $request = $this->curveGetGaugesWeightsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeWeightDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeWeightDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesWeightsHistoricalAsync
     *
     * GaugesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesWeightsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsHistorical'][0])
    {
        return $this->curveGetGaugesWeightsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesWeightsHistoricalAsyncWithHttpInfo
     *
     * GaugesWeights (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesWeightsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightDTO[]';
        $request = $this->curveGetGaugesWeightsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesWeightsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesWeightsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesWeights/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesWeightsVotesHistorical
     *
     * GaugesWeightsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]
     */
    public function curveGetGaugesWeightsVotesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsVotesHistorical'][0])
    {
        list($response) = $this->curveGetGaugesWeightsVotesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesWeightsVotesHistoricalWithHttpInfo
     *
     * GaugesWeightsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesWeightsVotesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsVotesHistorical'][0])
    {
        $request = $this->curveGetGaugesWeightsVotesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesWeightsVotesHistoricalAsync
     *
     * GaugesWeightsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesWeightsVotesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsVotesHistorical'][0])
    {
        return $this->curveGetGaugesWeightsVotesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesWeightsVotesHistoricalAsyncWithHttpInfo
     *
     * GaugesWeightsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesWeightsVotesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsVotesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeWeightVoteDTO[]';
        $request = $this->curveGetGaugesWeightsVotesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesWeightsVotesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWeightsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesWeightsVotesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWeightsVotesHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesWeightsVotes/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetGaugesWithdrawHistorical
     *
     * GaugesWithdraw (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWithdrawHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]
     */
    public function curveGetGaugesWithdrawHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWithdrawHistorical'][0])
    {
        list($response) = $this->curveGetGaugesWithdrawHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetGaugesWithdrawHistoricalWithHttpInfo
     *
     * GaugesWithdraw (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWithdrawHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveGaugeWithdrawDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetGaugesWithdrawHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWithdrawHistorical'][0])
    {
        $request = $this->curveGetGaugesWithdrawHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetGaugesWithdrawHistoricalAsync
     *
     * GaugesWithdraw (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWithdrawHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesWithdrawHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWithdrawHistorical'][0])
    {
        return $this->curveGetGaugesWithdrawHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetGaugesWithdrawHistoricalAsyncWithHttpInfo
     *
     * GaugesWithdraw (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWithdrawHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetGaugesWithdrawHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWithdrawHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveGaugeWithdrawDTO[]';
        $request = $this->curveGetGaugesWithdrawHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetGaugesWithdrawHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetGaugesWithdrawHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetGaugesWithdrawHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetGaugesWithdrawHistorical'][0])
    {






        $resourcePath = '/dapps/curve/gaugesWithdraws/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetHourlyVolumeDTOsHistorical
     *
     * HourlyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveHourlyVolumeDTO[]
     */
    public function curveGetHourlyVolumeDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumeDTOsHistorical'][0])
    {
        list($response) = $this->curveGetHourlyVolumeDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetHourlyVolumeDTOsHistoricalWithHttpInfo
     *
     * HourlyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveHourlyVolumeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetHourlyVolumeDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumeDTOsHistorical'][0])
    {
        $request = $this->curveGetHourlyVolumeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetHourlyVolumeDTOsHistoricalAsync
     *
     * HourlyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetHourlyVolumeDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumeDTOsHistorical'][0])
    {
        return $this->curveGetHourlyVolumeDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetHourlyVolumeDTOsHistoricalAsyncWithHttpInfo
     *
     * HourlyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetHourlyVolumeDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumeDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]';
        $request = $this->curveGetHourlyVolumeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetHourlyVolumeDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetHourlyVolumeDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumeDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/HourlyVolumeDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetHourlyVolumesHistorical
     *
     * HourlyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveHourlyVolumeDTO[]
     */
    public function curveGetHourlyVolumesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumesHistorical'][0])
    {
        list($response) = $this->curveGetHourlyVolumesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetHourlyVolumesHistoricalWithHttpInfo
     *
     * HourlyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveHourlyVolumeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetHourlyVolumesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumesHistorical'][0])
    {
        $request = $this->curveGetHourlyVolumesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetHourlyVolumesHistoricalAsync
     *
     * HourlyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetHourlyVolumesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumesHistorical'][0])
    {
        return $this->curveGetHourlyVolumesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetHourlyVolumesHistoricalAsyncWithHttpInfo
     *
     * HourlyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetHourlyVolumesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveHourlyVolumeDTO[]';
        $request = $this->curveGetHourlyVolumesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetHourlyVolumesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetHourlyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetHourlyVolumesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetHourlyVolumesHistorical'][0])
    {







        $resourcePath = '/dapps/curve/hourlyVolumes/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetLpTokenDTOsHistorical
     *
     * LpTokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveLpTokenDTO[]
     */
    public function curveGetLpTokenDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokenDTOsHistorical'][0])
    {
        list($response) = $this->curveGetLpTokenDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetLpTokenDTOsHistoricalWithHttpInfo
     *
     * LpTokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveLpTokenDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetLpTokenDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokenDTOsHistorical'][0])
    {
        $request = $this->curveGetLpTokenDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveLpTokenDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveLpTokenDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveLpTokenDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveLpTokenDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveLpTokenDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetLpTokenDTOsHistoricalAsync
     *
     * LpTokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetLpTokenDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokenDTOsHistorical'][0])
    {
        return $this->curveGetLpTokenDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetLpTokenDTOsHistoricalAsyncWithHttpInfo
     *
     * LpTokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetLpTokenDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokenDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveLpTokenDTO[]';
        $request = $this->curveGetLpTokenDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetLpTokenDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetLpTokenDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokenDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/LpTokenDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetLpTokensHistorical
     *
     * LpTokens (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokensHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveLpTokenDTO[]
     */
    public function curveGetLpTokensHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokensHistorical'][0])
    {
        list($response) = $this->curveGetLpTokensHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetLpTokensHistoricalWithHttpInfo
     *
     * LpTokens (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokensHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveLpTokenDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetLpTokensHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokensHistorical'][0])
    {
        $request = $this->curveGetLpTokensHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveLpTokenDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveLpTokenDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveLpTokenDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveLpTokenDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveLpTokenDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetLpTokensHistoricalAsync
     *
     * LpTokens (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokensHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetLpTokensHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokensHistorical'][0])
    {
        return $this->curveGetLpTokensHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetLpTokensHistoricalAsyncWithHttpInfo
     *
     * LpTokens (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokensHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetLpTokensHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokensHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveLpTokenDTO[]';
        $request = $this->curveGetLpTokensHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetLpTokensHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetLpTokensHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetLpTokensHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetLpTokensHistorical'][0])
    {







        $resourcePath = '/dapps/curve/lpTokens/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetPoolDTOsHistorical
     *
     * PoolDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurvePoolDTO[]
     */
    public function curveGetPoolDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolDTOsHistorical'][0])
    {
        list($response) = $this->curveGetPoolDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetPoolDTOsHistoricalWithHttpInfo
     *
     * PoolDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurvePoolDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetPoolDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolDTOsHistorical'][0])
    {
        $request = $this->curveGetPoolDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurvePoolDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurvePoolDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurvePoolDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurvePoolDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurvePoolDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetPoolDTOsHistoricalAsync
     *
     * PoolDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetPoolDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolDTOsHistorical'][0])
    {
        return $this->curveGetPoolDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetPoolDTOsHistoricalAsyncWithHttpInfo
     *
     * PoolDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetPoolDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurvePoolDTO[]';
        $request = $this->curveGetPoolDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetPoolDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetPoolDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/PoolDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetPoolsHistorical
     *
     * Pools (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurvePoolDTO[]
     */
    public function curveGetPoolsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolsHistorical'][0])
    {
        list($response) = $this->curveGetPoolsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetPoolsHistoricalWithHttpInfo
     *
     * Pools (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurvePoolDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetPoolsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolsHistorical'][0])
    {
        $request = $this->curveGetPoolsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurvePoolDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurvePoolDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurvePoolDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurvePoolDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurvePoolDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetPoolsHistoricalAsync
     *
     * Pools (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetPoolsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolsHistorical'][0])
    {
        return $this->curveGetPoolsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetPoolsHistoricalAsyncWithHttpInfo
     *
     * Pools (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetPoolsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurvePoolDTO[]';
        $request = $this->curveGetPoolsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetPoolsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetPoolsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetPoolsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetPoolsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/pools/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetProposalDTOsHistorical
     *
     * ProposalDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveProposalDTO[]
     */
    public function curveGetProposalDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalDTOsHistorical'][0])
    {
        list($response) = $this->curveGetProposalDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetProposalDTOsHistoricalWithHttpInfo
     *
     * ProposalDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveProposalDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetProposalDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalDTOsHistorical'][0])
    {
        $request = $this->curveGetProposalDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveProposalDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveProposalDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveProposalDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveProposalDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveProposalDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetProposalDTOsHistoricalAsync
     *
     * ProposalDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalDTOsHistorical'][0])
    {
        return $this->curveGetProposalDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetProposalDTOsHistoricalAsyncWithHttpInfo
     *
     * ProposalDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveProposalDTO[]';
        $request = $this->curveGetProposalDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetProposalDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetProposalDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/ProposalDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetProposalVoteDTOsHistorical
     *
     * ProposalVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveProposalVoteDTO[]
     */
    public function curveGetProposalVoteDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalVoteDTOsHistorical'][0])
    {
        list($response) = $this->curveGetProposalVoteDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetProposalVoteDTOsHistoricalWithHttpInfo
     *
     * ProposalVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveProposalVoteDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetProposalVoteDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalVoteDTOsHistorical'][0])
    {
        $request = $this->curveGetProposalVoteDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveProposalVoteDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveProposalVoteDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveProposalVoteDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveProposalVoteDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveProposalVoteDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetProposalVoteDTOsHistoricalAsync
     *
     * ProposalVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalVoteDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalVoteDTOsHistorical'][0])
    {
        return $this->curveGetProposalVoteDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetProposalVoteDTOsHistoricalAsyncWithHttpInfo
     *
     * ProposalVoteDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalVoteDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalVoteDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveProposalVoteDTO[]';
        $request = $this->curveGetProposalVoteDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetProposalVoteDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalVoteDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetProposalVoteDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetProposalVoteDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/ProposalVoteDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetProposalsHistorical
     *
     * Proposals (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveProposalDTO[]
     */
    public function curveGetProposalsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsHistorical'][0])
    {
        list($response) = $this->curveGetProposalsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetProposalsHistoricalWithHttpInfo
     *
     * Proposals (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveProposalDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetProposalsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsHistorical'][0])
    {
        $request = $this->curveGetProposalsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveProposalDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveProposalDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveProposalDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveProposalDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveProposalDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetProposalsHistoricalAsync
     *
     * Proposals (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsHistorical'][0])
    {
        return $this->curveGetProposalsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetProposalsHistoricalAsyncWithHttpInfo
     *
     * Proposals (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveProposalDTO[]';
        $request = $this->curveGetProposalsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetProposalsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetProposalsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/proposals/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetProposalsVotesHistorical
     *
     * ProposalsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveProposalVoteDTO[]
     */
    public function curveGetProposalsVotesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsVotesHistorical'][0])
    {
        list($response) = $this->curveGetProposalsVotesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetProposalsVotesHistoricalWithHttpInfo
     *
     * ProposalsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveProposalVoteDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetProposalsVotesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsVotesHistorical'][0])
    {
        $request = $this->curveGetProposalsVotesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveProposalVoteDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveProposalVoteDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveProposalVoteDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveProposalVoteDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveProposalVoteDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetProposalsVotesHistoricalAsync
     *
     * ProposalsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalsVotesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsVotesHistorical'][0])
    {
        return $this->curveGetProposalsVotesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetProposalsVotesHistoricalAsyncWithHttpInfo
     *
     * ProposalsVotes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetProposalsVotesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsVotesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveProposalVoteDTO[]';
        $request = $this->curveGetProposalsVotesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetProposalsVotesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetProposalsVotesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetProposalsVotesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetProposalsVotesHistorical'][0])
    {






        $resourcePath = '/dapps/curve/proposalsVotes/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetRemoveLiquidityEventDTOsHistorical
     *
     * RemoveLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]
     */
    public function curveGetRemoveLiquidityEventDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'][0])
    {
        list($response) = $this->curveGetRemoveLiquidityEventDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetRemoveLiquidityEventDTOsHistoricalWithHttpInfo
     *
     * RemoveLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetRemoveLiquidityEventDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'][0])
    {
        $request = $this->curveGetRemoveLiquidityEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetRemoveLiquidityEventDTOsHistoricalAsync
     *
     * RemoveLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityEventDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'][0])
    {
        return $this->curveGetRemoveLiquidityEventDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetRemoveLiquidityEventDTOsHistoricalAsyncWithHttpInfo
     *
     * RemoveLiquidityEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityEventDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]';
        $request = $this->curveGetRemoveLiquidityEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetRemoveLiquidityEventDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetRemoveLiquidityEventDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/RemoveLiquidityEventDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetRemoveLiquidityEventsHistorical
     *
     * RemoveLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]
     */
    public function curveGetRemoveLiquidityEventsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventsHistorical'][0])
    {
        list($response) = $this->curveGetRemoveLiquidityEventsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetRemoveLiquidityEventsHistoricalWithHttpInfo
     *
     * RemoveLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetRemoveLiquidityEventsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventsHistorical'][0])
    {
        $request = $this->curveGetRemoveLiquidityEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetRemoveLiquidityEventsHistoricalAsync
     *
     * RemoveLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityEventsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventsHistorical'][0])
    {
        return $this->curveGetRemoveLiquidityEventsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetRemoveLiquidityEventsHistoricalAsyncWithHttpInfo
     *
     * RemoveLiquidityEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityEventsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityEventDTO[]';
        $request = $this->curveGetRemoveLiquidityEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetRemoveLiquidityEventsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetRemoveLiquidityEventsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityEventsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/removeLiquidityEvents/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventDTOsHistorical
     *
     * RemoveLiquidityOneEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]
     */
    public function curveGetRemoveLiquidityOneEventDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'][0])
    {
        list($response) = $this->curveGetRemoveLiquidityOneEventDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventDTOsHistoricalWithHttpInfo
     *
     * RemoveLiquidityOneEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetRemoveLiquidityOneEventDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'][0])
    {
        $request = $this->curveGetRemoveLiquidityOneEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventDTOsHistoricalAsync
     *
     * RemoveLiquidityOneEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityOneEventDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'][0])
    {
        return $this->curveGetRemoveLiquidityOneEventDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventDTOsHistoricalAsyncWithHttpInfo
     *
     * RemoveLiquidityOneEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityOneEventDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]';
        $request = $this->curveGetRemoveLiquidityOneEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetRemoveLiquidityOneEventDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetRemoveLiquidityOneEventDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/RemoveLiquidityOneEventDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventsHistorical
     *
     * RemoveLiquidityOneEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]
     */
    public function curveGetRemoveLiquidityOneEventsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'][0])
    {
        list($response) = $this->curveGetRemoveLiquidityOneEventsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventsHistoricalWithHttpInfo
     *
     * RemoveLiquidityOneEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetRemoveLiquidityOneEventsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'][0])
    {
        $request = $this->curveGetRemoveLiquidityOneEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventsHistoricalAsync
     *
     * RemoveLiquidityOneEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityOneEventsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'][0])
    {
        return $this->curveGetRemoveLiquidityOneEventsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetRemoveLiquidityOneEventsHistoricalAsyncWithHttpInfo
     *
     * RemoveLiquidityOneEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetRemoveLiquidityOneEventsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveRemoveLiquidityOneEventDTO[]';
        $request = $this->curveGetRemoveLiquidityOneEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetRemoveLiquidityOneEventsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetRemoveLiquidityOneEventsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetRemoveLiquidityOneEventsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/removeLiquidityOneEvents/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetSystemStateDTOsHistorical
     *
     * SystemStateDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStateDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveSystemStateDTO[]
     */
    public function curveGetSystemStateDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetSystemStateDTOsHistorical'][0])
    {
        list($response) = $this->curveGetSystemStateDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetSystemStateDTOsHistoricalWithHttpInfo
     *
     * SystemStateDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStateDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveSystemStateDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetSystemStateDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetSystemStateDTOsHistorical'][0])
    {
        $request = $this->curveGetSystemStateDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveSystemStateDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveSystemStateDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveSystemStateDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveSystemStateDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveSystemStateDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetSystemStateDTOsHistoricalAsync
     *
     * SystemStateDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStateDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetSystemStateDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetSystemStateDTOsHistorical'][0])
    {
        return $this->curveGetSystemStateDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetSystemStateDTOsHistoricalAsyncWithHttpInfo
     *
     * SystemStateDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStateDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetSystemStateDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetSystemStateDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveSystemStateDTO[]';
        $request = $this->curveGetSystemStateDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetSystemStateDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStateDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetSystemStateDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetSystemStateDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/SystemStateDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetSystemStatesHistorical
     *
     * SystemStates (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStatesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveSystemStateDTO[]
     */
    public function curveGetSystemStatesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetSystemStatesHistorical'][0])
    {
        list($response) = $this->curveGetSystemStatesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetSystemStatesHistoricalWithHttpInfo
     *
     * SystemStates (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStatesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveSystemStateDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetSystemStatesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetSystemStatesHistorical'][0])
    {
        $request = $this->curveGetSystemStatesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveSystemStateDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveSystemStateDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveSystemStateDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveSystemStateDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveSystemStateDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetSystemStatesHistoricalAsync
     *
     * SystemStates (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStatesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetSystemStatesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetSystemStatesHistorical'][0])
    {
        return $this->curveGetSystemStatesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetSystemStatesHistoricalAsyncWithHttpInfo
     *
     * SystemStates (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStatesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetSystemStatesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetSystemStatesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveSystemStateDTO[]';
        $request = $this->curveGetSystemStatesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetSystemStatesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetSystemStatesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetSystemStatesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetSystemStatesHistorical'][0])
    {






        $resourcePath = '/dapps/curve/systemStates/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetTokenDTOsHistorical
     *
     * TokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveTokenDTO[]
     */
    public function curveGetTokenDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTokenDTOsHistorical'][0])
    {
        list($response) = $this->curveGetTokenDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetTokenDTOsHistoricalWithHttpInfo
     *
     * TokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveTokenDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetTokenDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTokenDTOsHistorical'][0])
    {
        $request = $this->curveGetTokenDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveTokenDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveTokenDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveTokenDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveTokenDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveTokenDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetTokenDTOsHistoricalAsync
     *
     * TokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTokenDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTokenDTOsHistorical'][0])
    {
        return $this->curveGetTokenDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetTokenDTOsHistoricalAsyncWithHttpInfo
     *
     * TokenDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTokenDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTokenDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveTokenDTO[]';
        $request = $this->curveGetTokenDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetTokenDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokenDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetTokenDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTokenDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/TokenDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetTokensHistorical
     *
     * Tokens (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $token_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokensHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveTokenDTO[]
     */
    public function curveGetTokensHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $token_id = null, string $contentType = self::contentTypes['curveGetTokensHistorical'][0])
    {
        list($response) = $this->curveGetTokensHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $token_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetTokensHistoricalWithHttpInfo
     *
     * Tokens (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $token_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokensHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveTokenDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetTokensHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $token_id = null, string $contentType = self::contentTypes['curveGetTokensHistorical'][0])
    {
        $request = $this->curveGetTokensHistoricalRequest($start_block, $end_block, $start_date, $end_date, $token_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveTokenDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveTokenDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveTokenDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveTokenDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveTokenDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetTokensHistoricalAsync
     *
     * Tokens (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $token_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokensHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTokensHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $token_id = null, string $contentType = self::contentTypes['curveGetTokensHistorical'][0])
    {
        return $this->curveGetTokensHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $token_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetTokensHistoricalAsyncWithHttpInfo
     *
     * Tokens (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $token_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokensHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTokensHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $token_id = null, string $contentType = self::contentTypes['curveGetTokensHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveTokenDTO[]';
        $request = $this->curveGetTokensHistoricalRequest($start_block, $end_block, $start_date, $end_date, $token_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetTokensHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $token_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTokensHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetTokensHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $token_id = null, string $contentType = self::contentTypes['curveGetTokensHistorical'][0])
    {







        $resourcePath = '/dapps/curve/tokens/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $token_id,
            'tokenId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetTransferOwnershipEventDTOsHistorical
     *
     * TransferOwnershipEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]
     */
    public function curveGetTransferOwnershipEventDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'][0])
    {
        list($response) = $this->curveGetTransferOwnershipEventDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetTransferOwnershipEventDTOsHistoricalWithHttpInfo
     *
     * TransferOwnershipEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetTransferOwnershipEventDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'][0])
    {
        $request = $this->curveGetTransferOwnershipEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetTransferOwnershipEventDTOsHistoricalAsync
     *
     * TransferOwnershipEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTransferOwnershipEventDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'][0])
    {
        return $this->curveGetTransferOwnershipEventDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetTransferOwnershipEventDTOsHistoricalAsyncWithHttpInfo
     *
     * TransferOwnershipEventDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTransferOwnershipEventDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]';
        $request = $this->curveGetTransferOwnershipEventDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetTransferOwnershipEventDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetTransferOwnershipEventDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/TransferOwnershipEventDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetTransferOwnershipEventsHistorical
     *
     * TransferOwnershipEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]
     */
    public function curveGetTransferOwnershipEventsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventsHistorical'][0])
    {
        list($response) = $this->curveGetTransferOwnershipEventsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetTransferOwnershipEventsHistoricalWithHttpInfo
     *
     * TransferOwnershipEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetTransferOwnershipEventsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventsHistorical'][0])
    {
        $request = $this->curveGetTransferOwnershipEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetTransferOwnershipEventsHistoricalAsync
     *
     * TransferOwnershipEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTransferOwnershipEventsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventsHistorical'][0])
    {
        return $this->curveGetTransferOwnershipEventsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetTransferOwnershipEventsHistoricalAsyncWithHttpInfo
     *
     * TransferOwnershipEvents (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetTransferOwnershipEventsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveTransferOwnershipEventDTO[]';
        $request = $this->curveGetTransferOwnershipEventsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetTransferOwnershipEventsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetTransferOwnershipEventsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetTransferOwnershipEventsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetTransferOwnershipEventsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/transferOwnershipEvents/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetUnderlyingCoinDTOsHistorical
     *
     * UnderlyingCoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]
     */
    public function curveGetUnderlyingCoinDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'][0])
    {
        list($response) = $this->curveGetUnderlyingCoinDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetUnderlyingCoinDTOsHistoricalWithHttpInfo
     *
     * UnderlyingCoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveUnderlyingCoinDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetUnderlyingCoinDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'][0])
    {
        $request = $this->curveGetUnderlyingCoinDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetUnderlyingCoinDTOsHistoricalAsync
     *
     * UnderlyingCoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetUnderlyingCoinDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'][0])
    {
        return $this->curveGetUnderlyingCoinDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetUnderlyingCoinDTOsHistoricalAsyncWithHttpInfo
     *
     * UnderlyingCoinDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetUnderlyingCoinDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]';
        $request = $this->curveGetUnderlyingCoinDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetUnderlyingCoinDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetUnderlyingCoinDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/UnderlyingCoinDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetUnderlyingCoinsHistorical
     *
     * UnderlyingCoins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]
     */
    public function curveGetUnderlyingCoinsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinsHistorical'][0])
    {
        list($response) = $this->curveGetUnderlyingCoinsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetUnderlyingCoinsHistoricalWithHttpInfo
     *
     * UnderlyingCoins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveUnderlyingCoinDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetUnderlyingCoinsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinsHistorical'][0])
    {
        $request = $this->curveGetUnderlyingCoinsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetUnderlyingCoinsHistoricalAsync
     *
     * UnderlyingCoins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetUnderlyingCoinsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinsHistorical'][0])
    {
        return $this->curveGetUnderlyingCoinsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetUnderlyingCoinsHistoricalAsyncWithHttpInfo
     *
     * UnderlyingCoins (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetUnderlyingCoinsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveUnderlyingCoinDTO[]';
        $request = $this->curveGetUnderlyingCoinsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetUnderlyingCoinsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetUnderlyingCoinsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetUnderlyingCoinsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetUnderlyingCoinsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/underlyingCoins/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetVotingAppDTOsHistorical
     *
     * VotingAppDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveVotingAppDTO[]
     */
    public function curveGetVotingAppDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetVotingAppDTOsHistorical'][0])
    {
        list($response) = $this->curveGetVotingAppDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetVotingAppDTOsHistoricalWithHttpInfo
     *
     * VotingAppDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveVotingAppDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetVotingAppDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetVotingAppDTOsHistorical'][0])
    {
        $request = $this->curveGetVotingAppDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveVotingAppDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveVotingAppDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveVotingAppDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveVotingAppDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveVotingAppDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetVotingAppDTOsHistoricalAsync
     *
     * VotingAppDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetVotingAppDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetVotingAppDTOsHistorical'][0])
    {
        return $this->curveGetVotingAppDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetVotingAppDTOsHistoricalAsyncWithHttpInfo
     *
     * VotingAppDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetVotingAppDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetVotingAppDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveVotingAppDTO[]';
        $request = $this->curveGetVotingAppDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetVotingAppDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetVotingAppDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetVotingAppDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/VotingAppDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetVotingAppsHistorical
     *
     * VotingApps (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveVotingAppDTO[]
     */
    public function curveGetVotingAppsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetVotingAppsHistorical'][0])
    {
        list($response) = $this->curveGetVotingAppsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation curveGetVotingAppsHistoricalWithHttpInfo
     *
     * VotingApps (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveVotingAppDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetVotingAppsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetVotingAppsHistorical'][0])
    {
        $request = $this->curveGetVotingAppsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveVotingAppDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveVotingAppDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveVotingAppDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveVotingAppDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveVotingAppDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetVotingAppsHistoricalAsync
     *
     * VotingApps (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetVotingAppsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetVotingAppsHistorical'][0])
    {
        return $this->curveGetVotingAppsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetVotingAppsHistoricalAsyncWithHttpInfo
     *
     * VotingApps (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetVotingAppsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetVotingAppsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveVotingAppDTO[]';
        $request = $this->curveGetVotingAppsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetVotingAppsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetVotingAppsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetVotingAppsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, string $contentType = self::contentTypes['curveGetVotingAppsHistorical'][0])
    {






        $resourcePath = '/dapps/curve/votingApps/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetWeeklyVolumeDTOsHistorical
     *
     * WeeklyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]
     */
    public function curveGetWeeklyVolumeDTOsHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'][0])
    {
        list($response) = $this->curveGetWeeklyVolumeDTOsHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetWeeklyVolumeDTOsHistoricalWithHttpInfo
     *
     * WeeklyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveWeeklyVolumeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetWeeklyVolumeDTOsHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'][0])
    {
        $request = $this->curveGetWeeklyVolumeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetWeeklyVolumeDTOsHistoricalAsync
     *
     * WeeklyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetWeeklyVolumeDTOsHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'][0])
    {
        return $this->curveGetWeeklyVolumeDTOsHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetWeeklyVolumeDTOsHistoricalAsyncWithHttpInfo
     *
     * WeeklyVolumeDTOs (historical) ðŸ”¥
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetWeeklyVolumeDTOsHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]';
        $request = $this->curveGetWeeklyVolumeDTOsHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetWeeklyVolumeDTOsHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetWeeklyVolumeDTOsHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumeDTOsHistorical'][0])
    {







        $resourcePath = '/dapps/curve/WeeklyVolumeDTOs/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation curveGetWeeklyVolumesHistorical
     *
     * WeeklyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]
     */
    public function curveGetWeeklyVolumesHistorical($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumesHistorical'][0])
    {
        list($response) = $this->curveGetWeeklyVolumesHistoricalWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation curveGetWeeklyVolumesHistoricalWithHttpInfo
     *
     * WeeklyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CurveWeeklyVolumeDTO[], HTTP status code, HTTP response headers (array of strings)
     */
    public function curveGetWeeklyVolumesHistoricalWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumesHistorical'][0])
    {
        $request = $this->curveGetWeeklyVolumesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation curveGetWeeklyVolumesHistoricalAsync
     *
     * WeeklyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetWeeklyVolumesHistoricalAsync($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumesHistorical'][0])
    {
        return $this->curveGetWeeklyVolumesHistoricalAsyncWithHttpInfo($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation curveGetWeeklyVolumesHistoricalAsyncWithHttpInfo
     *
     * WeeklyVolumes (historical)
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function curveGetWeeklyVolumesHistoricalAsyncWithHttpInfo($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumesHistorical'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CurveWeeklyVolumeDTO[]';
        $request = $this->curveGetWeeklyVolumesHistoricalRequest($start_block, $end_block, $start_date, $end_date, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'curveGetWeeklyVolumesHistorical'
     *
     * @param  int $start_block  (optional)
     * @param  int $end_block  (optional)
     * @param  \DateTime $start_date  (optional)
     * @param  \DateTime $end_date  (optional)
     * @param  string $pool_id  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['curveGetWeeklyVolumesHistorical'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function curveGetWeeklyVolumesHistoricalRequest($start_block = null, $end_block = null, $start_date = null, $end_date = null, $pool_id = null, string $contentType = self::contentTypes['curveGetWeeklyVolumesHistorical'][0])
    {







        $resourcePath = '/dapps/curve/weeklyVolumes/historical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_block,
            'startBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_block,
            'endBlock', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'startDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'endDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $pool_id,
            'poolId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
