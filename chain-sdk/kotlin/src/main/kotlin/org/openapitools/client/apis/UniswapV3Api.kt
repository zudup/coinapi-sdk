/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import org.openapitools.client.models.UniswapV3BundleDTO
import org.openapitools.client.models.UniswapV3BurnDTO
import org.openapitools.client.models.UniswapV3FactoryDTO
import org.openapitools.client.models.UniswapV3MintDTO
import org.openapitools.client.models.UniswapV3PoolDTO
import org.openapitools.client.models.UniswapV3PoolDayDataDTO
import org.openapitools.client.models.UniswapV3PoolHourDataDTO
import org.openapitools.client.models.UniswapV3PositionDTO
import org.openapitools.client.models.UniswapV3PositionSnapshotDTO
import org.openapitools.client.models.UniswapV3SwapDTO
import org.openapitools.client.models.UniswapV3TickDTO
import org.openapitools.client.models.UniswapV3TickDayDataDTO
import org.openapitools.client.models.UniswapV3TokenDTO
import org.openapitools.client.models.UniswapV3TokenHourDataDTO
import org.openapitools.client.models.UniswapV3TokenV3DayDataDTO
import org.openapitools.client.models.UniswapV3TransactionDTO
import org.openapitools.client.models.UniswapV3UniswapDayDataDTO

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UniswapV3Api(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://onchain.coinapi.io")
        }
    }

    /**
     * Bundles (current)
     * Gets bundles.
     * @return kotlin.collections.List<UniswapV3BundleDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3BundlesCurrent() : kotlin.collections.List<UniswapV3BundleDTO> {
        val localVarResponse = uniswapV3BundlesCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BundleDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bundles (current)
     * Gets bundles.
     * @return ApiResponse<kotlin.collections.List<UniswapV3BundleDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3BundlesCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3BundleDTO>?> {
        val localVariableConfig = uniswapV3BundlesCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3BundleDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3BundlesCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3BundlesCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/bundles/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Burns (current)
     * Gets burns.
     * @return kotlin.collections.List<UniswapV3BurnDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3BurnsCurrent() : kotlin.collections.List<UniswapV3BurnDTO> {
        val localVarResponse = uniswapV3BurnsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BurnDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Burns (current)
     * Gets burns.
     * @return ApiResponse<kotlin.collections.List<UniswapV3BurnDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3BurnsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3BurnDTO>?> {
        val localVariableConfig = uniswapV3BurnsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3BurnDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3BurnsCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3BurnsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/burns/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Factorys (current)
     * Gets factorys.
     * @return kotlin.collections.List<UniswapV3FactoryDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3FactorysCurrent() : kotlin.collections.List<UniswapV3FactoryDTO> {
        val localVarResponse = uniswapV3FactorysCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3FactoryDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Factorys (current)
     * Gets factorys.
     * @return ApiResponse<kotlin.collections.List<UniswapV3FactoryDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3FactorysCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3FactoryDTO>?> {
        val localVariableConfig = uniswapV3FactorysCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3FactoryDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3FactorysCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3FactorysCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/factorys/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Bundles (historical) ðŸ”¥
     * Gets bundles.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id  (optional)
     * @return kotlin.collections.List<UniswapV3BundleDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetBundlesHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3BundleDTO> {
        val localVarResponse = uniswapV3GetBundlesHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BundleDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Bundles (historical) ðŸ”¥
     * Gets bundles.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3BundleDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetBundlesHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3BundleDTO>?> {
        val localVariableConfig = uniswapV3GetBundlesHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3BundleDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetBundlesHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetBundlesHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/bundles/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Burns (historical) ðŸ”¥
     * Gets burns.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return kotlin.collections.List<UniswapV3BurnDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetBurnsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3BurnDTO> {
        val localVarResponse = uniswapV3GetBurnsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3BurnDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Burns (historical) ðŸ”¥
     * Gets burns.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3BurnDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetBurnsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3BurnDTO>?> {
        val localVariableConfig = uniswapV3GetBurnsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3BurnDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetBurnsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetBurnsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/burns/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Factorys (historical) ðŸ”¥
     * Gets factorys.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return kotlin.collections.List<UniswapV3FactoryDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetFactorysHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3FactoryDTO> {
        val localVarResponse = uniswapV3GetFactorysHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3FactoryDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Factorys (historical) ðŸ”¥
     * Gets factorys.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3FactoryDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetFactorysHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3FactoryDTO>?> {
        val localVariableConfig = uniswapV3GetFactorysHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3FactoryDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetFactorysHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Factory address. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetFactorysHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/factorys/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Mints (historical) ðŸ”¥
     * Gets mints.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return kotlin.collections.List<UniswapV3MintDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetMintsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3MintDTO> {
        val localVarResponse = uniswapV3GetMintsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3MintDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Mints (historical) ðŸ”¥
     * Gets mints.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3MintDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetMintsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3MintDTO>?> {
        val localVariableConfig = uniswapV3GetMintsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3MintDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetMintsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash + &#39;#&#39; + index in mints Transaction array. (optional)
     * @param pool Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetMintsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/mints/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolDayDatas (historical) ðŸ”¥
     * Gets poolDayDatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3PoolDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolDayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolDayDataDTO> {
        val localVarResponse = uniswapV3GetPoolDayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolDayDatas (historical) ðŸ”¥
     * Gets poolDayDatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolDayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataDTO>?> {
        val localVariableConfig = uniswapV3GetPoolDayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3PoolDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolDayDatasHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolDayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolDayDatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolHourDatas (historical) ðŸ”¥
     * Gets poolHourDatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3PoolHourDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolHourDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolHourDataDTO> {
        val localVarResponse = uniswapV3GetPoolHourDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolHourDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolHourDatas (historical) ðŸ”¥
     * Gets poolHourDatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolHourDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataDTO>?> {
        val localVariableConfig = uniswapV3GetPoolHourDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3PoolHourDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolHourDatasHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolHourDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolHourDatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Pools (historical) ðŸ”¥
     * Gets pools.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return kotlin.collections.List<UniswapV3PoolDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPoolsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolDTO> {
        val localVarResponse = uniswapV3GetPoolsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pools (historical) ðŸ”¥
     * Gets pools.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPoolsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolDTO>?> {
        val localVariableConfig = uniswapV3GetPoolsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3PoolDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPoolsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Pool address. (optional)
     * @param token0 Reference to token0 as stored in pool contract. (optional)
     * @param token1 Reference to token1 as stored in pool contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPoolsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/pools/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PositionSnapshots (historical) ðŸ”¥
     * Gets positionSnapshots.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3PositionSnapshotDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPositionSnapshotsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3PositionSnapshotDTO> {
        val localVarResponse = uniswapV3GetPositionSnapshotsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionSnapshotDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PositionSnapshots (historical) ðŸ”¥
     * Gets positionSnapshots.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPositionSnapshotsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotDTO>?> {
        val localVariableConfig = uniswapV3GetPositionSnapshotsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3PositionSnapshotDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPositionSnapshotsHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPositionSnapshotsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positionSnapshots/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Positions (historical) ðŸ”¥
     * Gets positions.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id NFT token identifier. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return kotlin.collections.List<UniswapV3PositionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetPositionsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3PositionDTO> {
        val localVarResponse = uniswapV3GetPositionsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Positions (historical) ðŸ”¥
     * Gets positions.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id NFT token identifier. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetPositionsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PositionDTO>?> {
        val localVariableConfig = uniswapV3GetPositionsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3PositionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetPositionsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id NFT token identifier. (optional)
     * @param pool Pool position is within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetPositionsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positions/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Swaps (historical) ðŸ”¥
     * Gets swaps.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array. (optional)
     * @param pool Pool swap occured within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return kotlin.collections.List<UniswapV3SwapDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetSwapsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null, token0: kotlin.String? = null, token1: kotlin.String? = null) : kotlin.collections.List<UniswapV3SwapDTO> {
        val localVarResponse = uniswapV3GetSwapsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3SwapDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Swaps (historical) ðŸ”¥
     * Gets swaps.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array. (optional)
     * @param pool Pool swap occured within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3SwapDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetSwapsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3SwapDTO>?> {
        val localVariableConfig = uniswapV3GetSwapsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool, token0 = token0, token1 = token1)

        return request<Unit, kotlin.collections.List<UniswapV3SwapDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetSwapsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Identifier, format: transaction hash + \&quot;#\&quot; + index in swaps Transaction array. (optional)
     * @param pool Pool swap occured within. (optional)
     * @param token0 Reference to token0 as stored in pair contract. (optional)
     * @param token1 Reference to token1 as stored in pair contract. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetSwapsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?, token0: kotlin.String?, token1: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
                if (token0 != null) {
                    put("token_0", listOf(token0.toString()))
                }
                if (token1 != null) {
                    put("token_1", listOf(token1.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/swaps/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TickDayDatas (historical) ðŸ”¥
     * Gets tickDayDatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3TickDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTickDayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3TickDayDataDTO> {
        val localVarResponse = uniswapV3GetTickDayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TickDayDatas (historical) ðŸ”¥
     * Gets tickDayDatas.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTickDayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TickDayDataDTO>?> {
        val localVariableConfig = uniswapV3GetTickDayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3TickDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTickDayDatasHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTickDayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tickDayDatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Ticks (historical) ðŸ”¥
     * Gets ticks.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return kotlin.collections.List<UniswapV3TickDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTicksHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3TickDTO> {
        val localVarResponse = uniswapV3GetTicksHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Ticks (historical) ðŸ”¥
     * Gets ticks.
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTicksHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TickDTO>?> {
        val localVariableConfig = uniswapV3GetTicksHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3TickDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTicksHistorical
     *
     * @param startBlock  (optional)
     * @param endBlock  (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @param id  (optional)
     * @param pool  (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTicksHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/ticks/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenHourDatas (historical) ðŸ”¥
     * Gets tokenHourDatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return kotlin.collections.List<UniswapV3TokenHourDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokenHourDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenHourDataDTO> {
        val localVarResponse = uniswapV3GetTokenHourDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenHourDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenHourDatas (historical) ðŸ”¥
     * Gets tokenHourDatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokenHourDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataDTO>?> {
        val localVariableConfig = uniswapV3GetTokenHourDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3TokenHourDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokenHourDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokenHourDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenHourDatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenV3DayDatas (historical) ðŸ”¥
     * Gets tokenV3DayDatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokenV3DayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenV3DayDataDTO> {
        val localVarResponse = uniswapV3GetTokenV3DayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenV3DayDatas (historical) ðŸ”¥
     * Gets tokenV3DayDatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokenV3DayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?> {
        val localVariableConfig = uniswapV3GetTokenV3DayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3TokenV3DayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokenV3DayDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address concatendated with date. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokenV3DayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenV3DayDatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Tokens (historical) ðŸ”¥
     * Gets tokens.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return kotlin.collections.List<UniswapV3TokenDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTokensHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null, symbol: kotlin.String? = null, name: kotlin.String? = null) : kotlin.collections.List<UniswapV3TokenDTO> {
        val localVarResponse = uniswapV3GetTokensHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, symbol = symbol, name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Tokens (historical) ðŸ”¥
     * Gets tokens.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTokensHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, symbol: kotlin.String?, name: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TokenDTO>?> {
        val localVariableConfig = uniswapV3GetTokensHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id, symbol = symbol, name = name)

        return request<Unit, kotlin.collections.List<UniswapV3TokenDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTokensHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Token address. (optional)
     * @param symbol Token symbol. (optional)
     * @param name Token name. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTokensHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?, symbol: kotlin.String?, name: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (symbol != null) {
                    put("symbol", listOf(symbol.toString()))
                }
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokens/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Transactions (historical) ðŸ”¥
     * Gets transactions.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash. (optional)
     * @return kotlin.collections.List<UniswapV3TransactionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetTransactionsHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3TransactionDTO> {
        val localVarResponse = uniswapV3GetTransactionsHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TransactionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Transactions (historical) ðŸ”¥
     * Gets transactions.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3TransactionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetTransactionsHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3TransactionDTO>?> {
        val localVariableConfig = uniswapV3GetTransactionsHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3TransactionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetTransactionsHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Transaction hash. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetTransactionsHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/transactions/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * UniswapDayDatas (historical) ðŸ”¥
     * Gets uniswapDayDatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Timestamp rounded to current day by dividing by 86400. (optional)
     * @return kotlin.collections.List<UniswapV3UniswapDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3GetUniswapDayDatasHistorical(startBlock: kotlin.Long? = null, endBlock: kotlin.Long? = null, startDate: java.time.OffsetDateTime? = null, endDate: java.time.OffsetDateTime? = null, id: kotlin.String? = null) : kotlin.collections.List<UniswapV3UniswapDayDataDTO> {
        val localVarResponse = uniswapV3GetUniswapDayDatasHistoricalWithHttpInfo(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3UniswapDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * UniswapDayDatas (historical) ðŸ”¥
     * Gets uniswapDayDatas.
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Timestamp rounded to current day by dividing by 86400. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3GetUniswapDayDatasHistoricalWithHttpInfo(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataDTO>?> {
        val localVariableConfig = uniswapV3GetUniswapDayDatasHistoricalRequestConfig(startBlock = startBlock, endBlock = endBlock, startDate = startDate, endDate = endDate, id = id)

        return request<Unit, kotlin.collections.List<UniswapV3UniswapDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3GetUniswapDayDatasHistorical
     *
     * @param startBlock The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock. (optional)
     * @param endBlock The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock). (optional)
     * @param startDate The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included. (optional)
     * @param endDate The end date of timeframe. (optional)
     * @param id Timestamp rounded to current day by dividing by 86400. (optional)
     * @return RequestConfig
     */
    fun uniswapV3GetUniswapDayDatasHistoricalRequestConfig(startBlock: kotlin.Long?, endBlock: kotlin.Long?, startDate: java.time.OffsetDateTime?, endDate: java.time.OffsetDateTime?, id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (startBlock != null) {
                    put("startBlock", listOf(startBlock.toString()))
                }
                if (endBlock != null) {
                    put("endBlock", listOf(endBlock.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(parseDateToQueryString(startDate)))
                }
                if (endDate != null) {
                    put("endDate", listOf(parseDateToQueryString(endDate)))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/uniswapDayDatas/historical",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Mints (current)
     * Gets mints.
     * @return kotlin.collections.List<UniswapV3MintDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3MintsCurrent() : kotlin.collections.List<UniswapV3MintDTO> {
        val localVarResponse = uniswapV3MintsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3MintDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Mints (current)
     * Gets mints.
     * @return ApiResponse<kotlin.collections.List<UniswapV3MintDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3MintsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3MintDTO>?> {
        val localVariableConfig = uniswapV3MintsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3MintDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3MintsCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3MintsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/mints/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolDayDatas (current)
     * Gets poolDayDatas.
     * @return kotlin.collections.List<UniswapV3PoolDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3PoolDayDatasCurrent() : kotlin.collections.List<UniswapV3PoolDayDataDTO> {
        val localVarResponse = uniswapV3PoolDayDatasCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolDayDatas (current)
     * Gets poolDayDatas.
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3PoolDayDatasCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3PoolDayDataDTO>?> {
        val localVariableConfig = uniswapV3PoolDayDatasCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3PoolDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3PoolDayDatasCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3PoolDayDatasCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolDayDatas/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PoolHourDatas (current)
     * Gets poolHourDatas.
     * @return kotlin.collections.List<UniswapV3PoolHourDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3PoolHourDatasCurrent() : kotlin.collections.List<UniswapV3PoolHourDataDTO> {
        val localVarResponse = uniswapV3PoolHourDatasCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolHourDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PoolHourDatas (current)
     * Gets poolHourDatas.
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3PoolHourDatasCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3PoolHourDataDTO>?> {
        val localVariableConfig = uniswapV3PoolHourDatasCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3PoolHourDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3PoolHourDatasCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3PoolHourDatasCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/poolHourDatas/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Pools (current)
     * Gets pools.
     * @param id Pool address. (optional)
     * @return kotlin.collections.List<UniswapV3PoolDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3PoolsCurrent(id: kotlin.String? = null) : kotlin.collections.List<UniswapV3PoolDTO> {
        val localVarResponse = uniswapV3PoolsCurrentWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PoolDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Pools (current)
     * Gets pools.
     * @param id Pool address. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3PoolDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3PoolsCurrentWithHttpInfo(id: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3PoolDTO>?> {
        val localVariableConfig = uniswapV3PoolsCurrentRequestConfig(id = id)

        return request<Unit, kotlin.collections.List<UniswapV3PoolDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3PoolsCurrent
     *
     * @param id Pool address. (optional)
     * @return RequestConfig
     */
    fun uniswapV3PoolsCurrentRequestConfig(id: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/pools/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * PositionSnapshots (current)
     * Gets positionSnapshots.
     * @return kotlin.collections.List<UniswapV3PositionSnapshotDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3PositionSnapshotsCurrent() : kotlin.collections.List<UniswapV3PositionSnapshotDTO> {
        val localVarResponse = uniswapV3PositionSnapshotsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionSnapshotDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PositionSnapshots (current)
     * Gets positionSnapshots.
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3PositionSnapshotsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3PositionSnapshotDTO>?> {
        val localVariableConfig = uniswapV3PositionSnapshotsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3PositionSnapshotDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3PositionSnapshotsCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3PositionSnapshotsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positionSnapshots/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Positions (current)
     * Gets positions.
     * @return kotlin.collections.List<UniswapV3PositionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3PositionsCurrent() : kotlin.collections.List<UniswapV3PositionDTO> {
        val localVarResponse = uniswapV3PositionsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3PositionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Positions (current)
     * Gets positions.
     * @return ApiResponse<kotlin.collections.List<UniswapV3PositionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3PositionsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3PositionDTO>?> {
        val localVariableConfig = uniswapV3PositionsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3PositionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3PositionsCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3PositionsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/positions/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Swaps (current)
     * Gets swaps.
     * @param pool Pool swap occured within. (optional)
     * @return kotlin.collections.List<UniswapV3SwapDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3SwapsCurrent(pool: kotlin.String? = null) : kotlin.collections.List<UniswapV3SwapDTO> {
        val localVarResponse = uniswapV3SwapsCurrentWithHttpInfo(pool = pool)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3SwapDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Swaps (current)
     * Gets swaps.
     * @param pool Pool swap occured within. (optional)
     * @return ApiResponse<kotlin.collections.List<UniswapV3SwapDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3SwapsCurrentWithHttpInfo(pool: kotlin.String?) : ApiResponse<kotlin.collections.List<UniswapV3SwapDTO>?> {
        val localVariableConfig = uniswapV3SwapsCurrentRequestConfig(pool = pool)

        return request<Unit, kotlin.collections.List<UniswapV3SwapDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3SwapsCurrent
     *
     * @param pool Pool swap occured within. (optional)
     * @return RequestConfig
     */
    fun uniswapV3SwapsCurrentRequestConfig(pool: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (pool != null) {
                    put("pool", listOf(pool.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/swaps/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TickDayDatas (current)
     * Gets tickDayDatas.
     * @return kotlin.collections.List<UniswapV3TickDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3TickDayDatasCurrent() : kotlin.collections.List<UniswapV3TickDayDataDTO> {
        val localVarResponse = uniswapV3TickDayDatasCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TickDayDatas (current)
     * Gets tickDayDatas.
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3TickDayDatasCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3TickDayDataDTO>?> {
        val localVariableConfig = uniswapV3TickDayDatasCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3TickDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3TickDayDatasCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3TickDayDatasCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tickDayDatas/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Ticks (current)
     * Gets ticks.
     * @return kotlin.collections.List<UniswapV3TickDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3TicksCurrent() : kotlin.collections.List<UniswapV3TickDTO> {
        val localVarResponse = uniswapV3TicksCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TickDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Ticks (current)
     * Gets ticks.
     * @return ApiResponse<kotlin.collections.List<UniswapV3TickDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3TicksCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3TickDTO>?> {
        val localVariableConfig = uniswapV3TicksCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3TickDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3TicksCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3TicksCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/ticks/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenHourDatas (current)
     * Gets tokenHourDatas.
     * @return kotlin.collections.List<UniswapV3TokenHourDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3TokenHourDatasCurrent() : kotlin.collections.List<UniswapV3TokenHourDataDTO> {
        val localVarResponse = uniswapV3TokenHourDatasCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenHourDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenHourDatas (current)
     * Gets tokenHourDatas.
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3TokenHourDatasCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3TokenHourDataDTO>?> {
        val localVariableConfig = uniswapV3TokenHourDatasCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3TokenHourDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3TokenHourDatasCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3TokenHourDatasCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenHourDatas/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * TokenV3DayDatas (current)
     * Gets tokenV3DayDatas.
     * @return kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3TokenV3DayDatasCurrent() : kotlin.collections.List<UniswapV3TokenV3DayDataDTO> {
        val localVarResponse = uniswapV3TokenV3DayDatasCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenV3DayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * TokenV3DayDatas (current)
     * Gets tokenV3DayDatas.
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3TokenV3DayDatasCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3TokenV3DayDataDTO>?> {
        val localVariableConfig = uniswapV3TokenV3DayDatasCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3TokenV3DayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3TokenV3DayDatasCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3TokenV3DayDatasCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokenV3DayDatas/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Tokens (current)
     * Gets tokens.
     * @return kotlin.collections.List<UniswapV3TokenDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3TokensCurrent() : kotlin.collections.List<UniswapV3TokenDTO> {
        val localVarResponse = uniswapV3TokensCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TokenDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Tokens (current)
     * Gets tokens.
     * @return ApiResponse<kotlin.collections.List<UniswapV3TokenDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3TokensCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3TokenDTO>?> {
        val localVariableConfig = uniswapV3TokensCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3TokenDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3TokensCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3TokensCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/tokens/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Transactions (current)
     * Gets transactions.
     * @return kotlin.collections.List<UniswapV3TransactionDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3TransactionsCurrent() : kotlin.collections.List<UniswapV3TransactionDTO> {
        val localVarResponse = uniswapV3TransactionsCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3TransactionDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Transactions (current)
     * Gets transactions.
     * @return ApiResponse<kotlin.collections.List<UniswapV3TransactionDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3TransactionsCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3TransactionDTO>?> {
        val localVariableConfig = uniswapV3TransactionsCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3TransactionDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3TransactionsCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3TransactionsCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/transactions/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * UniswapDayDatas (current)
     * Gets uniswapDayDatas.
     * @return kotlin.collections.List<UniswapV3UniswapDayDataDTO>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun uniswapV3UniswapDayDatasCurrent() : kotlin.collections.List<UniswapV3UniswapDayDataDTO> {
        val localVarResponse = uniswapV3UniswapDayDatasCurrentWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UniswapV3UniswapDayDataDTO>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * UniswapDayDatas (current)
     * Gets uniswapDayDatas.
     * @return ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataDTO>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun uniswapV3UniswapDayDatasCurrentWithHttpInfo() : ApiResponse<kotlin.collections.List<UniswapV3UniswapDayDataDTO>?> {
        val localVariableConfig = uniswapV3UniswapDayDatasCurrentRequestConfig()

        return request<Unit, kotlin.collections.List<UniswapV3UniswapDayDataDTO>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation uniswapV3UniswapDayDatasCurrent
     *
     * @return RequestConfig
     */
    fun uniswapV3UniswapDayDatasCurrentRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/dapps/uniswapv3/uniswapDayDatas/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
