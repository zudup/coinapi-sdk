// @flow
/* eslint-disable no-use-before-define */
/**
 * OnChain API
 *  This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry\'s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             
 *
 * The version of the OpenAPI document: v1
 * Contact: support@coinapi.io
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://onchain.coinapi.io".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type CowOrderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowOrderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowOrderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowOrderDTO
     */
    block_number?: number;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowOrderDTO
     */
    id?: string;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowOrderDTO
     */
    owner?: string;
    /**
     * Block\'s timestamp on trade event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    trades_timestamp?: string;
    /**
     * Block\'s timestamp on invalidate event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    invalidate_timestamp?: string;
    /**
     * Block\'s timestamp on presign event.
     * @type {string}
     * @memberof CowOrderDTO
     */
    presign_timestamp?: string;
    /**
     * Determines whether order is signed.
     * @type {boolean}
     * @memberof CowOrderDTO
     */
    is_signed?: boolean;
    /**
     * Determines whether order is valid.
     * @type {boolean}
     * @memberof CowOrderDTO
     */
    is_valid?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CowOrderDTO
     */
    vid?: number;
}

/**
 * A settlement comprises a list of traded tokens with their corresponding price in the batch.
 * @export
 */
export type CowSettlementDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowSettlementDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowSettlementDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowSettlementDTO
     */
    block_number?: number;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    id?: string;
    /**
     * Solver\'s address.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    solver?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    tx_hash?: string;
    /**
     * First trade timestamp.
     * @type {string}
     * @memberof CowSettlementDTO
     */
    first_trade_timestamp?: string;
    /**
     * 
     * @type {number}
     * @memberof CowSettlementDTO
     */
    vid?: number;
}

/**
 * Stores information for a specific token across all pairs that token is included in.
 * @export
 */
export type CowTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowTokenDTO
     */
    block_number?: number;
    /**
     * Token\'s address.
     * @type {string}
     * @memberof CowTokenDTO
     */
    id?: string;
    /**
     * Token\'s address.
     * @type {string}
     * @memberof CowTokenDTO
     */
    address?: string;
    /**
     * First token trade block timestamp.
     * @type {string}
     * @memberof CowTokenDTO
     */
    first_trade_timestamp?: string;
    /**
     * Token name fetched by ERC20 contract call.
     * @type {string}
     * @memberof CowTokenDTO
     */
    name?: string;
    /**
     * Token symbol fetched by contract call.
     * @type {string}
     * @memberof CowTokenDTO
     */
    symbol?: string;
    /**
     * Token decimals fetched by contract call.
     * @type {number}
     * @memberof CowTokenDTO
     */
    decimals?: number;
    /**
     * Sum of total amount traded for this token.
     * @type {string}
     * @memberof CowTokenDTO
     */
    total_volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CowTokenDTO
     */
    token_symbol?: string;
}

/**
 * Trade entity.
 * @export
 */
export type CowTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowTradeDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <order id>|<transaction hash>|<event index>.
     * @type {string}
     * @memberof CowTradeDTO
     */
    id?: string;
    /**
     * Block\'s timestamp.
     * @type {string}
     * @memberof CowTradeDTO
     */
    timestamp?: string;
    /**
     * Transaction\'s gas price.
     * @type {string}
     * @memberof CowTradeDTO
     */
    gas_price?: string;
    /**
     * Transaction\'s gas limit.
     * @type {string}
     * @memberof CowTradeDTO
     */
    gas_limit?: string;
    /**
     * Trade\'s fee amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    fee_amount?: string;
    /**
     * Trade event transaction hash.
     * @type {string}
     * @memberof CowTradeDTO
     */
    tx_hash?: string;
    /**
     * Reference to settlement.
     * @type {string}
     * @memberof CowTradeDTO
     */
    settlement?: string;
    /**
     * Buy amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    buy_amount?: string;
    /**
     * Sell amount.
     * @type {string}
     * @memberof CowTradeDTO
     */
    sell_amount?: string;
    /**
     * Address of token that is sold.
     * @type {string}
     * @memberof CowTradeDTO
     */
    sell_token?: string;
    /**
     * Address of token that is bought.
     * @type {string}
     * @memberof CowTradeDTO
     */
    buy_token?: string;
    /**
     * Reference to order.
     * @type {string}
     * @memberof CowTradeDTO
     */
    order?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CowTradeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CowTradeDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CowTradeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CowTradeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * 
 * @export
 */
export type CowUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CowUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CowUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CowUserDTO
     */
    block_number?: number;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowUserDTO
     */
    id?: string;
    /**
     * User\'s address.
     * @type {string}
     * @memberof CowUserDTO
     */
    address?: string;
    /**
     * First trade block timestamp.
     * @type {string}
     * @memberof CowUserDTO
     */
    first_trade_timestamp?: string;
    /**
     * Determines if user has solved a settlement.
     * @type {boolean}
     * @memberof CowUserDTO
     */
    is_solver?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CowUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAccountDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAccountDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAccountDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAccountDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAccountDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAccountDTO
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAccountDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAddLiquidityEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAddLiquidityEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAddLiquidityEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAddLiquidityEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveAddLiquidityEventDTO
     */
    token_amounts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveAddLiquidityEventDTO
     */
    fees?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    invariant?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    token_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAddLiquidityEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAddLiquidityEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAdminFeeChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAdminFeeChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveAmplificationCoeffChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveAmplificationCoeffChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveCoinDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveCoinDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveCoinDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveCoinDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool_id>-<coin_index>.
     * @type {string}
     * @memberof CurveCoinDTO
     */
    id?: string;
    /**
     * Coin index.
     * @type {number}
     * @memberof CurveCoinDTO
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    underlying?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    balance?: string;
    /**
     * Exchange rate between this coin and the associated underlying coin within the pool.
     * @type {string}
     * @memberof CurveCoinDTO
     */
    rate?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveCoinDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveCoinDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveContractDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveContractDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveContractDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveContractDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    id?: string;
    /**
     * Human-readable description.
     * @type {string}
     * @memberof CurveContractDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractDTO
     */
    modified_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveContractDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveContractVersionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveContractVersionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveContractVersionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveContractVersionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    contract?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveContractVersionDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveContractVersionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveDailyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveDailyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveDailyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveDailyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveDailyVolumeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveDailyVolumeDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveExchangeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveExchangeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveExchangeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    buyer?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    receiver?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    token_sold?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    token_bought?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    amount_sold?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    amount_bought?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof CurveExchangeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof CurveExchangeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveExchangeDTO
     */
    transaction_id?: string;
}

/**
 * 
 * @export
 */
export type CurveFeeChangeLogDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveFeeChangeLogDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveFeeChangeLogDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveFeeChangeLogDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveFeeChangeLogDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveFeeChangeLogDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeDepositDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeDepositDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeDepositDTO
     */
    block_range?: string;
}

/**
 * 
 * @export
 */
export type CurveGaugeLiquidityDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeLiquidityDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeLiquidityDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeLiquidityDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    original_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    original_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    working_balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    working_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeLiquidityDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeLiquidityDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTotalWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTotalWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTotalWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTotalWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTotalWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTotalWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTypeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTypeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeDTO
     */
    gauge_count?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTypeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeTypeWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeTypeWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeTypeWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeTypeWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeTypeWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWeightDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWeightDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWeightDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWeightVoteDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightVoteDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWeightVoteDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWeightVoteDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWeightVoteDTO
     */
    weight?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWeightVoteDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveGaugeWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveGaugeWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveGaugeWithdrawDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveGaugeWithdrawDTO
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveGaugeWithdrawDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveHourlyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveHourlyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveHourlyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveHourlyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveHourlyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveHourlyVolumeDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveLpTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveLpTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveLpTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveLpTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    gauge?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveLpTokenDTO
     */
    pool?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveLpTokenDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurvePoolDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurvePoolDTO
     */
    block_number?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    id?: string;
    /**
     * Pool\'s human-readable name.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    name?: string;
    /**
     * Identify whether pool is a metapool.
     * @type {boolean}
     * @memberof CurvePoolDTO
     */
    is_meta?: boolean;
    /**
     * Registry contract address from where this pool was registered.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    registry_address?: string;
    /**
     * Swap contract address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    swap_address?: string;
    /**
     * Address of the token representing LP share.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    lp_token?: string;
    /**
     * Number of coins composing the pool.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    coin_count?: string;
    /**
     * Number of underlying coins composing the pool.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    underlying_count?: string;
    /**
     * Amplification coefficient multiplied by n * (n - 1).
     * @type {string}
     * @memberof CurvePoolDTO
     */
    a?: string;
    /**
     * Fee to charge for exchanges.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    fee?: string;
    /**
     * Admin fee is represented as a percentage of the total fee collected on a swap.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    admin_fee?: string;
    /**
     * Admin address.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    owner?: string;
    /**
     * Average dollar value of pool token.
     * @type {string}
     * @memberof CurvePoolDTO
     */
    virtual_price?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    locked?: string;
    /**
     * 
     * @type {Date}
     * @memberof CurvePoolDTO
     */
    added_at?: Date;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    added_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    added_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    removed_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    exchange_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurvePoolDTO
     */
    gauge_count?: string;
    /**
     * 
     * @type {number}
     * @memberof CurvePoolDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof CurvePoolDTO
     */
    evaluated_ask?: number;
}

/**
 * 
 * @export
 */
export type CurveProposalDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveProposalDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    id?: string;
    /**
     * Sequential number in related to the realted voting app.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    _number?: string;
    /**
     * Voting app instance.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    app?: string;
    /**
     * Proposal creator\'s account.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    creator?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    execution_script?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    expire_date?: string;
    /**
     * Percentage of positive votes in total possible votes for this proposal to be accepted.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    minimum_quorum?: string;
    /**
     * Percentage of positive votes needed for this proposal to be accepted.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    required_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    snapshot_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    voting_power?: string;
    /**
     * Link to metadata file.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    metadata?: string;
    /**
     * Proposal description text.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    text?: string;
    /**
     * Number of votes received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    vote_count?: string;
    /**
     * Number of positive votes (yes) received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    positive_vote_count?: string;
    /**
     * Number of negative votes (no) received by the proposal.
     * @type {string}
     * @memberof CurveProposalDTO
     */
    negative_vote_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    current_quorum?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    current_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    staked_support?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    total_staked?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalDTO
     */
    executed_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveProposalDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveProposalVoteDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalVoteDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveProposalVoteDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveProposalVoteDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    proposal?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CurveProposalVoteDTO
     */
    supports?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    stake?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    voter?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveProposalVoteDTO
     */
    created_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveProposalVoteDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveRemoveLiquidityEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    token_amounts?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    fees?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    token_supply?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    invariant?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveRemoveLiquidityEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveRemoveLiquidityOneEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    token_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    coin_amount?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveRemoveLiquidityOneEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveSystemStateDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveSystemStateDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveSystemStateDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveSystemStateDTO
     */
    block_number?: number;
    /**
     * Singleton ID, equals to \'current\'.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    id?: string;
    /**
     * Current pool registry address.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    registry_contract?: string;
    /**
     * Number of contracts in the AddressProvider registry.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    contract_count?: string;
    /**
     * Number of gauges registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    gauge_count?: string;
    /**
     * Number of gauge types registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    gauge_type_count?: string;
    /**
     * Number of active pools.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    pool_count?: string;
    /**
     * Number of tokens registered.
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    token_count?: string;
    /**
     * Total number of pools (including removed ones).
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    total_pool_count?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveSystemStateDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveSystemStateDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CurveTokenDTO
     */
    pools?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CurveTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTokenDTO
     */
    token_symbol?: string;
}

/**
 * 
 * @export
 */
export type CurveTransferOwnershipEventDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveTransferOwnershipEventDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveTransferOwnershipEventDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveTransferOwnershipEventDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    new_admin?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveTransferOwnershipEventDTO
     */
    transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveTransferOwnershipEventDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveUnderlyingCoinDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveUnderlyingCoinDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveUnderlyingCoinDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    block_number?: number;
    /**
     * Equals to: <pool_id>-<coin_index>.
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    id?: string;
    /**
     * Coin index.
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    coin?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    balance?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated_at_block?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveUnderlyingCoinDTO
     */
    updated_at_transaction?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveUnderlyingCoinDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveVotingAppDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveVotingAppDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveVotingAppDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveVotingAppDTO
     */
    block_number?: number;
    /**
     * App address.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    codename?: string;
    /**
     * Minimum balance needed to create a proposal.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_balance?: string;
    /**
     * Percentage of positive votes in total possible votes for a proposal to be accepted.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_quorum?: string;
    /**
     * Minimum time needed to pass between user\'s previous proposal and a user creating a new proposal.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    minimum_time?: string;
    /**
     * Percentage of positive votes needed for a proposal to be accepted.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    required_support?: string;
    /**
     * Seconds that a proposal will be open for vote (unless enough votes have been cast to make an early decision).
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    vote_time?: string;
    /**
     * Number of proposals created with this app.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    proposal_count?: string;
    /**
     * Number of votes received by all the proposals created with this app.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    vote_count?: string;
    /**
     * Address of the token used for voting.
     * @type {string}
     * @memberof CurveVotingAppDTO
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveVotingAppDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type CurveWeeklyVolumeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof CurveWeeklyVolumeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CurveWeeklyVolumeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof CurveWeeklyVolumeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof CurveWeeklyVolumeDTO
     */
    volume?: string;
    /**
     * 
     * @type {number}
     * @memberof CurveWeeklyVolumeDTO
     */
    vid?: number;
}

/**
 * Batch executed. Every batch will contain at least solution with the a set of trades that are executed in it
 * @export
 */
export type DexBatchDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexBatchDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexBatchDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexBatchDTO
     */
    block_number?: number;
    /**
     * Identifier.
     * @type {string}
     * @memberof DexBatchDTO
     */
    id?: string;
    /**
     * Start epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    start_epoch?: string;
    /**
     * End epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    end_epoch?: string;
    /**
     * Reference to solution.
     * @type {string}
     * @memberof DexBatchDTO
     */
    solution?: string;
    /**
     * First solution epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    first_solution_epoch?: string;
    /**
     * Last revert epoch.
     * @type {string}
     * @memberof DexBatchDTO
     */
    last_revert_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexBatchDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexBatchDTO
     */
    vid?: number;
}

/**
 * Deposit of an user.
 * @export
 */
export type DexDepositDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexDepositDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexDepositDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexDepositDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction hash>-<token id>.
     * @type {string}
     * @memberof DexDepositDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof DexDepositDTO
     */
    user?: string;
    /**
     * Token address.
     * @type {string}
     * @memberof DexDepositDTO
     */
    token_address?: string;
    /**
     * Amount of deposit.
     * @type {string}
     * @memberof DexDepositDTO
     */
    amount?: string;
    /**
     * Identifier (numerical).
     * @type {string}
     * @memberof DexDepositDTO
     */
    batch_id?: string;
    /**
     * Create epoch.
     * @type {string}
     * @memberof DexDepositDTO
     */
    create_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexDepositDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexDepositDTO
     */
    vid?: number;
}

/**
 * Order submitted by an user. It has a validity (dates) so they can only be executed from/until some given batches. Partial executions of this trades must respect the limit price.
 * @export
 */
export type DexOrderDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexOrderDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexOrderDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexOrderDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <owner address>-<order id>
     * @type {string}
     * @memberof DexOrderDTO
     */
    id?: string;
    /**
     * Reference to owner.
     * @type {string}
     * @memberof DexOrderDTO
     */
    owner?: string;
    /**
     * Order id.
     * @type {number}
     * @memberof DexOrderDTO
     */
    order_id?: number;
    /**
     * Batch id from which order became valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    from_batch_id?: string;
    /**
     * Start of epoch in which order was placed and became valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    from_epoch?: string;
    /**
     * Batch id until which trade was still valid.
     * @type {string}
     * @memberof DexOrderDTO
     */
    until_batch_id?: string;
    /**
     * End of epoch in which order was placed.
     * @type {string}
     * @memberof DexOrderDTO
     */
    until_epoch?: string;
    /**
     * Identifier of token that was bought.
     * @type {string}
     * @memberof DexOrderDTO
     */
    buy_token?: string;
    /**
     * Identifier of token that was sold.
     * @type {string}
     * @memberof DexOrderDTO
     */
    sell_token?: string;
    /**
     * Price enumerator.
     * @type {string}
     * @memberof DexOrderDTO
     */
    price_numerator?: string;
    /**
     * Price denominator.
     * @type {string}
     * @memberof DexOrderDTO
     */
    price_denominator?: string;
    /**
     * Maximum sell amount.
     * @type {string}
     * @memberof DexOrderDTO
     */
    max_sell_amount?: string;
    /**
     * Minimum receive amount.
     * @type {string}
     * @memberof DexOrderDTO
     */
    min_receive_amount?: string;
    /**
     * Sold volume.
     * @type {string}
     * @memberof DexOrderDTO
     */
    sold_volume?: string;
    /**
     * Bought volume.
     * @type {string}
     * @memberof DexOrderDTO
     */
    bought_volume?: string;
    /**
     * Epoch in which order was created.
     * @type {string}
     * @memberof DexOrderDTO
     */
    create_epoch?: string;
    /**
     * Epoch in which order was cancelled.
     * @type {string}
     * @memberof DexOrderDTO
     */
    cancel_epoch?: string;
    /**
     * Epoch in which order was deleted.
     * @type {string}
     * @memberof DexOrderDTO
     */
    delete_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexOrderDTO
     */
    tx_hash?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof DexOrderDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexOrderDTO
     */
    vid?: number;
}

/**
 * Token price in conjuction with batch id.
 * @export
 */
export type DexPriceDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexPriceDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexPriceDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexPriceDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <token id>-<batch id>.
     * @type {string}
     * @memberof DexPriceDTO
     */
    id?: string;
    /**
     * Token identifier.
     * @type {string}
     * @memberof DexPriceDTO
     */
    token?: string;
    /**
     * Batch identifier.
     * @type {string}
     * @memberof DexPriceDTO
     */
    batch_id?: string;
    /**
     * Price enumerator in OWL (derivative of the GNO token).
     * @type {string}
     * @memberof DexPriceDTO
     */
    price_in_owl_numerator?: string;
    /**
     * Price denominator in OWL (derivative of the GNO token).
     * @type {string}
     * @memberof DexPriceDTO
     */
    price_in_owl_denominator?: string;
    /**
     * Volume.
     * @type {string}
     * @memberof DexPriceDTO
     */
    volume?: string;
    /**
     * Create epoch.
     * @type {string}
     * @memberof DexPriceDTO
     */
    create_epoch?: string;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof DexPriceDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexPriceDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type DexSolutionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexSolutionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexSolutionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexSolutionDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    batch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    solver?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    fee_reward?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    objective_value?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    utility?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DexSolutionDTO
     */
    trades?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    revert_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof DexSolutionDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexSolutionDTO
     */
    vid?: number;
}

/**
 * A type collecting global stats about this instance of Gnosis Protocol.
 * @export
 */
export type DexStatsDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexStatsDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexStatsDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexStatsDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexStatsDTO
     */
    id?: string;
    /**
     * The total volume denominated in OWL (all sell amounts combined).
     * @type {string}
     * @memberof DexStatsDTO
     */
    volume_in_owl?: string;
    /**
     * The total trader surplus in OWL.
     * @type {string}
     * @memberof DexStatsDTO
     */
    utility_in_owl?: string;
    /**
     * The total amount of OWL burnt (equivalent to fees rewarded to solvers).
     * @type {string}
     * @memberof DexStatsDTO
     */
    owl_burnt?: string;
    /**
     * The total number of settled batches.
     * @type {number}
     * @memberof DexStatsDTO
     */
    settled_batch_count?: number;
    /**
     * The total number of settled trades.
     * @type {number}
     * @memberof DexStatsDTO
     */
    settled_trade_count?: number;
    /**
     * The number of listed tokens.
     * @type {number}
     * @memberof DexStatsDTO
     */
    listed_tokens?: number;
    /**
     * 
     * @type {number}
     * @memberof DexStatsDTO
     */
    vid?: number;
}

/**
 * Registered token.
 * @export
 */
export type DexTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexTokenDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    decimals?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    name?: string;
    /**
     * Cumulative sell volume.
     * @type {string}
     * @memberof DexTokenDTO
     */
    sell_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTokenDTO
     */
    token_symbol?: string;
}

/**
 * Trade for a single user, as part of a ring trade. It\'s part of the solution submitted by a solver for a given batch.
 * @export
 */
export type DexTradeDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexTradeDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexTradeDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexTradeDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    order?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    sell_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    buy_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    trade_batch_id?: string;
    /**
     * The date of the end of the batch.
     * @type {string}
     * @memberof DexTradeDTO
     */
    trade_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    buy_token?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    sell_token?: string;
    /**
     * The date where the transaction was mined.
     * @type {string}
     * @memberof DexTradeDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    revert_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    tx_log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexTradeDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof DexTradeDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof DexTradeDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * User of the protocol. Any ethereum account that deposited tokens or traded.
 * @export
 */
export type DexUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexUserDTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexUserDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexUserDTO
     */
    vid?: number;
}

/**
 * Withdraw of an user.
 * @export
 */
export type DexWithdrawDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexWithdrawDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction hash>-<id>.
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    token_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    create_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexWithdrawDTO
     */
    vid?: number;
}

/**
 * Withdraw request of an user
 * @export
 */
export type DexWithdrawRequestDTO = {
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawRequestDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DexWithdrawRequestDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof DexWithdrawRequestDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction hash>-<id>.
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    token_address?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    amount?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    withdrawable_from_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    create_epoch?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    create_batch_id?: string;
    /**
     * 
     * @type {string}
     * @memberof DexWithdrawRequestDTO
     */
    tx_hash?: string;
    /**
     * 
     * @type {number}
     * @memberof DexWithdrawRequestDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type NumericsBigInteger = {
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_power_of_two?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_zero?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_one?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumericsBigInteger
     */
    is_even?: boolean;
    /**
     * 
     * @type {number}
     * @memberof NumericsBigInteger
     */
    sign?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD.
 * @export
 */
export type SushiswapBundleDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBundleDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    block_number?: number;
    /**
     * Hardcoded to \'1\'.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    id?: string;
    /**
     * Price of native.
     * @type {string}
     * @memberof SushiswapBundleDTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBundleDTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type SushiswapBurnDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapBurnDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction id>:<transaction.burns.length>.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    log_index?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SushiswapBurnDTO
     */
    complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapBurnDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapBurnDTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type SushiswapDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    _date?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    factory?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    untracked_volume?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof SushiswapDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapDayDataDTO
     */
    vid?: number;
}

/**
 * The Sushiswap Factory entity is responsible for storing aggregate information across all Sushiswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type SushiswapFactoryDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapFactoryDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Sushiswap factory.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    pair_count?: string;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    tx_count?: string;
    /**
     * Total count of tokens.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    token_count?: string;
    /**
     * Users count.
     * @type {string}
     * @memberof SushiswapFactoryDTO
     */
    user_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapFactoryDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    block_number?: number;
    /**
     * Start of hour timestamp.
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    _date?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    factory?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    volume_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    untracked_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    liquidity_usd?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapHourDataDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapLiquidityPositionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair address>-<user address>
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    id?: string;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    user?: string;
    /**
     * Pair address.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof SushiswapLiquidityPositionDTO
     */
    liquidity_token_balance?: string;
    /**
     * Block number at which position was created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    block?: number;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    timestamp?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionDTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type SushiswapLiquidityPositionSnapshotDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair address>-<user address>-<timestamp>
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    timestamp?: number;
    /**
     * Block in which snapshot has been created.
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapLiquidityPositionSnapshotDTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Sushiswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type SushiswapMintDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapMintDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <transaction hash>-<index in the transaction mint array>.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof SushiswapMintDTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapMintDTO
     */
    vid?: number;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type SushiswapPairDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    block_number?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    id?: string;
    /**
     * Factory contract address.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    factory?: string;
    /**
     * Friendly name, format: <token0 name>-<token1 name>
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    name?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    untracked_volume_usd?: string;
    /**
     * All time amount of transactions on this pair.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    tx_count?: string;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    liquidity_provider_count?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    timestamp?: string;
    /**
     * Block number in which pair information was created in.
     * @type {string}
     * @memberof SushiswapPairDTO
     */
    block?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    vid?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDTO
     */
    evaluated_ask?: number;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type SushiswapPairDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair id>-<day start timestamp>.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    pair?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof SushiswapPairDayDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairDayDataDTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type SushiswapPairHourDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapPairHourDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair id>-<hour start timestamp>.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    id?: string;
    /**
     * Hour start timestamp.
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    _date?: number;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_1?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof SushiswapPairHourDataDTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapPairHourDataDTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type SushiswapSwapDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapSwapDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    sender?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    to?: string;
    /**
     * Event index within transaction.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    log_index?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SushiswapSwapDTO
     */
    transaction_id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof SushiswapSwapDTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof SushiswapSwapDTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type SushiswapTokenDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    block_number?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    id?: string;
    /**
     * Factory address.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    factory?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    decimals?: string;
    /**
     * Total supply of liquidity token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    total_supply?: string;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    untracked_volume_usd?: string;
    /**
     * Amount of transactions all time in pairs including token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    tx_count?: string;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    derived_eth?: string;
    /**
     * Array of whitelisted pairs.
     * @type {Array<string>}
     * @memberof SushiswapTokenDTO
     */
    whitelist_pairs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof SushiswapTokenDTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type SushiswapTokenDayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTokenDayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    block_number?: number;
    /**
     * Identifier, day start timestamp in unix / 86400.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    tx_count?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof SushiswapTokenDayDataDTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTokenDayDataDTO
     */
    vid?: number;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Sushiswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type SushiswapTransactionDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapTransactionDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof SushiswapTransactionDTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof SushiswapTransactionDTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SushiswapTransactionDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 */
export type SushiswapUserDTO = {
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SushiswapUserDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof SushiswapUserDTO
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof SushiswapUserDTO
     */
    vid?: number;
}

/**
 * 
 * @export
 * @enum {string}
 */
export type TransactionsETradeAggressiveSide = 'Buy' | 'Sell' | 'EstimatedBuy' | 'EstimatedSell' | 'Unknown';

/**
 * The Bundle is used as a global store of derived ETH price in USD. Because there is no guaranteed common base token across pairs, a global reference of USD price is useful for deriving other USD values. The Bundle entity stores an updated weighted average of ETH<->Stablecoin pair prices. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV2BundleV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BundleV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BundleV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2BundleV2DTO
     */
    block_number?: number;
    /**
     * Constant 1.
     * @type {string}
     * @memberof UniswapV2BundleV2DTO
     */
    id?: string;
    /**
     * Derived price of ETH in USD based on stablecoin pairs.
     * @type {string}
     * @memberof UniswapV2BundleV2DTO
     */
    eth_price?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2BundleV2DTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2BundleV2DTO
     */
    block_range?: string;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned LP tokens, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV2BurnV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BurnV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2BurnV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2BurnV2DTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in the transaction burn array
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    id?: string;
    /**
     * Reference to the transaction Burn was included in.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    transaction?: string;
    /**
     * Timestamp of Burn, used to sort recent liquidity removals.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    pair?: string;
    /**
     * Amount of liquidity tokens burned.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity removal.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    sender?: string;
    /**
     * Amount of token0 removed.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    amount_0?: string;
    /**
     * Amount of token1 removed.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    amount_1?: string;
    /**
     * Recipient of tokens.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    to?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UniswapV2BurnV2DTO
     */
    needs_complete?: boolean;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    fee_to?: string;
    /**
     * Amount of tokens sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2BurnV2DTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2BurnV2DTO
     */
    vid?: number;
}

/**
 * This entity is used to store data about a user\'s liquidity position over time. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more. It gets created and never updated.
 * @export
 */
export type UniswapV2LiquidityPositionSnapshotV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pair address>-<user address>
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    id?: string;
    /**
     * Reference to LP identifier.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    liquidity_position?: string;
    /**
     * Creation time.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    timestamp?: number;
    /**
     * Number of block in which LP snapshot was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    block?: number;
    /**
     * Reference to user.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    pair?: string;
    /**
     * Snapshot of token0 price.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    token_0_price_usd?: string;
    /**
     * Snapshot of token0 price.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    token_1_price_usd?: string;
    /**
     * Snapshot of pair token0 reserves.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    reserve_0?: string;
    /**
     * Snapshot of pair token1 reserves.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    reserve_1?: string;
    /**
     * Snapshot of pair reserves in USD.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    reserve_usd?: string;
    /**
     * Snapshot of pool token supply.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    liquidity_token_total_supply?: string;
    /**
     * Snapshot of users pool token balance.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2LiquidityPositionSnapshotV2DTO
     */
    block_range?: string;
}

/**
 * This entity is used to store data about a user\'s liquidity position. This information, along with information from the pair itself can be used to provide position sizes, token deposits, and more.
 * @export
 */
export type UniswapV2LiquidityPositionV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    block_number?: number;
    /**
     * User address and pair address concatenated with a dash.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    id?: string;
    /**
     * Reference to user.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    user?: string;
    /**
     * Reference to the pair liquidity is being provided on.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    pair?: string;
    /**
     * Amount of LP tokens minted for this position.
     * @type {string}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    liquidity_token_balance?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2LiquidityPositionV2DTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, who received the liquidity, and more. This entity can be used to track liquidity provisions on pairs.
 * @export
 */
export type UniswapV2MintV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2MintV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2MintV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2MintV2DTO
     */
    block_number?: number;
    /**
     * Transaction hash plus index in the transaction mint array.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    id?: string;
    /**
     * Reference to the transaction Mint was included in.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    transaction?: string;
    /**
     * Timestamp of Mint, used to sort recent liquidity provisions.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    timestamp?: string;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    pair?: string;
    /**
     * Recipient of liquidity tokens.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    to?: string;
    /**
     * Amount of liquidity tokens minted.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    liquidity?: string;
    /**
     * Address that initiated the liquidity provision.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    sender?: string;
    /**
     * Amount of token0 provided.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    amount_0?: string;
    /**
     * Amount of token1 provided.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    amount_1?: string;
    /**
     * Index in the transaction event was emitted.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    log_index?: string;
    /**
     * Derived USD value of token0 amount plus token1 amount.
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    amount_usd?: string;
    /**
     * Address of fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    fee_to?: string;
    /**
     * Amount of liquidity sent to fee recipient (if fee is on).
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    fee_liquidity?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2MintV2DTO
     */
    vid?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2MintV2DTO
     */
    block_range?: string;
}

/**
 * Tracks pair data across each day.
 * @export
 */
export type UniswapV2PairDayDataV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    _date?: number;
    /**
     * Address for pair contract.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    pair_address?: string;
    /**
     * Reference to token0.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    token_0?: string;
    /**
     * Reference to token1.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    token_1?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    daily_volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    daily_volume_token_1?: string;
    /**
     * Total volume within pair throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    daily_volume_usd?: string;
    /**
     * Amount of transactions on pair throughout day.
     * @type {string}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    daily_txns?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairDayDataV2DTO
     */
    vid?: number;
}

/**
 * Tracks pair data across each hour.
 * @export
 */
export type UniswapV2PairHourDataV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    hour_start_unix?: number;
    /**
     * Address for pair contract.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    pair?: string;
    /**
     * Reserve of token0 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1 (updated during each transaction on pair).
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    total_supply?: string;
    /**
     * Reserve of token0 plus token1 stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    reserve_usd?: string;
    /**
     * Total amount of token0 swapped throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    hourly_volume_token_0?: string;
    /**
     * Total amount of token1 swapped throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    hourly_volume_token_1?: string;
    /**
     * Total volume within pair throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    hourly_volume_usd?: string;
    /**
     * Amount of transactions on pair throughout hour.
     * @type {string}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    hourly_txns?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairHourDataV2DTO
     */
    vid?: number;
}

/**
 * Information about a pair. Includes references to each token within the pair, volume information, liquidity information, and more. The pair entity mirrors the pair smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV2PairV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2PairV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2PairV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairV2DTO
     */
    vid?: number;
    /**
     * Pair contract address.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    id?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_1?: string;
    /**
     * Reserve of token0.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_0?: string;
    /**
     * Reserve of token1.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_1?: string;
    /**
     * Total supply of liquidity token distributed to LPs.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    total_supply?: string;
    /**
     * Total liquidity in pair stored as an amount of ETH.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_eth?: string;
    /**
     * Total liquidity amount in pair stored as an amount of USD.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    reserve_usd?: string;
    /**
     * Total liquidity with only tracked amount.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    tracked_reserve_eth?: string;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    token_1_price?: string;
    /**
     * Amount of token0 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    volume_token_0?: string;
    /**
     * Amount of token1 swapped on this pair.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    volume_token_1?: string;
    /**
     * Total amount swapped all time in this pair stored in USD (only tracked if USD liquidity is above minimum threshold).
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    volume_usd?: string;
    /**
     * Total amount swapped all time in this pair stored in USD, no minimum liquidity threshold.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2PairV2DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Timestamp contract was created.
     * @type {Date}
     * @memberof UniswapV2PairV2DTO
     */
    created_at_timestamp?: Date;
    /**
     * Total number of LPs.
     * @type {string}
     * @memberof UniswapV2PairV2DTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2PairV2DTO
     */
    evaluated_ask?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV2SwapV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2SwapV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    vid?: number;
    /**
     * Transaction hash plus index in Transaction swap array.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    id?: string;
    /**
     * Reference to transaction swap was included in.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    transaction?: string;
    /**
     * Timestamp of swap, used for sorted lookups.
     * @type {Date}
     * @memberof UniswapV2SwapV2DTO
     */
    timestamp?: Date;
    /**
     * Reference to pair.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    pair?: string;
    /**
     * Address that initiated the swap.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    sender?: string;
    /**
     * The EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    from?: string;
    /**
     * Amount of token0 sold.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_0_in?: string;
    /**
     * Amount of token1 sold.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_1_in?: string;
    /**
     * Amount of token0 received.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_0_out?: string;
    /**
     * Amount of token1 received.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_1_out?: string;
    /**
     * Recipient of output tokens.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    to?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2SwapV2DTO
     */
    log_index?: NumericsBigInteger;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2SwapV2DTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV2SwapV2DTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2SwapV2DTO
     */
    transaction_id?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV2TokenDayDataV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    block_number?: number;
    /**
     * Token address and day id (day start timestamp in unix / 86400) concatenated with a dash.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    _date?: number;
    /**
     * Reference to token entity.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    token?: string;
    /**
     * Amount of token swapped across all pairs throughout day.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    daily_volume_token?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    daily_volume_eth?: string;
    /**
     * Amount of token swapped across all pairs throughout day stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    daily_volume_usd?: string;
    /**
     * Amount of transactions with this token across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    daily_txns?: string;
    /**
     * Token amount of token deposited across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    total_liquidity_token?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of ETH.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    total_liquidity_eth?: string;
    /**
     * Token amount of token deposited across all pairs stored as amount of USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    total_liquidity_usd?: string;
    /**
     * Price of token in derived USD.
     * @type {string}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenDayDataV2DTO
     */
    vid?: number;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV2TokenV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TokenV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TokenV2DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TokenV2DTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV2TokenV2DTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenV2DTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Amount of token traded all time across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    trade_volume?: string;
    /**
     * Amount of token in USD traded all time across pairs (only for tokens with liquidity above minimum threshold).
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    trade_volume_usd?: string;
    /**
     * Amount of token in USD traded all time across pairs (no minimum liquidity threshold).
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    untracked_volume_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV2TokenV2DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Total amount of token provided as liquidity across all pairs.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    total_liquidity?: string;
    /**
     * ETH per token.
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    derived_eth?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV2TokenV2DTO
     */
    token_symbol?: string;
}

/**
 * Transaction entities are created for each Ethereum transaction that contains an interaction within Uniswap contracts. Each transaction contains 3 arrays, and at least one of these arrays has a length of 1.
 * @export
 */
export type UniswapV2TransactionV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TransactionV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2TransactionV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2TransactionV2DTO
     */
    block_number?: number;
    /**
     * Ethereum transaction hash.
     * @type {string}
     * @memberof UniswapV2TransactionV2DTO
     */
    id?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV2TransactionV2DTO
     */
    timestamp?: string;
    /**
     * Array of Mint events within the transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionV2DTO
     */
    mints?: Array<string>;
    /**
     * Array of Burn events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionV2DTO
     */
    burns?: Array<string>;
    /**
     * Array of Swap events within transaction, 0 or greater.
     * @type {Array<string>}
     * @memberof UniswapV2TransactionV2DTO
     */
    swaps?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2TransactionV2DTO
     */
    vid?: number;
}

/**
 * Tracks data across all pairs aggregated into a daily bucket.
 * @export
 */
export type UniswapV2UniswapDayDataV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    block_number?: number;
    /**
     * Unix timestamp for start of day / 86400 giving a unique day index.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of day.
     * @type {number}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    daily_volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    daily_volume_usd?: string;
    /**
     * Total volume across all pairs on this day, untracked.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    daily_volume_untracked?: string;
    /**
     * All time volume across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    total_volume_eth?: string;
    /**
     * Total liquidity across all pairs in ETH up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    total_liquidity_eth?: string;
    /**
     * All time volume across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    total_volume_usd?: string;
    /**
     * Total liquidity across all pairs in USD up to and including this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    total_liquidity_usd?: string;
    /**
     * Number of transactions throughout this day.
     * @type {string}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    tx_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2UniswapDayDataV2DTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV2UniswapFactoryV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    id?: string;
    /**
     * Amount of pairs created by the Uniswap factory.
     * @type {number}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    pair_count?: number;
    /**
     * All time USD volume across all pairs (USD is derived).
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    total_volume_usd?: string;
    /**
     * All time volume in ETH across all pairs (ETH is derived).
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    total_volume_eth?: string;
    /**
     * Untracked volume USD.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    untracked_volume_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived USD amount.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    total_liquidity_usd?: string;
    /**
     * Total liquidity across all pairs stored as a derived ETH amount.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    total_liquidity_eth?: string;
    /**
     * All time amount of transactions across all pairs.
     * @type {string}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    tx_count?: string;
    /**
     * .
     * @type {number}
     * @memberof UniswapV2UniswapFactoryV2DTO
     */
    vid?: number;
}

/**
 * A user entity is created for any address that provides liquidity to a pool on Uniswap. This entity can be used to track open positions for users.
 * @export
 */
export type UniswapV2UserV2DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UserV2DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV2UserV2DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV2UserV2DTO
     */
    block_number?: number;
    /**
     * User address.
     * @type {string}
     * @memberof UniswapV2UserV2DTO
     */
    id?: string;
    /**
     * Total USD value swapped.
     * @type {string}
     * @memberof UniswapV2UserV2DTO
     */
    usd_swapped?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV2UserV2DTO
     */
    vid?: number;
}

/**
 * The Bundle is used as a global store of derived ETH price in USD. This provides a strong estimate for the USD price of ETH.
 * @export
 */
export type UniswapV3BundleV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BundleV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BundleV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3BundleV3DTO
     */
    id?: string;
    /**
     * Price of ETH in usd.
     * @type {string}
     * @memberof UniswapV3BundleV3DTO
     */
    eth_price_usd?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BundleV3DTO
     */
    vid?: number;
}

/**
 * Burn entities are created for every emitted Burn event on the Uniswap core contracts. The Burn entity stores key data about the event like token amounts, who burned, who received tokens, and more. This entity can be used to track liquidity removals on pairs.
 * @export
 */
export type UniswapV3BurnV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3BurnV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3BurnV3DTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    id?: string;
    /**
     * Transaction burn was included in.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    transaction?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    token_1?: string;
    /**
     * Timestamp.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    timestamp?: string;
    /**
     * Owner of position where liquidity was burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    owner?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    origin?: string;
    /**
     * Amount of liquidity burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount?: string;
    /**
     * Amount of token 0 burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 burned.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    amount_usd?: string;
    /**
     * Lower tick of position.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    tick_lower?: string;
    /**
     * Upper tick of position.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    tick_upper?: string;
    /**
     * Position within the transactions.
     * @type {string}
     * @memberof UniswapV3BurnV3DTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3BurnV3DTO
     */
    vid?: number;
}

/**
 * The Uniswap Factory entity is responsible for storing aggregate information across all Uniswap pairs. It can be used to view stats about total liquidity, volume, amount of pairs and more.
 * @export
 */
export type UniswapV3FactoryV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3FactoryV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3FactoryV3DTO
     */
    block_number?: number;
    /**
     * Factory address.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    id?: string;
    /**
     * Amount of pools created.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    pool_count?: string;
    /**
     * Amount of transactions all time.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    tx_count?: string;
    /**
     * Total volume all time in derived USD.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_volume_usd?: string;
    /**
     * Total volume all time in derived ETH.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_volume_eth?: string;
    /**
     * Total swap fees all time in USD.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_fees_usd?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_fees_eth?: string;
    /**
     * All volume even through less reliable USD values.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Total value locked derived in USD.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived in ETH.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Total value locked derived in ETH untracked.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    total_value_locked_eth_untracked?: string;
    /**
     * Current owner of the factory.
     * @type {string}
     * @memberof UniswapV3FactoryV3DTO
     */
    owner?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3FactoryV3DTO
     */
    vid?: number;
}

/**
 * Mint entities are created for every emitted Mint event on the Uniswap core contracts. The Mint entity stores key data about the event like token amounts, who sent the transaction, and more.
 * @export
 */
export type UniswapV3MintV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3MintV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3MintV3DTO
     */
    block_number?: number;
    /**
     * Transaction hash + \'#\' + index in mints Transaction array.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    id?: string;
    /**
     * Which txn the mint was included in.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    transaction?: string;
    /**
     * Time of transaction.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    timestamp?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    token_1?: string;
    /**
     * Owner of position where liquidity minted to.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    owner?: string;
    /**
     * The address that minted the liquidity.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    sender?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    origin?: string;
    /**
     * Amount of liquidity minted.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount?: string;
    /**
     * Amount of token 0 minted.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount_0?: string;
    /**
     * Amount of token 1 minted.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount_1?: string;
    /**
     * Derived amount based on available prices of tokens.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    amount_usd?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    tick_upper?: string;
    /**
     * Order within the transaction.
     * @type {string}
     * @memberof UniswapV3MintV3DTO
     */
    log_index?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3MintV3DTO
     */
    vid?: number;
}

/**
 * Data accumulated and condensed into day stats for each pool.
 * @export
 */
export type UniswapV3PoolDayDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool address>-<day id>.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400
     * @type {number}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolDayDataV3DTO
     */
    vid?: number;
}

/**
 * Hourly stats tracker for pool.
 * @export
 */
export type UniswapV3PoolHourDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool address>-<day id>
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    period_start_unix?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    pool?: string;
    /**
     * In range liquidity at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    liquidity?: string;
    /**
     * Current price tracker at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    sqrt_price?: string;
    /**
     * Price of token0 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    token_0_price?: string;
    /**
     * Price of token1 - derived from sqrtPrice.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    token_1_price?: string;
    /**
     * Current tick at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    tick?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    fee_growth_global_0x128?: string;
    /**
     * Tracker for global fee growth.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    fee_growth_global_1x128?: string;
    /**
     * Total value locked derived in USD at end of period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    tvl_usd?: string;
    /**
     * Volume in token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    volume_token_0?: string;
    /**
     * Volume in token1.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    volume_token_1?: string;
    /**
     * Volume in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    fees_usd?: string;
    /**
     * Number of transactions during period.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    tx_count?: string;
    /**
     * Opening price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    open?: string;
    /**
     * High price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    high?: string;
    /**
     * Low price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    low?: string;
    /**
     * Close price of token0.
     * @type {string}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolHourDataV3DTO
     */
    vid?: number;
}

/**
 * Information about a pool. Includes references to each token within the pool, volume information, liquidity information, and more. The pool entity mirrors the pool smart contract, and also contains aggregated information about use.
 * @export
 */
export type UniswapV3PoolV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PoolV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PoolV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolV3DTO
     */
    vid?: number;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    id?: string;
    /**
     * Creation time.
     * @type {Date}
     * @memberof UniswapV3PoolV3DTO
     */
    created_at_timestamp?: Date;
    /**
     * Reference to token0 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pool contract.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_1?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    fee_tier?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    liquidity?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    sqrt_price?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    fee_growth_global_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    fee_growth_global_1x128?: NumericsBigInteger;
    /**
     * Token0 per token1.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_0_price?: string;
    /**
     * Token1 per token0.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    token_1_price?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    observation_index?: NumericsBigInteger;
    /**
     * All time token0 swapped.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    volume_token_0?: string;
    /**
     * All time token1 swapped.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    volume_token_1?: string;
    /**
     * All time USD swapped.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    volume_usd?: string;
    /**
     * All time USD swapped, unfiltered for unreliable USD pools.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3PoolV3DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * All time fees collected token0.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time fees collected token1.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * All time fees collected derived USD.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    collected_fees_usd?: string;
    /**
     * Total token 0 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_token_0?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_token_1?: string;
    /**
     * Total token 1 across all ticks.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_eth?: string;
    /**
     * Total value locked USD.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * Total value locked derived ETH.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Liquidity providers count, used to detect new exchanges.
     * @type {string}
     * @memberof UniswapV3PoolV3DTO
     */
    liquidity_provider_count?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PoolV3DTO
     */
    evaluated_ask?: number;
}

/**
 * 
 * @export
 */
export type UniswapV3PositionSnapshotV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    block_number?: number;
    /**
     * NFT token identifier, format: <NFT token id>#<block number>
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    owner?: string;
    /**
     * Pool the position is within.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    pool?: string;
    /**
     * Position of which the snap was taken of.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    position?: string;
    /**
     * Timestamp of block in which the snap was created.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    timestamp?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the snapshot was initialized.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionSnapshotV3DTO
     */
    vid?: number;
}

/**
 * Positions created through NonfungiblePositionManager. Positions are represented as NFTs (ERC-721 tokens) as opposed to the fungible ERC-20 tokens on Uniswap V1 and V2.
 * @export
 */
export type UniswapV3PositionV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3PositionV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3PositionV3DTO
     */
    block_number?: number;
    /**
     * NFT token identifier.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    id?: string;
    /**
     * Owner of the NFT.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    owner?: string;
    /**
     * Pool position is within.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    token_1?: string;
    /**
     * Lower tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    tick_lower?: string;
    /**
     * Upper tick of the position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    tick_upper?: string;
    /**
     * Total position liquidity.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    liquidity?: string;
    /**
     * Amount of token 0 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    deposited_token_0?: string;
    /**
     * Amount of token 1 ever deposited to position.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    deposited_token_1?: string;
    /**
     * Amount of token 0 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    withdrawn_token_0?: string;
    /**
     * Amount of token 1 ever withdrawn from position (without fees).
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    withdrawn_token_1?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * Transaction in which the position was initialized.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    transaction?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    fee_growth_inside_0_last_x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3PositionV3DTO
     */
    fee_growth_inside_1_last_x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3PositionV3DTO
     */
    vid?: number;
}

/**
 * Swap are created for each token swap within a pair.
 * @export
 */
export type UniswapV3SwapV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3SwapV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    vid?: number;
    /**
     * Identifier, format: transaction hash + \"#\" + index in swaps Transaction array.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    id?: string;
    /**
     * Pointer to transaction.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    transaction?: string;
    /**
     * Timestamp of transaction.
     * @type {Date}
     * @memberof UniswapV3SwapV3DTO
     */
    timestamp?: Date;
    /**
     * Pool swap occured within.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    pool?: string;
    /**
     * Reference to token0 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    token_0?: string;
    /**
     * Reference to token1 as stored in pair contract.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    token_1?: string;
    /**
     * Sender of the swap.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    sender?: string;
    /**
     * Recipient of the swap.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    recipient?: string;
    /**
     * Transaction origin: the EOA (Externally Owned Account) that initiated the transaction
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    origin?: string;
    /**
     * Delta of token0 swapped.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    amount_0?: string;
    /**
     * Delta of token1 swapped.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    amount_1?: string;
    /**
     * Derived amount of tokens sold in USD.
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    amount_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapV3DTO
     */
    sqrt_price_x96?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapV3DTO
     */
    tick?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3SwapV3DTO
     */
    log_index?: NumericsBigInteger;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    evaluated_price?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3SwapV3DTO
     */
    evaluated_amount?: number;
    /**
     * 
     * @type {TransactionsETradeAggressiveSide}
     * @memberof UniswapV3SwapV3DTO
     */
    evaluated_aggressor?: TransactionsETradeAggressiveSide;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    pool_id?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3SwapV3DTO
     */
    transaction_id?: string;
}

/**
 * Data accumulated and condensed into day stats for each exchange. Entity gets saved only if there is a change during the day
 * @export
 */
export type UniswapV3TickDayDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    block_number?: number;
    /**
     * Identifier, format: <pool address>-<tick index>-<timestamp>.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    _date?: number;
    /**
     * Pointer to pool.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    pool?: string;
    /**
     * Pointer to tick.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    tick?: string;
    /**
     * Total liquidity pool has as tick lower or upper at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    liquidity_gross?: string;
    /**
     * How much liquidity changes when tick crossed at end of period.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    liquidity_net?: string;
    /**
     * Hourly volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    volume_token_0?: string;
    /**
     * Hourly volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    volume_token_1?: string;
    /**
     * Hourly volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    fees_usd?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    fee_growth_outside_0x128?: string;
    /**
     * Variable needed for fee computation.
     * @type {string}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    fee_growth_outside_1x128?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickDayDataV3DTO
     */
    vid?: number;
}

/**
 * Ticks are the boundaries between discrete areas in price space.
 * @export
 */
export type UniswapV3TickV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TickV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TickV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TickV3DTO
     */
    vid?: number;
    /**
     * Identifier, format: <pool address>#<tick index>
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    id?: string;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    pool_address?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    tick_idx?: NumericsBigInteger;
    /**
     * Pool address.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    pool?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    liquidity_gross?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    liquidity_net?: NumericsBigInteger;
    /**
     * Calculated price of token0 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    price_0?: string;
    /**
     * Calculated price of token1 of tick within this pool - constant.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    price_1?: string;
    /**
     * Lifetime volume of token0 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    volume_token_0?: string;
    /**
     * Lifetime volume of token1 with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    volume_token_1?: string;
    /**
     * Lifetime volume in derived USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    volume_usd?: string;
    /**
     * Lifetime volume in untracked USD with this tick in range.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    fees_usd?: string;
    /**
     * All time collected fees in token0.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    collected_fees_token_0?: string;
    /**
     * All time collected fees in token1.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    collected_fees_token_1?: string;
    /**
     * All time collected fees in USD.
     * @type {string}
     * @memberof UniswapV3TickV3DTO
     */
    collected_fees_usd?: string;
    /**
     * Created time.
     * @type {Date}
     * @memberof UniswapV3TickV3DTO
     */
    created_at_timestamp?: Date;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    liquidity_provider_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    fee_growth_outside_0x128?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TickV3DTO
     */
    fee_growth_outside_1x128?: NumericsBigInteger;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenHourDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    block_number?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    id?: string;
    /**
     * Unix timestamp for start of hour.
     * @type {number}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    period_start_unix?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    close?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenHourDataV3DTO
     */
    vid?: number;
}

/**
 * Stores aggregated information for a specific token across all pairs that token is included in.
 * @export
 */
export type UniswapV3TokenV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenV3DTO
     */
    vid?: number;
    /**
     * Token address.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    id?: string;
    /**
     * Token symbol.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    symbol?: string;
    /**
     * Token name.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    name?: string;
    /**
     * Token decimals.
     * @type {number}
     * @memberof UniswapV3TokenV3DTO
     */
    decimals?: number;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenV3DTO
     */
    total_supply?: NumericsBigInteger;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    untracked_volume_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenV3DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3TokenV3DTO
     */
    pool_count?: NumericsBigInteger;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    total_value_locked_usd?: string;
    /**
     * TVL derived in USD untracked.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    total_value_locked_usd_untracked?: string;
    /**
     * Derived price in ETH.
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    derived_eth?: string;
    /**
     * Pools token is in that are white listed for USD pricing.
     * @type {Array<string>}
     * @memberof UniswapV3TokenV3DTO
     */
    whitelist_pools?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TokenV3DTO
     */
    token_symbol?: string;
}

/**
 * Token data aggregated across all pairs that include token.
 * @export
 */
export type UniswapV3TokenV3DayDataDTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    vid?: number;
    /**
     * Token address concatendated with date.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    _date?: number;
    /**
     * Pointer to token.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    token?: string;
    /**
     * Volume in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume?: string;
    /**
     * Volume in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    volume_usd?: string;
    /**
     * Volume in USD even on pools with less reliable USD values.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    untracked_volume_usd?: string;
    /**
     * Liquidity across all pools in token units.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked?: string;
    /**
     * Liquidity across all pools in derived USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    total_value_locked_usd?: string;
    /**
     * Price at end of period in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    price_usd?: string;
    /**
     * Fees in USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    fees_usd?: string;
    /**
     * Opening price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    open?: string;
    /**
     * High price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    high?: string;
    /**
     * Low price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    low?: string;
    /**
     * Close price USD.
     * @type {string}
     * @memberof UniswapV3TokenV3DayDataDTO
     */
    close?: string;
}

/**
 * 
 * @export
 */
export type UniswapV3TransactionV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TransactionV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3TransactionV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3TransactionV3DTO
     */
    block_number?: number;
    /**
     * Transaction hash.
     * @type {string}
     * @memberof UniswapV3TransactionV3DTO
     */
    id?: string;
    /**
     * Timestamp txn was confirmed.
     * @type {string}
     * @memberof UniswapV3TransactionV3DTO
     */
    timestamp?: string;
    /**
     * Gas used during txn execution.
     * @type {string}
     * @memberof UniswapV3TransactionV3DTO
     */
    gas_used?: string;
    /**
     * 
     * @type {string}
     * @memberof UniswapV3TransactionV3DTO
     */
    gas_price?: string;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3TransactionV3DTO
     */
    vid?: number;
}

/**
 * Data accumulated and condensed into day stats for all of Uniswap.
 * @export
 */
export type UniswapV3UniswapDayDataV3DTO = {
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    entry_time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    recv_time?: Date;
    /**
     * Number of block in which entity was recorded.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    block_number?: number;
    /**
     * 
     * @type {number}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    vid?: number;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    id?: string;
    /**
     * Timestamp rounded to current day by dividing by 86400.
     * @type {number}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    _date?: number;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of ETH.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    volume_eth?: string;
    /**
     * Total volume across all pairs on this day, stored as a derived amount of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    volume_usd?: string;
    /**
     * Total daily volume in Uniswap derived in terms of USD untracked.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    volume_usd_untracked?: string;
    /**
     * Fees in USD
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    fees_usd?: string;
    /**
     * 
     * @type {NumericsBigInteger}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    tx_count?: NumericsBigInteger;
    /**
     * Tvl in terms of USD.
     * @type {string}
     * @memberof UniswapV3UniswapDayDataV3DTO
     */
    tvl_usd?: string;
}



/**
 * CowApi - fetch parameter creator
 * @export
 */
export const CowApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        cowGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/orders/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets settlements.
         * @summary Settlements (historical)
         * @throws {RequiredError}
         */
        cowGetSettlementsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/settlements/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        cowGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/tokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (historical) 
         * @throws {RequiredError}
         */
        cowGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/trades/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        cowGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/cow/users/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CowApiType = { 
    cowGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CowOrderDTO>>,

    cowGetSettlementsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CowSettlementDTO>>,

    cowGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<CowTokenDTO>>,

    cowGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CowTradeDTO>>,

    cowGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CowUserDTO>>,
}

/**
 * CowApi - factory function to inject configuration 
 * @export
 */
export const CowApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CowApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        cowGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CowOrderDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetOrdersHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets settlements.
         * @summary Settlements (historical)
         * @throws {RequiredError}
         */
        cowGetSettlementsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CowSettlementDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetSettlementsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        cowGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<CowTokenDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (historical) 
         * @throws {RequiredError}
         */
        cowGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CowTradeDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetTradesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        cowGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CowUserDTO>> {
            const localVarFetchArgs = CowApiFetchParamCreator(configuration).cowGetUsersHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * CurveApi - fetch parameter creator
 * @export
 */
export const CurveApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets accounts.
         * @summary Accounts (historical)
         * @throws {RequiredError}
         */
        curveGetAccountsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/accounts/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets add liquidity events.
         * @summary AddLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetAddLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/addLiquidityEvents/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets admin fee change logs.
         * @summary AdminFeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAdminFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/adminFeeChangeLogs/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets amplification coeff change logs.
         * @summary AmplificationCoeffChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAmplificationCoeffChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/amplificationCoeffChangeLogs/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets coins.
         * @summary Coins (historical)
         * @throws {RequiredError}
         */
        curveGetCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/coins/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contracts.
         * @summary Contracts (historical)
         * @throws {RequiredError}
         */
        curveGetContractsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contracts/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets contracts versions.
         * @summary ContractsVersions (historical)
         * @throws {RequiredError}
         */
        curveGetContractsVersionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/contractsVersions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets daily volumes.
         * @summary DailyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetDailyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/dailyVolumes/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (historical) 
         * @throws {RequiredError}
         */
        curveGetExchangesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/exchanges/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets fee change logs.
         * @summary FeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/feeChangeLogs/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges deposits.
         * @summary GaugesDeposits (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesDeposits/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges.
         * @summary Gauges (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gauges/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges liquidity.
         * @summary GaugesLiquidity (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesLiquidityHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesLiquidity/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges total weights.
         * @summary GaugesTotalWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesTotalWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesTotalWeights/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges types.
         * @summary GaugesTypes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesTypesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesTypes/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges types weights.
         * @summary GaugesTypesWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesTypesWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesTypesWeights/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges weights.
         * @summary GaugesWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesWeights/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges weights votes.
         * @summary GaugesWeightsVotes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesWeightsVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesWeightsVotes/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets gauges withdraws.
         * @summary GaugesWithdraw (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesWithdrawHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/gaugesWithdraws/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hourly volumes.
         * @summary HourlyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetHourlyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/hourlyVolumes/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets lp tokens.
         * @summary LpTokens (historical)
         * @throws {RequiredError}
         */
        curveGetLpTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/lpTokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        curveGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/pools/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposals.
         * @summary Proposals (historical)
         * @throws {RequiredError}
         */
        curveGetProposalsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposals/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets proposals votes.
         * @summary ProposalsVotes (historical)
         * @throws {RequiredError}
         */
        curveGetProposalsVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/proposalsVotes/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets remove liquidity events.
         * @summary RemoveLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityEvents/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets remove liquidity one events.
         * @summary RemoveLiquidityOneEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityOneEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/removeLiquidityOneEvents/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets system states.
         * @summary SystemStates (historical)
         * @throws {RequiredError}
         */
        curveGetSystemStatesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/systemStates/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        curveGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/tokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transfer ownership events.
         * @summary TransferOwnershipEvents (historical)
         * @throws {RequiredError}
         */
        curveGetTransferOwnershipEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/transferOwnershipEvents/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets underlying coins.
         * @summary UnderlyingCoins (historical)
         * @throws {RequiredError}
         */
        curveGetUnderlyingCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/underlyingCoins/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets voting apps.
         * @summary VotingApps (historical)
         * @throws {RequiredError}
         */
        curveGetVotingAppsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/votingApps/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets weekly volumes.
         * @summary WeeklyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetWeeklyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/curve/weeklyVolumes/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type CurveApiType = { 
    curveGetAccountsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveAccountDTO>>,

    curveGetAddLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveAddLiquidityEventDTO>>,

    curveGetAdminFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveAdminFeeChangeLogDTO>>,

    curveGetAmplificationCoeffChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveAmplificationCoeffChangeLogDTO>>,

    curveGetCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveCoinDTO>>,

    curveGetContractsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveContractDTO>>,

    curveGetContractsVersionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveContractVersionDTO>>,

    curveGetDailyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveDailyVolumeDTO>>,

    curveGetExchangesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveExchangeDTO>>,

    curveGetFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveFeeChangeLogDTO>>,

    curveGetGaugesDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeDepositDTO>>,

    curveGetGaugesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveGaugeDTO>>,

    curveGetGaugesLiquidityHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeLiquidityDTO>>,

    curveGetGaugesTotalWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeTotalWeightDTO>>,

    curveGetGaugesTypesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeTypeDTO>>,

    curveGetGaugesTypesWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeTypeWeightDTO>>,

    curveGetGaugesWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeWeightDTO>>,

    curveGetGaugesWeightsVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeWeightVoteDTO>>,

    curveGetGaugesWithdrawHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveGaugeWithdrawDTO>>,

    curveGetHourlyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveHourlyVolumeDTO>>,

    curveGetLpTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveLpTokenDTO>>,

    curveGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurvePoolDTO>>,

    curveGetProposalsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveProposalDTO>>,

    curveGetProposalsVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveProposalVoteDTO>>,

    curveGetRemoveLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveRemoveLiquidityEventDTO>>,

    curveGetRemoveLiquidityOneEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveRemoveLiquidityOneEventDTO>>,

    curveGetSystemStatesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveSystemStateDTO>>,

    curveGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<CurveTokenDTO>>,

    curveGetTransferOwnershipEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveTransferOwnershipEventDTO>>,

    curveGetUnderlyingCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveUnderlyingCoinDTO>>,

    curveGetVotingAppsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<CurveVotingAppDTO>>,

    curveGetWeeklyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<CurveWeeklyVolumeDTO>>,
}

/**
 * CurveApi - factory function to inject configuration 
 * @export
 */
export const CurveApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): CurveApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets accounts.
         * @summary Accounts (historical)
         * @throws {RequiredError}
         */
        curveGetAccountsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveAccountDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAccountsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets add liquidity events.
         * @summary AddLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetAddLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveAddLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAddLiquidityEventsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets admin fee change logs.
         * @summary AdminFeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAdminFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveAdminFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAdminFeeChangeLogsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets amplification coeff change logs.
         * @summary AmplificationCoeffChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetAmplificationCoeffChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveAmplificationCoeffChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetAmplificationCoeffChangeLogsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets coins.
         * @summary Coins (historical)
         * @throws {RequiredError}
         */
        curveGetCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetCoinsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contracts.
         * @summary Contracts (historical)
         * @throws {RequiredError}
         */
        curveGetContractsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveContractDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetContractsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets contracts versions.
         * @summary ContractsVersions (historical)
         * @throws {RequiredError}
         */
        curveGetContractsVersionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveContractVersionDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetContractsVersionsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets daily volumes.
         * @summary DailyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetDailyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveDailyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetDailyVolumesHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets exchanges.
         * @summary Exchanges (historical) 
         * @throws {RequiredError}
         */
        curveGetExchangesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveExchangeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetExchangesHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets fee change logs.
         * @summary FeeChangeLogs (historical)
         * @throws {RequiredError}
         */
        curveGetFeeChangeLogsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveFeeChangeLogDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetFeeChangeLogsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges deposits.
         * @summary GaugesDeposits (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeDepositDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesDepositsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges.
         * @summary Gauges (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveGaugeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges liquidity.
         * @summary GaugesLiquidity (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesLiquidityHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeLiquidityDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesLiquidityHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges total weights.
         * @summary GaugesTotalWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesTotalWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeTotalWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesTotalWeightsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges types.
         * @summary GaugesTypes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesTypesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesTypesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges types weights.
         * @summary GaugesTypesWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesTypesWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeTypeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesTypesWeightsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges weights.
         * @summary GaugesWeights (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesWeightsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesWeightsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges weights votes.
         * @summary GaugesWeightsVotes (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesWeightsVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeWeightVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesWeightsVotesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets gauges withdraws.
         * @summary GaugesWithdraw (historical)
         * @throws {RequiredError}
         */
        curveGetGaugesWithdrawHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveGaugeWithdrawDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetGaugesWithdrawHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hourly volumes.
         * @summary HourlyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetHourlyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveHourlyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetHourlyVolumesHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets lp tokens.
         * @summary LpTokens (historical)
         * @throws {RequiredError}
         */
        curveGetLpTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveLpTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetLpTokensHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        curveGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurvePoolDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetPoolsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposals.
         * @summary Proposals (historical)
         * @throws {RequiredError}
         */
        curveGetProposalsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveProposalDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetProposalsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets proposals votes.
         * @summary ProposalsVotes (historical)
         * @throws {RequiredError}
         */
        curveGetProposalsVotesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveProposalVoteDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetProposalsVotesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets remove liquidity events.
         * @summary RemoveLiquidityEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetRemoveLiquidityEventsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets remove liquidity one events.
         * @summary RemoveLiquidityOneEvents (historical)
         * @throws {RequiredError}
         */
        curveGetRemoveLiquidityOneEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveRemoveLiquidityOneEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetRemoveLiquidityOneEventsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets system states.
         * @summary SystemStates (historical)
         * @throws {RequiredError}
         */
        curveGetSystemStatesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveSystemStateDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetSystemStatesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        curveGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<CurveTokenDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transfer ownership events.
         * @summary TransferOwnershipEvents (historical)
         * @throws {RequiredError}
         */
        curveGetTransferOwnershipEventsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveTransferOwnershipEventDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetTransferOwnershipEventsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets underlying coins.
         * @summary UnderlyingCoins (historical)
         * @throws {RequiredError}
         */
        curveGetUnderlyingCoinsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveUnderlyingCoinDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetUnderlyingCoinsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets voting apps.
         * @summary VotingApps (historical)
         * @throws {RequiredError}
         */
        curveGetVotingAppsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<CurveVotingAppDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetVotingAppsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets weekly volumes.
         * @summary WeeklyVolumes (historical)
         * @throws {RequiredError}
         */
        curveGetWeeklyVolumesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<CurveWeeklyVolumeDTO>> {
            const localVarFetchArgs = CurveApiFetchParamCreator(configuration).curveGetWeeklyVolumesHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * DexApi - fetch parameter creator
 * @export
 */
export const DexApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets batches.
         * @summary Batches (historical)
         * @throws {RequiredError}
         */
        dexGetBatchesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/batches/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets deposits.
         * @summary Deposits (historical)
         * @throws {RequiredError}
         */
        dexGetDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/deposits/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        dexGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/orders/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets prices.
         * @summary Prices (historical)
         * @throws {RequiredError}
         */
        dexGetPricesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/prices/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets solutions.
         * @summary Solutions (historical)
         * @throws {RequiredError}
         */
        dexGetSolutionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/solutions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets stats.
         * @summary Stats (historical)
         * @throws {RequiredError}
         */
        dexGetStatsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/stats/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        dexGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/tokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (historical) 
         * @throws {RequiredError}
         */
        dexGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/trades/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        dexGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/users/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdraws/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets withdraws requests.
         * @summary WithdrawsRequests (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawsRequestsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/dex/withdrawsRequests/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type DexApiType = { 
    dexGetBatchesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<DexBatchDTO>>,

    dexGetDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexDepositDTO>>,

    dexGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexOrderDTO>>,

    dexGetPricesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexPriceDTO>>,

    dexGetSolutionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexSolutionDTO>>,

    dexGetStatsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<DexStatsDTO>>,

    dexGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexTokenDTO>>,

    dexGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<DexTradeDTO>>,

    dexGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<DexUserDTO>>,

    dexGetWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexWithdrawDTO>>,

    dexGetWithdrawsRequestsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<DexWithdrawRequestDTO>>,
}

/**
 * DexApi - factory function to inject configuration 
 * @export
 */
export const DexApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): DexApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets batches.
         * @summary Batches (historical)
         * @throws {RequiredError}
         */
        dexGetBatchesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<DexBatchDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetBatchesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets deposits.
         * @summary Deposits (historical)
         * @throws {RequiredError}
         */
        dexGetDepositsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexDepositDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetDepositsHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets orders.
         * @summary Orders (historical)
         * @throws {RequiredError}
         */
        dexGetOrdersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexOrderDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetOrdersHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets prices.
         * @summary Prices (historical)
         * @throws {RequiredError}
         */
        dexGetPricesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexPriceDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetPricesHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets solutions.
         * @summary Solutions (historical)
         * @throws {RequiredError}
         */
        dexGetSolutionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexSolutionDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetSolutionsHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets stats.
         * @summary Stats (historical)
         * @throws {RequiredError}
         */
        dexGetStatsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<DexStatsDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetStatsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        dexGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexTokenDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (historical) 
         * @throws {RequiredError}
         */
        dexGetTradesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<DexTradeDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetTradesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        dexGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<DexUserDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetUsersHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws.
         * @summary Withdraws (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexWithdrawDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetWithdrawsHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets withdraws requests.
         * @summary WithdrawsRequests (historical)
         * @throws {RequiredError}
         */
        dexGetWithdrawsRequestsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<DexWithdrawRequestDTO>> {
            const localVarFetchArgs = DexApiFetchParamCreator(configuration).dexGetWithdrawsRequestsHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * SushiswapApi - fetch parameter creator
 * @export
 */
export const SushiswapApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets exchanges.
         * @summary Exchanges (current) 
         * @throws {RequiredError}
         */
        curveGetExchangesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/exchanges/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets trades.
         * @summary Trades (current) 
         * @throws {RequiredError}
         */
        dexGetTradesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/trades/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/bundles/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/burns/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets day data.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/dayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factory.
         * @summary Factory (historical)
         * @throws {RequiredError}
         */
        sushiswapGetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/factory/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets hour data.
         * @summary HourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/hourData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidity position.
         * @summary LiquidityPosition (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPosition/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidity position snapshot.
         * @summary LiquidityPositionSnapshot (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionSnapshotHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/liquidityPositionSnapshots/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/mints/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current) 
         * @throws {RequiredError}
         */
        sushiswapGetPoolsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/poolsDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets list of pools for given filters.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/pools/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools tracked each our.
         * @summary PoolsHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/poolsHourData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current) 
         * @throws {RequiredError}
         */
        sushiswapGetSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets list of swaps for given filters.
         * @summary Swaps (historical) 
         * @throws {RequiredError}
         */
        sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/swaps/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current) 
         * @throws {RequiredError}
         */
        sushiswapGetTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokensDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets list of tokens for given filters.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/tokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/transactions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/sushiswap/users/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type SushiswapApiType = { 
    curveGetExchangesCurrent(options?: RequestOptions): Promise<Array<CurveExchangeDTO>>,

    dexGetTradesCurrent(options?: RequestOptions): Promise<Array<DexTradeDTO>>,

    sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapBundleDTO>>,

    sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapBurnDTO>>,

    sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapDayDataDTO>>,

    sushiswapGetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapFactoryDTO>>,

    sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapHourDataDTO>>,

    sushiswapGetLiquidityPositionHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionDTO>>,

    sushiswapGetLiquidityPositionSnapshotHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>>,

    sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapMintDTO>>,

    sushiswapGetPoolsCurrent(options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapGetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapPairDayDataDTO>>,

    sushiswapGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapPairDTO>>,

    sushiswapGetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapPairHourDataDTO>>,

    sushiswapGetSwapsCurrent(options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<SushiswapSwapDTO>>,

    sushiswapGetTokensCurrent(options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapGetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<SushiswapTokenDayDataDTO>>,

    sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<SushiswapTokenDTO>>,

    sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapTransactionDTO>>,

    sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<SushiswapUserDTO>>,
}

/**
 * SushiswapApi - factory function to inject configuration 
 * @export
 */
export const SushiswapApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): SushiswapApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets exchanges.
         * @summary Exchanges (current) 
         * @throws {RequiredError}
         */
        curveGetExchangesCurrent(options?: RequestOptions = {}): Promise<Array<CurveExchangeDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).curveGetExchangesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets trades.
         * @summary Trades (current) 
         * @throws {RequiredError}
         */
        dexGetTradesCurrent(options?: RequestOptions = {}): Promise<Array<DexTradeDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).dexGetTradesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapBundleDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetBundlesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        sushiswapGetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapBurnDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetBurnsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets day data.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetDayDataHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factory.
         * @summary Factory (historical)
         * @throws {RequiredError}
         */
        sushiswapGetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapFactoryDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetFactoryHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets hour data.
         * @summary HourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetHourDataHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidity position.
         * @summary LiquidityPosition (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetLiquidityPositionHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidity position snapshot.
         * @summary LiquidityPositionSnapshot (historical)
         * @throws {RequiredError}
         */
        sushiswapGetLiquidityPositionSnapshotHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapLiquidityPositionSnapshotDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetLiquidityPositionSnapshotHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        sushiswapGetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapMintDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetMintsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current) 
         * @throws {RequiredError}
         */
        sushiswapGetPoolsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsDayDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets list of pools for given filters.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools tracked each our.
         * @summary PoolsHourData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapPairHourDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetPoolsHourDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current) 
         * @throws {RequiredError}
         */
        sushiswapGetSwapsCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets list of swaps for given filters.
         * @summary Swaps (historical) 
         * @throws {RequiredError}
         */
        sushiswapGetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapSwapDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetSwapsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current) 
         * @throws {RequiredError}
         */
        sushiswapGetTokensCurrent(options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTokenDayDataDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensDayDataHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets list of tokens for given filters.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        sushiswapGetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<SushiswapTokenDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        sushiswapGetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapTransactionDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetTransactionsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        sushiswapGetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<SushiswapUserDTO>> {
            const localVarFetchArgs = SushiswapApiFetchParamCreator(configuration).sushiswapGetUsersHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV2Api - fetch parameter creator
 * @export
 */
export const UniswapV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/bundles/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/burns/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapv2 day data.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/dayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factory.
         * @summary Factory (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/factory/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidity positions.
         * @summary LiquidityPositions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets liquidity positions snapshots.
         * @summary LiquidityPositionsSnapshots (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionsSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/liquidityPositionsSnapshots/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/mints/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current) 
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/poolsDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/pools/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools tracked each our.
         * @summary PoolsHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/poolsHourData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current) 
         * @throws {RequiredError}
         */
        uniswapV2GetSwapsCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical) 
         * @throws {RequiredError}
         */
        uniswapV2GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/swaps/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current) 
         * @throws {RequiredError}
         */
        uniswapV2GetTokensCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokensDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        uniswapV2GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/tokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/transactions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv2/users/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV2ApiType = { 
    uniswapV2GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV2BundleV2DTO>>,

    uniswapV2GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2BurnV2DTO>>,

    uniswapV2GetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV2UniswapDayDataV2DTO>>,

    uniswapV2GetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV2UniswapFactoryV2DTO>>,

    uniswapV2GetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionV2DTO>>,

    uniswapV2GetLiquidityPositionsSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2LiquidityPositionSnapshotV2DTO>>,

    uniswapV2GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2MintV2DTO>>,

    uniswapV2GetPoolsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV2PairV2DTO>>,

    uniswapV2GetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2PairDayDataV2DTO>>,

    uniswapV2GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2PairV2DTO>>,

    uniswapV2GetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2PairHourDataV2DTO>>,

    uniswapV2GetSwapsCurrent(options?: RequestOptions): Promise<Array<UniswapV2SwapV2DTO>>,

    uniswapV2GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV2SwapV2DTO>>,

    uniswapV2GetTokensCurrent(options?: RequestOptions): Promise<Array<UniswapV2TokenV2DTO>>,

    uniswapV2GetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<UniswapV2TokenDayDataV2DTO>>,

    uniswapV2GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<UniswapV2TokenV2DTO>>,

    uniswapV2GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV2TransactionV2DTO>>,

    uniswapV2GetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV2UserV2DTO>>,
}

/**
 * UniswapV2Api - factory function to inject configuration 
 * @export
 */
export const UniswapV2Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV2ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV2BundleV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetBundlesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2BurnV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetBurnsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapv2 day data.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapDayDataV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetDayDataHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factory.
         * @summary Factory (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV2UniswapFactoryV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetFactoryHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidity positions.
         * @summary LiquidityPositions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetLiquidityPositionsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets liquidity positions snapshots.
         * @summary LiquidityPositionsSnapshots (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetLiquidityPositionsSnapshotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2LiquidityPositionSnapshotV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetLiquidityPositionsSnapshotsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2MintV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetMintsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current) 
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPoolsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairDayDataV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPoolsDayDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPoolsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools tracked each our.
         * @summary PoolsHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2PairHourDataV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetPoolsHourDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current) 
         * @throws {RequiredError}
         */
        uniswapV2GetSwapsCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2SwapV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetSwapsCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical) 
         * @throws {RequiredError}
         */
        uniswapV2GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2SwapV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetSwapsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current) 
         * @throws {RequiredError}
         */
        uniswapV2GetTokensCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV2TokenV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTokensCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2TokenDayDataV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTokensDayDataHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        uniswapV2GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV2TokenV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV2TransactionV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetTransactionsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets users.
         * @summary Users (historical)
         * @throws {RequiredError}
         */
        uniswapV2GetUsersHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV2UserV2DTO>> {
            const localVarFetchArgs = UniswapV2ApiFetchParamCreator(configuration).uniswapV2GetUsersHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UniswapV3Api - fetch parameter creator
 * @export
 */
export const UniswapV3ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV3GetBundlesCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundles/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/bundles/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV3GetBurnsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/burns/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapv3 day data.
         * @summary DayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetDayDataCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/dayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets uniswapv3 day data.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/dayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factory.
         * @summary Factory (current)
         * @throws {RequiredError}
         */
        uniswapV3GetFactoryCurrent(options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/factory/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets factory.
         * @summary Factory (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/factory/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV3GetMintsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/mints/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (current) 
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsDayDataCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolsDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolsDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/pools/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools hour data.
         * @summary PoolsHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHourDataCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolsHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets pools hour data.
         * @summary PoolsHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/poolsHourData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions.
         * @summary Positions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions snapshots.
         * @summary PositionsSnaphots (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsSnaphotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionsSnapshots/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets positions snapshots.
         * @summary PositionsSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsSnapshotsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/positionSnapshots/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (current) 
         * @throws {RequiredError}
         */
        uniswapV3GetSwapsCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical) 
         * @throws {RequiredError}
         */
        uniswapV3GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/swaps/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks day data.
         * @summary TicksDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksDayDataCurrent(filterPoolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticksDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterPoolId !== undefined) {
                localVarQueryParameter['filter_pool_id'] = ((filterPoolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks day data.
         * @summary TicksDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticksDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ticks.
         * @summary Ticks (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/ticks/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (poolId !== undefined) {
                localVarQueryParameter['poolId'] = ((poolId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (current) 
         * @throws {RequiredError}
         */
        uniswapV3GetTokensCurrent(filterTokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterTokenId !== undefined) {
                localVarQueryParameter['filter_token_id'] = ((filterTokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensDayDataCurrent(filterTokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokensDayData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterTokenId !== undefined) {
                localVarQueryParameter['filter_token_id'] = ((filterTokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokensDayData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokens/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens hour data.
         * @summary TokensHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHourDataCurrent(filterTokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokensHourData/current`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (filterTokenId !== undefined) {
                localVarQueryParameter['filter_token_id'] = ((filterTokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets tokens hour data.
         * @summary TokensHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/tokensHourData/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = ((tokenId:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options: RequestOptions): FetchArgs {
            const localVarPath = `/dapps/uniswapv3/transactions/historical-manual`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            if (startBlock !== undefined) {
                localVarQueryParameter['startBlock'] = ((startBlock:any):string);
            }

            if (endBlock !== undefined) {
                localVarQueryParameter['endBlock'] = ((endBlock:any):string);
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = ((startDate:any):Date).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = ((endDate:any):Date).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UniswapV3ApiType = { 
    uniswapV3GetBundlesCurrent(options?: RequestOptions): Promise<Array<UniswapV3BundleV3DTO>>,

    uniswapV3GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV3BundleV3DTO>>,

    uniswapV3GetBurnsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3BurnV3DTO>>,

    uniswapV3GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3BurnV3DTO>>,

    uniswapV3GetDayDataCurrent(options?: RequestOptions): Promise<Array<UniswapV3UniswapDayDataV3DTO>>,

    uniswapV3GetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV3UniswapDayDataV3DTO>>,

    uniswapV3GetFactoryCurrent(options?: RequestOptions): Promise<Array<UniswapV3FactoryV3DTO>>,

    uniswapV3GetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV3FactoryV3DTO>>,

    uniswapV3GetMintsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3MintV3DTO>>,

    uniswapV3GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3MintV3DTO>>,

    uniswapV3GetPoolsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolV3DTO>>,

    uniswapV3GetPoolsDayDataCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDayDataV3DTO>>,

    uniswapV3GetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolDayDataV3DTO>>,

    uniswapV3GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolV3DTO>>,

    uniswapV3GetPoolsHourDataCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolHourDataV3DTO>>,

    uniswapV3GetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PoolHourDataV3DTO>>,

    uniswapV3GetPositionsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionV3DTO>>,

    uniswapV3GetPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionV3DTO>>,

    uniswapV3GetPositionsSnaphotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionSnapshotV3DTO>>,

    uniswapV3GetPositionsSnapshotsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3PositionSnapshotV3DTO>>,

    uniswapV3GetSwapsCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3SwapV3DTO>>,

    uniswapV3GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3SwapV3DTO>>,

    uniswapV3GetTicksCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3TickV3DTO>>,

    uniswapV3GetTicksDayDataCurrent(filterPoolId?: string, options?: RequestOptions): Promise<Array<UniswapV3TickDayDataV3DTO>>,

    uniswapV3GetTicksDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3TickDayDataV3DTO>>,

    uniswapV3GetTicksHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions): Promise<Array<UniswapV3TickV3DTO>>,

    uniswapV3GetTokensCurrent(filterTokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DTO>>,

    uniswapV3GetTokensDayDataCurrent(filterTokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DayDataDTO>>,

    uniswapV3GetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DayDataDTO>>,

    uniswapV3GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenV3DTO>>,

    uniswapV3GetTokensHourDataCurrent(filterTokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenHourDataV3DTO>>,

    uniswapV3GetTokensHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions): Promise<Array<UniswapV3TokenHourDataV3DTO>>,

    uniswapV3GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions): Promise<Array<UniswapV3TransactionV3DTO>>,
}

/**
 * UniswapV3Api - factory function to inject configuration 
 * @export
 */
export const UniswapV3Api = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UniswapV3ApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Gets bundles.
         * @summary Bundles (current)
         * @throws {RequiredError}
         */
        uniswapV3GetBundlesCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3BundleV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetBundlesCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets bundles.
         * @summary Bundles (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBundlesHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV3BundleV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetBundlesHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (current)
         * @throws {RequiredError}
         */
        uniswapV3GetBurnsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3BurnV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetBurnsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets burns.
         * @summary Burns (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetBurnsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3BurnV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetBurnsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapv3 day data.
         * @summary DayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetDayDataCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3UniswapDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetDayDataCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets uniswapv3 day data.
         * @summary DayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV3UniswapDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetDayDataHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factory.
         * @summary Factory (current)
         * @throws {RequiredError}
         */
        uniswapV3GetFactoryCurrent(options?: RequestOptions = {}): Promise<Array<UniswapV3FactoryV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetFactoryCurrent(options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets factory.
         * @summary Factory (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetFactoryHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV3FactoryV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetFactoryHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (current)
         * @throws {RequiredError}
         */
        uniswapV3GetMintsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3MintV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetMintsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets mints.
         * @summary Mints (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetMintsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3MintV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetMintsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (current) 
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsDayDataCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsDayDataCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools day data.
         * @summary PoolsDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsDayDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools.
         * @summary Pools (historical) 
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools hour data.
         * @summary PoolsHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHourDataCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolHourDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsHourDataCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets pools hour data.
         * @summary PoolsHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPoolsHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PoolHourDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPoolsHourDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPositionsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions.
         * @summary Positions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPositionsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions snapshots.
         * @summary PositionsSnaphots (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsSnaphotsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionSnapshotV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPositionsSnaphotsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets positions snapshots.
         * @summary PositionsSnapshots (current)
         * @throws {RequiredError}
         */
        uniswapV3GetPositionsSnapshotsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3PositionSnapshotV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetPositionsSnapshotsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (current) 
         * @throws {RequiredError}
         */
        uniswapV3GetSwapsCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3SwapV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetSwapsCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets swaps.
         * @summary Swaps (historical) 
         * @throws {RequiredError}
         */
        uniswapV3GetSwapsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3SwapV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetSwapsHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTicksCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks day data.
         * @summary TicksDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksDayDataCurrent(filterPoolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTicksDayDataCurrent(filterPoolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks day data.
         * @summary TicksDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickDayDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTicksDayDataHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets ticks.
         * @summary Ticks (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTicksHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, poolId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TickV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTicksHistorical(startBlock, endBlock, startDate, endDate, poolId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (current) 
         * @throws {RequiredError}
         */
        uniswapV3GetTokensCurrent(filterTokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensCurrent(filterTokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensDayDataCurrent(filterTokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensDayDataCurrent(filterTokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens day data.
         * @summary TokensDayData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensDayDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DayDataDTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensDayDataHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens.
         * @summary Tokens (historical) 
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens hour data.
         * @summary TokensHourData (current)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHourDataCurrent(filterTokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenHourDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensHourDataCurrent(filterTokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets tokens hour data.
         * @summary TokensHourData (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTokensHourDataHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, tokenId?: string, options?: RequestOptions = {}): Promise<Array<UniswapV3TokenHourDataV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTokensHourDataHistorical(startBlock, endBlock, startDate, endDate, tokenId, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Gets transactions.
         * @summary Transactions (historical)
         * @throws {RequiredError}
         */
        uniswapV3GetTransactionsHistorical(startBlock?: number, endBlock?: number, startDate?: Date, endDate?: Date, options?: RequestOptions = {}): Promise<Array<UniswapV3TransactionV3DTO>> {
            const localVarFetchArgs = UniswapV3ApiFetchParamCreator(configuration).uniswapV3GetTransactionsHistorical(startBlock, endBlock, startDate, endDate, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    CowApi: CowApiType,

    CurveApi: CurveApiType,

    DexApi: DexApiType,

    SushiswapApi: SushiswapApiType,

    UniswapV2Api: UniswapV2ApiType,

    UniswapV3Api: UniswapV3ApiType,
 }
