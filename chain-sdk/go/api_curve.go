/*
On Chain Dapps - REST API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// CurveApiService CurveApi service
type CurveApiService service

type ApiCurveAccountsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveAccountsCurrentRequest) Execute() ([]CurveAccountDTO, *http.Response, error) {
	return r.ApiService.CurveAccountsCurrentExecute(r)
}

/*
CurveAccountsCurrent Accounts (current)

Gets accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveAccountsCurrentRequest
*/
func (a *CurveApiService) CurveAccountsCurrent(ctx context.Context) ApiCurveAccountsCurrentRequest {
	return ApiCurveAccountsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAccountDTO
func (a *CurveApiService) CurveAccountsCurrentExecute(r ApiCurveAccountsCurrentRequest) ([]CurveAccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveAccountsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/accounts/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveAddLiquidityEventsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveAddLiquidityEventsCurrentRequest) Execute() ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveAddLiquidityEventsCurrentExecute(r)
}

/*
CurveAddLiquidityEventsCurrent AddLiquidityEvents (current)

Gets addLiquidityEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveAddLiquidityEventsCurrentRequest
*/
func (a *CurveApiService) CurveAddLiquidityEventsCurrent(ctx context.Context) ApiCurveAddLiquidityEventsCurrentRequest {
	return ApiCurveAddLiquidityEventsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAddLiquidityEventDTO
func (a *CurveApiService) CurveAddLiquidityEventsCurrentExecute(r ApiCurveAddLiquidityEventsCurrentRequest) ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAddLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveAddLiquidityEventsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/addLiquidityEvents/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveAdminFeeChangeLogsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveAdminFeeChangeLogsCurrentRequest) Execute() ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveAdminFeeChangeLogsCurrentExecute(r)
}

/*
CurveAdminFeeChangeLogsCurrent AdminFeeChangeLogs (current)

Gets adminFeeChangeLogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveAdminFeeChangeLogsCurrentRequest
*/
func (a *CurveApiService) CurveAdminFeeChangeLogsCurrent(ctx context.Context) ApiCurveAdminFeeChangeLogsCurrentRequest {
	return ApiCurveAdminFeeChangeLogsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAdminFeeChangeLogDTO
func (a *CurveApiService) CurveAdminFeeChangeLogsCurrentExecute(r ApiCurveAdminFeeChangeLogsCurrentRequest) ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAdminFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveAdminFeeChangeLogsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/adminFeeChangeLogs/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveAmplificationCoeffChangeLogsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveAmplificationCoeffChangeLogsCurrentRequest) Execute() ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveAmplificationCoeffChangeLogsCurrentExecute(r)
}

/*
CurveAmplificationCoeffChangeLogsCurrent AmplificationCoeffChangeLogs (current)

Gets amplificationCoeffChangeLogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveAmplificationCoeffChangeLogsCurrentRequest
*/
func (a *CurveApiService) CurveAmplificationCoeffChangeLogsCurrent(ctx context.Context) ApiCurveAmplificationCoeffChangeLogsCurrentRequest {
	return ApiCurveAmplificationCoeffChangeLogsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAmplificationCoeffChangeLogDTO
func (a *CurveApiService) CurveAmplificationCoeffChangeLogsCurrentExecute(r ApiCurveAmplificationCoeffChangeLogsCurrentRequest) ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAmplificationCoeffChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveAmplificationCoeffChangeLogsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/amplificationCoeffChangeLogs/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveCoinsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveCoinsCurrentRequest) Execute() ([]CurveCoinDTO, *http.Response, error) {
	return r.ApiService.CurveCoinsCurrentExecute(r)
}

/*
CurveCoinsCurrent Coins (current)

Gets coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveCoinsCurrentRequest
*/
func (a *CurveApiService) CurveCoinsCurrent(ctx context.Context) ApiCurveCoinsCurrentRequest {
	return ApiCurveCoinsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveCoinDTO
func (a *CurveApiService) CurveCoinsCurrentExecute(r ApiCurveCoinsCurrentRequest) ([]CurveCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveCoinsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/coins/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveContractVersionsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveContractVersionsCurrentRequest) Execute() ([]CurveContractVersionDTO, *http.Response, error) {
	return r.ApiService.CurveContractVersionsCurrentExecute(r)
}

/*
CurveContractVersionsCurrent ContractVersions (current)

Gets contractVersions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveContractVersionsCurrentRequest
*/
func (a *CurveApiService) CurveContractVersionsCurrent(ctx context.Context) ApiCurveContractVersionsCurrentRequest {
	return ApiCurveContractVersionsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractVersionDTO
func (a *CurveApiService) CurveContractVersionsCurrentExecute(r ApiCurveContractVersionsCurrentRequest) ([]CurveContractVersionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractVersionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveContractVersionsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contractVersions/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveContractsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveContractsCurrentRequest) Execute() ([]CurveContractDTO, *http.Response, error) {
	return r.ApiService.CurveContractsCurrentExecute(r)
}

/*
CurveContractsCurrent Contracts (current)

Gets contracts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveContractsCurrentRequest
*/
func (a *CurveApiService) CurveContractsCurrent(ctx context.Context) ApiCurveContractsCurrentRequest {
	return ApiCurveContractsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractDTO
func (a *CurveApiService) CurveContractsCurrentExecute(r ApiCurveContractsCurrentRequest) ([]CurveContractDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveContractsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contracts/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveDailyVolumesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveDailyVolumesCurrentRequest) Execute() ([]CurveDailyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveDailyVolumesCurrentExecute(r)
}

/*
CurveDailyVolumesCurrent DailyVolumes (current)

Gets dailyVolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveDailyVolumesCurrentRequest
*/
func (a *CurveApiService) CurveDailyVolumesCurrent(ctx context.Context) ApiCurveDailyVolumesCurrentRequest {
	return ApiCurveDailyVolumesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveDailyVolumeDTO
func (a *CurveApiService) CurveDailyVolumesCurrentExecute(r ApiCurveDailyVolumesCurrentRequest) ([]CurveDailyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveDailyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveDailyVolumesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/dailyVolumes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveExchangesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	pool *string
}

// 
func (r ApiCurveExchangesCurrentRequest) Pool(pool string) ApiCurveExchangesCurrentRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveExchangesCurrentRequest) Execute() ([]CurveExchangeDTO, *http.Response, error) {
	return r.ApiService.CurveExchangesCurrentExecute(r)
}

/*
CurveExchangesCurrent Exchanges (current)

Gets exchanges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveExchangesCurrentRequest
*/
func (a *CurveApiService) CurveExchangesCurrent(ctx context.Context) ApiCurveExchangesCurrentRequest {
	return ApiCurveExchangesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveExchangeDTO
func (a *CurveApiService) CurveExchangesCurrentExecute(r ApiCurveExchangesCurrentRequest) ([]CurveExchangeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveExchangeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveExchangesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/exchanges/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveFeeChangeLogsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveFeeChangeLogsCurrentRequest) Execute() ([]CurveFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveFeeChangeLogsCurrentExecute(r)
}

/*
CurveFeeChangeLogsCurrent FeeChangeLogs (current)

Gets feeChangeLogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveFeeChangeLogsCurrentRequest
*/
func (a *CurveApiService) CurveFeeChangeLogsCurrent(ctx context.Context) ApiCurveFeeChangeLogsCurrentRequest {
	return ApiCurveFeeChangeLogsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveFeeChangeLogDTO
func (a *CurveApiService) CurveFeeChangeLogsCurrentExecute(r ApiCurveFeeChangeLogsCurrentRequest) ([]CurveFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveFeeChangeLogsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/feeChangeLogs/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeDepositsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeDepositsCurrentRequest) Execute() ([]CurveGaugeDepositDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeDepositsCurrentExecute(r)
}

/*
CurveGaugeDepositsCurrent GaugeDeposits (current)

Gets gaugeDeposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeDepositsCurrentRequest
*/
func (a *CurveApiService) CurveGaugeDepositsCurrent(ctx context.Context) ApiCurveGaugeDepositsCurrentRequest {
	return ApiCurveGaugeDepositsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDepositDTO
func (a *CurveApiService) CurveGaugeDepositsCurrentExecute(r ApiCurveGaugeDepositsCurrentRequest) ([]CurveGaugeDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeDepositsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeDeposits/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeLiquiditiesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeLiquiditiesCurrentRequest) Execute() ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeLiquiditiesCurrentExecute(r)
}

/*
CurveGaugeLiquiditiesCurrent GaugeLiquidities (current)

Gets gaugeLiquidities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeLiquiditiesCurrentRequest
*/
func (a *CurveApiService) CurveGaugeLiquiditiesCurrent(ctx context.Context) ApiCurveGaugeLiquiditiesCurrentRequest {
	return ApiCurveGaugeLiquiditiesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeLiquidityDTO
func (a *CurveApiService) CurveGaugeLiquiditiesCurrentExecute(r ApiCurveGaugeLiquiditiesCurrentRequest) ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeLiquidityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeLiquiditiesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeLiquidities/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeTotalWeightsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeTotalWeightsCurrentRequest) Execute() ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeTotalWeightsCurrentExecute(r)
}

/*
CurveGaugeTotalWeightsCurrent GaugeTotalWeights (current)

Gets gaugeTotalWeights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeTotalWeightsCurrentRequest
*/
func (a *CurveApiService) CurveGaugeTotalWeightsCurrent(ctx context.Context) ApiCurveGaugeTotalWeightsCurrentRequest {
	return ApiCurveGaugeTotalWeightsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTotalWeightDTO
func (a *CurveApiService) CurveGaugeTotalWeightsCurrentExecute(r ApiCurveGaugeTotalWeightsCurrentRequest) ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTotalWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeTotalWeightsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeTotalWeights/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeTypeWeightsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeTypeWeightsCurrentRequest) Execute() ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeTypeWeightsCurrentExecute(r)
}

/*
CurveGaugeTypeWeightsCurrent GaugeTypeWeights (current)

Gets gaugeTypeWeights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeTypeWeightsCurrentRequest
*/
func (a *CurveApiService) CurveGaugeTypeWeightsCurrent(ctx context.Context) ApiCurveGaugeTypeWeightsCurrentRequest {
	return ApiCurveGaugeTypeWeightsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeWeightDTO
func (a *CurveApiService) CurveGaugeTypeWeightsCurrentExecute(r ApiCurveGaugeTypeWeightsCurrentRequest) ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeTypeWeightsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeTypeWeights/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeTypesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeTypesCurrentRequest) Execute() ([]CurveGaugeTypeDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeTypesCurrentExecute(r)
}

/*
CurveGaugeTypesCurrent GaugeTypes (current)

Gets gaugeTypes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeTypesCurrentRequest
*/
func (a *CurveApiService) CurveGaugeTypesCurrent(ctx context.Context) ApiCurveGaugeTypesCurrentRequest {
	return ApiCurveGaugeTypesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeDTO
func (a *CurveApiService) CurveGaugeTypesCurrentExecute(r ApiCurveGaugeTypesCurrentRequest) ([]CurveGaugeTypeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeTypesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeTypes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeWeightVotesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeWeightVotesCurrentRequest) Execute() ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeWeightVotesCurrentExecute(r)
}

/*
CurveGaugeWeightVotesCurrent GaugeWeightVotes (current)

Gets gaugeWeightVotes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeWeightVotesCurrentRequest
*/
func (a *CurveApiService) CurveGaugeWeightVotesCurrent(ctx context.Context) ApiCurveGaugeWeightVotesCurrentRequest {
	return ApiCurveGaugeWeightVotesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightVoteDTO
func (a *CurveApiService) CurveGaugeWeightVotesCurrentExecute(r ApiCurveGaugeWeightVotesCurrentRequest) ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeWeightVotesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeWeightVotes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeWeightsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeWeightsCurrentRequest) Execute() ([]CurveGaugeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeWeightsCurrentExecute(r)
}

/*
CurveGaugeWeightsCurrent GaugeWeights (current)

Gets gaugeWeights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeWeightsCurrentRequest
*/
func (a *CurveApiService) CurveGaugeWeightsCurrent(ctx context.Context) ApiCurveGaugeWeightsCurrentRequest {
	return ApiCurveGaugeWeightsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightDTO
func (a *CurveApiService) CurveGaugeWeightsCurrentExecute(r ApiCurveGaugeWeightsCurrentRequest) ([]CurveGaugeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeWeightsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeWeights/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugeWithdrawsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugeWithdrawsCurrentRequest) Execute() ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	return r.ApiService.CurveGaugeWithdrawsCurrentExecute(r)
}

/*
CurveGaugeWithdrawsCurrent GaugeWithdraws (current)

Gets gaugeWithdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugeWithdrawsCurrentRequest
*/
func (a *CurveApiService) CurveGaugeWithdrawsCurrent(ctx context.Context) ApiCurveGaugeWithdrawsCurrentRequest {
	return ApiCurveGaugeWithdrawsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWithdrawDTO
func (a *CurveApiService) CurveGaugeWithdrawsCurrentExecute(r ApiCurveGaugeWithdrawsCurrentRequest) ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugeWithdrawsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeWithdraws/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGaugesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveGaugesCurrentRequest) Execute() ([]CurveGaugeDTO, *http.Response, error) {
	return r.ApiService.CurveGaugesCurrentExecute(r)
}

/*
CurveGaugesCurrent Gauges (current)

Gets gauges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGaugesCurrentRequest
*/
func (a *CurveApiService) CurveGaugesCurrent(ctx context.Context) ApiCurveGaugesCurrentRequest {
	return ApiCurveGaugesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDTO
func (a *CurveApiService) CurveGaugesCurrentExecute(r ApiCurveGaugesCurrentRequest) ([]CurveGaugeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGaugesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gauges/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAccountsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAccountsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAccountsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAccountsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAccountsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAccountsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAccountsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) Id(id string) ApiCurveGetAccountsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAccountsHistoricalRequest) Address(address string) ApiCurveGetAccountsHistoricalRequest {
	r.address = &address
	return r
}

func (r ApiCurveGetAccountsHistoricalRequest) Execute() ([]CurveAccountDTO, *http.Response, error) {
	return r.ApiService.CurveGetAccountsHistoricalExecute(r)
}

/*
CurveGetAccountsHistorical Accounts (historical)

Gets accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAccountsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAccountsHistorical(ctx context.Context) ApiCurveGetAccountsHistoricalRequest {
	return ApiCurveGetAccountsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAccountDTO
func (a *CurveApiService) CurveGetAccountsHistoricalExecute(r ApiCurveGetAccountsHistoricalRequest) ([]CurveAccountDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAccountDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAccountsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/accounts/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAddLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Id(id string) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Pool(pool string) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetAddLiquidityEventsHistoricalRequest) Execute() ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetAddLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetAddLiquidityEventsHistorical AddLiquidityEvents (historical)

Gets addLiquidityEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAddLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAddLiquidityEventsHistorical(ctx context.Context) ApiCurveGetAddLiquidityEventsHistoricalRequest {
	return ApiCurveGetAddLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAddLiquidityEventDTO
func (a *CurveApiService) CurveGetAddLiquidityEventsHistoricalExecute(r ApiCurveGetAddLiquidityEventsHistoricalRequest) ([]CurveAddLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAddLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAddLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/addLiquidityEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAdminFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Id(id string) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Pool(pool string) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) Execute() ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAdminFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetAdminFeeChangeLogsHistorical AdminFeeChangeLogs (historical)

Gets adminFeeChangeLogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAdminFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetAdminFeeChangeLogsHistoricalRequest {
	return ApiCurveGetAdminFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAdminFeeChangeLogDTO
func (a *CurveApiService) CurveGetAdminFeeChangeLogsHistoricalExecute(r ApiCurveGetAdminFeeChangeLogsHistoricalRequest) ([]CurveAdminFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAdminFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAdminFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/adminFeeChangeLogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Id(id string) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Pool(pool string) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) Execute() ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r)
}

/*
CurveGetAmplificationCoeffChangeLogsHistorical AmplificationCoeffChangeLogs (historical)

Gets amplificationCoeffChangeLogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistorical(ctx context.Context) ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest {
	return ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveAmplificationCoeffChangeLogDTO
func (a *CurveApiService) CurveGetAmplificationCoeffChangeLogsHistoricalExecute(r ApiCurveGetAmplificationCoeffChangeLogsHistoricalRequest) ([]CurveAmplificationCoeffChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveAmplificationCoeffChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetAmplificationCoeffChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/amplificationCoeffChangeLogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

func (r ApiCurveGetCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Id(id string) ApiCurveGetCoinsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Pool(pool string) ApiCurveGetCoinsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetCoinsHistoricalRequest) Execute() ([]CurveCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetCoinsHistoricalExecute(r)
}

/*
CurveGetCoinsHistorical Coins (historical)

Gets coins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetCoinsHistorical(ctx context.Context) ApiCurveGetCoinsHistoricalRequest {
	return ApiCurveGetCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveCoinDTO
func (a *CurveApiService) CurveGetCoinsHistoricalExecute(r ApiCurveGetCoinsHistoricalRequest) ([]CurveCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/coins/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractVersionsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetContractVersionsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractVersionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetContractVersionsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractVersionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetContractVersionsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractVersionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetContractVersionsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractVersionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractVersionsHistoricalRequest) Id(id string) ApiCurveGetContractVersionsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetContractVersionsHistoricalRequest) Address(address string) ApiCurveGetContractVersionsHistoricalRequest {
	r.address = &address
	return r
}

func (r ApiCurveGetContractVersionsHistoricalRequest) Execute() ([]CurveContractVersionDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractVersionsHistoricalExecute(r)
}

/*
CurveGetContractVersionsHistorical ContractVersions (historical)

Gets contractVersions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractVersionsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractVersionsHistorical(ctx context.Context) ApiCurveGetContractVersionsHistoricalRequest {
	return ApiCurveGetContractVersionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractVersionDTO
func (a *CurveApiService) CurveGetContractVersionsHistoricalExecute(r ApiCurveGetContractVersionsHistoricalRequest) ([]CurveContractVersionDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractVersionDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractVersionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contractVersions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetContractsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetContractsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetContractsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetContractsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetContractsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetContractsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetContractsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetContractsHistoricalRequest) Id(id string) ApiCurveGetContractsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetContractsHistoricalRequest) Execute() ([]CurveContractDTO, *http.Response, error) {
	return r.ApiService.CurveGetContractsHistoricalExecute(r)
}

/*
CurveGetContractsHistorical Contracts (historical)

Gets contracts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetContractsHistoricalRequest
*/
func (a *CurveApiService) CurveGetContractsHistorical(ctx context.Context) ApiCurveGetContractsHistoricalRequest {
	return ApiCurveGetContractsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveContractDTO
func (a *CurveApiService) CurveGetContractsHistoricalExecute(r ApiCurveGetContractsHistoricalRequest) ([]CurveContractDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveContractDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetContractsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/contracts/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetDailyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetDailyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetDailyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetDailyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) Id(id string) ApiCurveGetDailyVolumesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetDailyVolumesHistoricalRequest) Pool(pool string) ApiCurveGetDailyVolumesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetDailyVolumesHistoricalRequest) Execute() ([]CurveDailyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetDailyVolumesHistoricalExecute(r)
}

/*
CurveGetDailyVolumesHistorical DailyVolumes (historical)

Gets dailyVolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetDailyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetDailyVolumesHistorical(ctx context.Context) ApiCurveGetDailyVolumesHistoricalRequest {
	return ApiCurveGetDailyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveDailyVolumeDTO
func (a *CurveApiService) CurveGetDailyVolumesHistoricalExecute(r ApiCurveGetDailyVolumesHistoricalRequest) ([]CurveDailyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveDailyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetDailyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/dailyVolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetExchangesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetExchangesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetExchangesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetExchangesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetExchangesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetExchangesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetExchangesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) Id(id string) ApiCurveGetExchangesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetExchangesHistoricalRequest) Pool(pool string) ApiCurveGetExchangesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetExchangesHistoricalRequest) Execute() ([]CurveExchangeDTO, *http.Response, error) {
	return r.ApiService.CurveGetExchangesHistoricalExecute(r)
}

/*
CurveGetExchangesHistorical Exchanges (historical)

Gets exchanges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetExchangesHistoricalRequest
*/
func (a *CurveApiService) CurveGetExchangesHistorical(ctx context.Context) ApiCurveGetExchangesHistoricalRequest {
	return ApiCurveGetExchangesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveExchangeDTO
func (a *CurveApiService) CurveGetExchangesHistoricalExecute(r ApiCurveGetExchangesHistoricalRequest) ([]CurveExchangeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveExchangeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetExchangesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/exchanges/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetFeeChangeLogsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Id(id string) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Pool(pool string) ApiCurveGetFeeChangeLogsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetFeeChangeLogsHistoricalRequest) Execute() ([]CurveFeeChangeLogDTO, *http.Response, error) {
	return r.ApiService.CurveGetFeeChangeLogsHistoricalExecute(r)
}

/*
CurveGetFeeChangeLogsHistorical FeeChangeLogs (historical)

Gets feeChangeLogs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetFeeChangeLogsHistoricalRequest
*/
func (a *CurveApiService) CurveGetFeeChangeLogsHistorical(ctx context.Context) ApiCurveGetFeeChangeLogsHistoricalRequest {
	return ApiCurveGetFeeChangeLogsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveFeeChangeLogDTO
func (a *CurveApiService) CurveGetFeeChangeLogsHistoricalExecute(r ApiCurveGetFeeChangeLogsHistoricalRequest) ([]CurveFeeChangeLogDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveFeeChangeLogDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetFeeChangeLogsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/feeChangeLogs/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeDepositsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeDepositsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeDepositsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeDepositsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeDepositsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeDepositsHistoricalRequest) Id(id string) ApiCurveGetGaugeDepositsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeDepositsHistoricalRequest) Execute() ([]CurveGaugeDepositDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeDepositsHistoricalExecute(r)
}

/*
CurveGetGaugeDepositsHistorical GaugeDeposits (historical)

Gets gaugeDeposits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeDepositsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeDepositsHistorical(ctx context.Context) ApiCurveGetGaugeDepositsHistoricalRequest {
	return ApiCurveGetGaugeDepositsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDepositDTO
func (a *CurveApiService) CurveGetGaugeDepositsHistoricalExecute(r ApiCurveGetGaugeDepositsHistoricalRequest) ([]CurveGaugeDepositDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDepositDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeDepositsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeDeposits/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeLiquiditiesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) Id(id string) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) User(user string) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiCurveGetGaugeLiquiditiesHistoricalRequest) Execute() ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeLiquiditiesHistoricalExecute(r)
}

/*
CurveGetGaugeLiquiditiesHistorical GaugeLiquidities (historical)

Gets gaugeLiquidities.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeLiquiditiesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeLiquiditiesHistorical(ctx context.Context) ApiCurveGetGaugeLiquiditiesHistoricalRequest {
	return ApiCurveGetGaugeLiquiditiesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeLiquidityDTO
func (a *CurveApiService) CurveGetGaugeLiquiditiesHistoricalExecute(r ApiCurveGetGaugeLiquiditiesHistoricalRequest) ([]CurveGaugeLiquidityDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeLiquidityDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeLiquiditiesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeLiquidities/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTotalWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) Id(id string) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeTotalWeightsHistoricalRequest) Execute() ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTotalWeightsHistoricalExecute(r)
}

/*
CurveGetGaugeTotalWeightsHistorical GaugeTotalWeights (historical)

Gets gaugeTotalWeights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTotalWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTotalWeightsHistorical(ctx context.Context) ApiCurveGetGaugeTotalWeightsHistoricalRequest {
	return ApiCurveGetGaugeTotalWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTotalWeightDTO
func (a *CurveApiService) CurveGetGaugeTotalWeightsHistoricalExecute(r ApiCurveGetGaugeTotalWeightsHistoricalRequest) ([]CurveGaugeTotalWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTotalWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTotalWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeTotalWeights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTypeWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) Id(id string) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeTypeWeightsHistoricalRequest) Execute() ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTypeWeightsHistoricalExecute(r)
}

/*
CurveGetGaugeTypeWeightsHistorical GaugeTypeWeights (historical)

Gets gaugeTypeWeights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTypeWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTypeWeightsHistorical(ctx context.Context) ApiCurveGetGaugeTypeWeightsHistoricalRequest {
	return ApiCurveGetGaugeTypeWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeWeightDTO
func (a *CurveApiService) CurveGetGaugeTypeWeightsHistoricalExecute(r ApiCurveGetGaugeTypeWeightsHistoricalRequest) ([]CurveGaugeTypeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTypeWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeTypeWeights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeTypesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeTypesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeTypesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeTypesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeTypesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeTypesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeTypesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeTypesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeTypesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeTypesHistoricalRequest) Id(id string) ApiCurveGetGaugeTypesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugeTypesHistoricalRequest) Name(name string) ApiCurveGetGaugeTypesHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiCurveGetGaugeTypesHistoricalRequest) Execute() ([]CurveGaugeTypeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeTypesHistoricalExecute(r)
}

/*
CurveGetGaugeTypesHistorical GaugeTypes (historical)

Gets gaugeTypes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeTypesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeTypesHistorical(ctx context.Context) ApiCurveGetGaugeTypesHistoricalRequest {
	return ApiCurveGetGaugeTypesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeTypeDTO
func (a *CurveApiService) CurveGetGaugeTypesHistoricalExecute(r ApiCurveGetGaugeTypesHistoricalRequest) ([]CurveGaugeTypeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeTypeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeTypesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeTypes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWeightVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	user *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) Id(id string) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) User(user string) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	r.user = &user
	return r
}

func (r ApiCurveGetGaugeWeightVotesHistoricalRequest) Execute() ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWeightVotesHistoricalExecute(r)
}

/*
CurveGetGaugeWeightVotesHistorical GaugeWeightVotes (historical)

Gets gaugeWeightVotes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWeightVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWeightVotesHistorical(ctx context.Context) ApiCurveGetGaugeWeightVotesHistoricalRequest {
	return ApiCurveGetGaugeWeightVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightVoteDTO
func (a *CurveApiService) CurveGetGaugeWeightVotesHistoricalExecute(r ApiCurveGetGaugeWeightVotesHistoricalRequest) ([]CurveGaugeWeightVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWeightVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeWeightVotes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.user != nil {
		localVarQueryParams.Add("user", parameterToString(*r.user, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWeightsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeWeightsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeWeightsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeWeightsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeWeightsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWeightsHistoricalRequest) Id(id string) ApiCurveGetGaugeWeightsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeWeightsHistoricalRequest) Execute() ([]CurveGaugeWeightDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWeightsHistoricalExecute(r)
}

/*
CurveGetGaugeWeightsHistorical GaugeWeights (historical)

Gets gaugeWeights.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWeightsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWeightsHistorical(ctx context.Context) ApiCurveGetGaugeWeightsHistoricalRequest {
	return ApiCurveGetGaugeWeightsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWeightDTO
func (a *CurveApiService) CurveGetGaugeWeightsHistoricalExecute(r ApiCurveGetGaugeWeightsHistoricalRequest) ([]CurveGaugeWeightDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWeightDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWeightsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeWeights/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugeWithdrawsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) Id(id string) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetGaugeWithdrawsHistoricalRequest) Execute() ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugeWithdrawsHistoricalExecute(r)
}

/*
CurveGetGaugeWithdrawsHistorical GaugeWithdraws (historical)

Gets gaugeWithdraws.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugeWithdrawsHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugeWithdrawsHistorical(ctx context.Context) ApiCurveGetGaugeWithdrawsHistoricalRequest {
	return ApiCurveGetGaugeWithdrawsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeWithdrawDTO
func (a *CurveApiService) CurveGetGaugeWithdrawsHistoricalExecute(r ApiCurveGetGaugeWithdrawsHistoricalRequest) ([]CurveGaugeWithdrawDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeWithdrawDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugeWithdrawsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gaugeWithdraws/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetGaugesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetGaugesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetGaugesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetGaugesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetGaugesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetGaugesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetGaugesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) Id(id string) ApiCurveGetGaugesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) Address(address string) ApiCurveGetGaugesHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiCurveGetGaugesHistoricalRequest) Pool(pool string) ApiCurveGetGaugesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetGaugesHistoricalRequest) Execute() ([]CurveGaugeDTO, *http.Response, error) {
	return r.ApiService.CurveGetGaugesHistoricalExecute(r)
}

/*
CurveGetGaugesHistorical Gauges (historical)

Gets gauges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetGaugesHistoricalRequest
*/
func (a *CurveApiService) CurveGetGaugesHistorical(ctx context.Context) ApiCurveGetGaugesHistoricalRequest {
	return ApiCurveGetGaugesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveGaugeDTO
func (a *CurveApiService) CurveGetGaugesHistoricalExecute(r ApiCurveGetGaugesHistoricalRequest) ([]CurveGaugeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveGaugeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetGaugesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/gauges/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetHourlyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetHourlyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetHourlyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) Id(id string) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetHourlyVolumesHistoricalRequest) Pool(pool string) ApiCurveGetHourlyVolumesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetHourlyVolumesHistoricalRequest) Execute() ([]CurveHourlyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetHourlyVolumesHistoricalExecute(r)
}

/*
CurveGetHourlyVolumesHistorical HourlyVolumes (historical)

Gets hourlyVolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetHourlyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetHourlyVolumesHistorical(ctx context.Context) ApiCurveGetHourlyVolumesHistoricalRequest {
	return ApiCurveGetHourlyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveHourlyVolumeDTO
func (a *CurveApiService) CurveGetHourlyVolumesHistoricalExecute(r ApiCurveGetHourlyVolumesHistoricalRequest) ([]CurveHourlyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveHourlyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetHourlyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/hourlyVolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetLpTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	name *string
	symbol *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetLpTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetLpTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetLpTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetLpTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetLpTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetLpTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Id(id string) ApiCurveGetLpTokensHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Address(address string) ApiCurveGetLpTokensHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Name(name string) ApiCurveGetLpTokensHistoricalRequest {
	r.name = &name
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Symbol(symbol string) ApiCurveGetLpTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

// 
func (r ApiCurveGetLpTokensHistoricalRequest) Pool(pool string) ApiCurveGetLpTokensHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetLpTokensHistoricalRequest) Execute() ([]CurveLpTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetLpTokensHistoricalExecute(r)
}

/*
CurveGetLpTokensHistorical LpTokens (historical)

Gets lpTokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetLpTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetLpTokensHistorical(ctx context.Context) ApiCurveGetLpTokensHistoricalRequest {
	return ApiCurveGetLpTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveLpTokenDTO
func (a *CurveApiService) CurveGetLpTokensHistoricalExecute(r ApiCurveGetLpTokensHistoricalRequest) ([]CurveLpTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveLpTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetLpTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/lpTokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetPoolsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	name *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetPoolsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetPoolsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetPoolsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetPoolsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetPoolsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetPoolsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Pool address.
func (r ApiCurveGetPoolsHistoricalRequest) Id(id string) ApiCurveGetPoolsHistoricalRequest {
	r.id = &id
	return r
}

// Pool&#39;s human-readable name.
func (r ApiCurveGetPoolsHistoricalRequest) Name(name string) ApiCurveGetPoolsHistoricalRequest {
	r.name = &name
	return r
}

func (r ApiCurveGetPoolsHistoricalRequest) Execute() ([]CurvePoolDTO, *http.Response, error) {
	return r.ApiService.CurveGetPoolsHistoricalExecute(r)
}

/*
CurveGetPoolsHistorical Pools (historical)

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetPoolsHistoricalRequest
*/
func (a *CurveApiService) CurveGetPoolsHistorical(ctx context.Context) ApiCurveGetPoolsHistoricalRequest {
	return ApiCurveGetPoolsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurvePoolDTO
func (a *CurveApiService) CurveGetPoolsHistoricalExecute(r ApiCurveGetPoolsHistoricalRequest) ([]CurvePoolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurvePoolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetPoolsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/pools/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalVotesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetProposalVotesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalVotesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetProposalVotesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalVotesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetProposalVotesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalVotesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetProposalVotesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalVotesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetProposalVotesHistoricalRequest) Id(id string) ApiCurveGetProposalVotesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetProposalVotesHistoricalRequest) Execute() ([]CurveProposalVoteDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalVotesHistoricalExecute(r)
}

/*
CurveGetProposalVotesHistorical ProposalVotes (historical)

Gets proposalVotes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalVotesHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalVotesHistorical(ctx context.Context) ApiCurveGetProposalVotesHistoricalRequest {
	return ApiCurveGetProposalVotesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalVoteDTO
func (a *CurveApiService) CurveGetProposalVotesHistoricalExecute(r ApiCurveGetProposalVotesHistoricalRequest) ([]CurveProposalVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalVotesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposalVotes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetProposalsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetProposalsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetProposalsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetProposalsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetProposalsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetProposalsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetProposalsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetProposalsHistoricalRequest) Id(id string) ApiCurveGetProposalsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetProposalsHistoricalRequest) Execute() ([]CurveProposalDTO, *http.Response, error) {
	return r.ApiService.CurveGetProposalsHistoricalExecute(r)
}

/*
CurveGetProposalsHistorical Proposals (historical)

Gets proposals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetProposalsHistoricalRequest
*/
func (a *CurveApiService) CurveGetProposalsHistorical(ctx context.Context) ApiCurveGetProposalsHistoricalRequest {
	return ApiCurveGetProposalsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalDTO
func (a *CurveApiService) CurveGetProposalsHistoricalExecute(r ApiCurveGetProposalsHistoricalRequest) ([]CurveProposalDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetProposalsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposals/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Id(id string) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Pool(pool string) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityEventsHistorical RemoveLiquidityEvents (historical)

Gets removeLiquidityEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityEventsHistoricalRequest) ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Id(id string) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Pool(pool string) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) Execute() ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetRemoveLiquidityOneEventsHistoricalExecute(r)
}

/*
CurveGetRemoveLiquidityOneEventsHistorical RemoveLiquidityOneEvents (historical)

Gets removeLiquidityOneEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistorical(ctx context.Context) ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest {
	return ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityOneEventDTO
func (a *CurveApiService) CurveGetRemoveLiquidityOneEventsHistoricalExecute(r ApiCurveGetRemoveLiquidityOneEventsHistoricalRequest) ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityOneEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetRemoveLiquidityOneEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityOneEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetSystemStatesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetSystemStatesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetSystemStatesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetSystemStatesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetSystemStatesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetSystemStatesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetSystemStatesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// Singleton ID, equals to &#39;current&#39;.
func (r ApiCurveGetSystemStatesHistoricalRequest) Id(id string) ApiCurveGetSystemStatesHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetSystemStatesHistoricalRequest) Execute() ([]CurveSystemStateDTO, *http.Response, error) {
	return r.ApiService.CurveGetSystemStatesHistoricalExecute(r)
}

/*
CurveGetSystemStatesHistorical SystemStates (historical)

Gets systemStates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetSystemStatesHistoricalRequest
*/
func (a *CurveApiService) CurveGetSystemStatesHistorical(ctx context.Context) ApiCurveGetSystemStatesHistoricalRequest {
	return ApiCurveGetSystemStatesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveSystemStateDTO
func (a *CurveApiService) CurveGetSystemStatesHistoricalExecute(r ApiCurveGetSystemStatesHistoricalRequest) ([]CurveSystemStateDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveSystemStateDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetSystemStatesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/systemStates/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
	name *string
	symbol *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetTokensHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetTokensHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetTokensHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetTokensHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Id(id string) ApiCurveGetTokensHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Address(address string) ApiCurveGetTokensHistoricalRequest {
	r.address = &address
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Name(name string) ApiCurveGetTokensHistoricalRequest {
	r.name = &name
	return r
}

// 
func (r ApiCurveGetTokensHistoricalRequest) Symbol(symbol string) ApiCurveGetTokensHistoricalRequest {
	r.symbol = &symbol
	return r
}

func (r ApiCurveGetTokensHistoricalRequest) Execute() ([]CurveTokenDTO, *http.Response, error) {
	return r.ApiService.CurveGetTokensHistoricalExecute(r)
}

/*
CurveGetTokensHistorical Tokens (historical)

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTokensHistoricalRequest
*/
func (a *CurveApiService) CurveGetTokensHistorical(ctx context.Context) ApiCurveGetTokensHistoricalRequest {
	return ApiCurveGetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTokenDTO
func (a *CurveApiService) CurveGetTokensHistoricalExecute(r ApiCurveGetTokensHistoricalRequest) ([]CurveTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetTransferOwnershipEventsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Id(id string) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Pool(pool string) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetTransferOwnershipEventsHistoricalRequest) Execute() ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	return r.ApiService.CurveGetTransferOwnershipEventsHistoricalExecute(r)
}

/*
CurveGetTransferOwnershipEventsHistorical TransferOwnershipEvents (historical)

Gets transferOwnershipEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetTransferOwnershipEventsHistoricalRequest
*/
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistorical(ctx context.Context) ApiCurveGetTransferOwnershipEventsHistoricalRequest {
	return ApiCurveGetTransferOwnershipEventsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTransferOwnershipEventDTO
func (a *CurveApiService) CurveGetTransferOwnershipEventsHistoricalExecute(r ApiCurveGetTransferOwnershipEventsHistoricalRequest) ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTransferOwnershipEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetTransferOwnershipEventsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/transferOwnershipEvents/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetUnderlyingCoinsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.startDate = &startDate
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Id(id string) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.id = &id
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Pool(pool string) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetUnderlyingCoinsHistoricalRequest) Execute() ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	return r.ApiService.CurveGetUnderlyingCoinsHistoricalExecute(r)
}

/*
CurveGetUnderlyingCoinsHistorical UnderlyingCoins (historical)

Gets underlyingCoins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetUnderlyingCoinsHistoricalRequest
*/
func (a *CurveApiService) CurveGetUnderlyingCoinsHistorical(ctx context.Context) ApiCurveGetUnderlyingCoinsHistoricalRequest {
	return ApiCurveGetUnderlyingCoinsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveUnderlyingCoinDTO
func (a *CurveApiService) CurveGetUnderlyingCoinsHistoricalExecute(r ApiCurveGetUnderlyingCoinsHistoricalRequest) ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveUnderlyingCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetUnderlyingCoinsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/underlyingCoins/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetVotingAppsHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	address *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetVotingAppsHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetVotingAppsHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetVotingAppsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetVotingAppsHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetVotingAppsHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetVotingAppsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// App address.
func (r ApiCurveGetVotingAppsHistoricalRequest) Id(id string) ApiCurveGetVotingAppsHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetVotingAppsHistoricalRequest) Address(address string) ApiCurveGetVotingAppsHistoricalRequest {
	r.address = &address
	return r
}

func (r ApiCurveGetVotingAppsHistoricalRequest) Execute() ([]CurveVotingAppDTO, *http.Response, error) {
	return r.ApiService.CurveGetVotingAppsHistoricalExecute(r)
}

/*
CurveGetVotingAppsHistorical VotingApps (historical)

Gets votingApps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetVotingAppsHistoricalRequest
*/
func (a *CurveApiService) CurveGetVotingAppsHistorical(ctx context.Context) ApiCurveGetVotingAppsHistoricalRequest {
	return ApiCurveGetVotingAppsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveVotingAppDTO
func (a *CurveApiService) CurveGetVotingAppsHistoricalExecute(r ApiCurveGetVotingAppsHistoricalRequest) ([]CurveVotingAppDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveVotingAppDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetVotingAppsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/votingApps/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.address != nil {
		localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveGetWeeklyVolumesHistoricalRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	id *string
	pool *string
}

// The start block. If endblock is not given, only those entities will be included that were exactly created in startBlock.
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartBlock(startBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// The end block. Useful to filter data in range of blocks (FROM startBlock TO endBlock).
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndBlock(endBlock int64) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// The start date of timeframe. If endDate is not given, entities created FROM startDate TO startDate plus 24 hours will be included.
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) StartDate(startDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// The end date of timeframe.
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) EndDate(endDate time.Time) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Id(id string) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.id = &id
	return r
}

// 
func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Pool(pool string) ApiCurveGetWeeklyVolumesHistoricalRequest {
	r.pool = &pool
	return r
}

func (r ApiCurveGetWeeklyVolumesHistoricalRequest) Execute() ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveGetWeeklyVolumesHistoricalExecute(r)
}

/*
CurveGetWeeklyVolumesHistorical WeeklyVolumes (historical)

Gets weeklyVolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveGetWeeklyVolumesHistoricalRequest
*/
func (a *CurveApiService) CurveGetWeeklyVolumesHistorical(ctx context.Context) ApiCurveGetWeeklyVolumesHistoricalRequest {
	return ApiCurveGetWeeklyVolumesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveWeeklyVolumeDTO
func (a *CurveApiService) CurveGetWeeklyVolumesHistoricalExecute(r ApiCurveGetWeeklyVolumesHistoricalRequest) ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveWeeklyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveGetWeeklyVolumesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/weeklyVolumes/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	if r.pool != nil {
		localVarQueryParams.Add("pool", parameterToString(*r.pool, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveHourlyVolumesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveHourlyVolumesCurrentRequest) Execute() ([]CurveHourlyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveHourlyVolumesCurrentExecute(r)
}

/*
CurveHourlyVolumesCurrent HourlyVolumes (current)

Gets hourlyVolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveHourlyVolumesCurrentRequest
*/
func (a *CurveApiService) CurveHourlyVolumesCurrent(ctx context.Context) ApiCurveHourlyVolumesCurrentRequest {
	return ApiCurveHourlyVolumesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveHourlyVolumeDTO
func (a *CurveApiService) CurveHourlyVolumesCurrentExecute(r ApiCurveHourlyVolumesCurrentRequest) ([]CurveHourlyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveHourlyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveHourlyVolumesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/hourlyVolumes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveLpTokensCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveLpTokensCurrentRequest) Execute() ([]CurveLpTokenDTO, *http.Response, error) {
	return r.ApiService.CurveLpTokensCurrentExecute(r)
}

/*
CurveLpTokensCurrent LpTokens (current)

Gets lpTokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveLpTokensCurrentRequest
*/
func (a *CurveApiService) CurveLpTokensCurrent(ctx context.Context) ApiCurveLpTokensCurrentRequest {
	return ApiCurveLpTokensCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveLpTokenDTO
func (a *CurveApiService) CurveLpTokensCurrentExecute(r ApiCurveLpTokensCurrentRequest) ([]CurveLpTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveLpTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveLpTokensCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/lpTokens/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurvePoolsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
	id *string
}

// Pool address.
func (r ApiCurvePoolsCurrentRequest) Id(id string) ApiCurvePoolsCurrentRequest {
	r.id = &id
	return r
}

func (r ApiCurvePoolsCurrentRequest) Execute() ([]CurvePoolDTO, *http.Response, error) {
	return r.ApiService.CurvePoolsCurrentExecute(r)
}

/*
CurvePoolsCurrent Pools (current)

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurvePoolsCurrentRequest
*/
func (a *CurveApiService) CurvePoolsCurrent(ctx context.Context) ApiCurvePoolsCurrentRequest {
	return ApiCurvePoolsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurvePoolDTO
func (a *CurveApiService) CurvePoolsCurrentExecute(r ApiCurvePoolsCurrentRequest) ([]CurvePoolDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurvePoolDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurvePoolsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/pools/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveProposalVotesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveProposalVotesCurrentRequest) Execute() ([]CurveProposalVoteDTO, *http.Response, error) {
	return r.ApiService.CurveProposalVotesCurrentExecute(r)
}

/*
CurveProposalVotesCurrent ProposalVotes (current)

Gets proposalVotes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveProposalVotesCurrentRequest
*/
func (a *CurveApiService) CurveProposalVotesCurrent(ctx context.Context) ApiCurveProposalVotesCurrentRequest {
	return ApiCurveProposalVotesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalVoteDTO
func (a *CurveApiService) CurveProposalVotesCurrentExecute(r ApiCurveProposalVotesCurrentRequest) ([]CurveProposalVoteDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalVoteDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveProposalVotesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposalVotes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveProposalsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveProposalsCurrentRequest) Execute() ([]CurveProposalDTO, *http.Response, error) {
	return r.ApiService.CurveProposalsCurrentExecute(r)
}

/*
CurveProposalsCurrent Proposals (current)

Gets proposals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveProposalsCurrentRequest
*/
func (a *CurveApiService) CurveProposalsCurrent(ctx context.Context) ApiCurveProposalsCurrentRequest {
	return ApiCurveProposalsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveProposalDTO
func (a *CurveApiService) CurveProposalsCurrentExecute(r ApiCurveProposalsCurrentRequest) ([]CurveProposalDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveProposalDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveProposalsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/proposals/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveRemoveLiquidityEventsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveRemoveLiquidityEventsCurrentRequest) Execute() ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	return r.ApiService.CurveRemoveLiquidityEventsCurrentExecute(r)
}

/*
CurveRemoveLiquidityEventsCurrent RemoveLiquidityEvents (current)

Gets removeLiquidityEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveRemoveLiquidityEventsCurrentRequest
*/
func (a *CurveApiService) CurveRemoveLiquidityEventsCurrent(ctx context.Context) ApiCurveRemoveLiquidityEventsCurrentRequest {
	return ApiCurveRemoveLiquidityEventsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityEventDTO
func (a *CurveApiService) CurveRemoveLiquidityEventsCurrentExecute(r ApiCurveRemoveLiquidityEventsCurrentRequest) ([]CurveRemoveLiquidityEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveRemoveLiquidityEventsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityEvents/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveRemoveLiquidityOneEventsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveRemoveLiquidityOneEventsCurrentRequest) Execute() ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	return r.ApiService.CurveRemoveLiquidityOneEventsCurrentExecute(r)
}

/*
CurveRemoveLiquidityOneEventsCurrent RemoveLiquidityOneEvents (current)

Gets removeLiquidityOneEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveRemoveLiquidityOneEventsCurrentRequest
*/
func (a *CurveApiService) CurveRemoveLiquidityOneEventsCurrent(ctx context.Context) ApiCurveRemoveLiquidityOneEventsCurrentRequest {
	return ApiCurveRemoveLiquidityOneEventsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveRemoveLiquidityOneEventDTO
func (a *CurveApiService) CurveRemoveLiquidityOneEventsCurrentExecute(r ApiCurveRemoveLiquidityOneEventsCurrentRequest) ([]CurveRemoveLiquidityOneEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveRemoveLiquidityOneEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveRemoveLiquidityOneEventsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/removeLiquidityOneEvents/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveSystemStatesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveSystemStatesCurrentRequest) Execute() ([]CurveSystemStateDTO, *http.Response, error) {
	return r.ApiService.CurveSystemStatesCurrentExecute(r)
}

/*
CurveSystemStatesCurrent SystemStates (current)

Gets systemStates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveSystemStatesCurrentRequest
*/
func (a *CurveApiService) CurveSystemStatesCurrent(ctx context.Context) ApiCurveSystemStatesCurrentRequest {
	return ApiCurveSystemStatesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveSystemStateDTO
func (a *CurveApiService) CurveSystemStatesCurrentExecute(r ApiCurveSystemStatesCurrentRequest) ([]CurveSystemStateDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveSystemStateDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveSystemStatesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/systemStates/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveTokensCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveTokensCurrentRequest) Execute() ([]CurveTokenDTO, *http.Response, error) {
	return r.ApiService.CurveTokensCurrentExecute(r)
}

/*
CurveTokensCurrent Tokens (current)

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveTokensCurrentRequest
*/
func (a *CurveApiService) CurveTokensCurrent(ctx context.Context) ApiCurveTokensCurrentRequest {
	return ApiCurveTokensCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTokenDTO
func (a *CurveApiService) CurveTokensCurrentExecute(r ApiCurveTokensCurrentRequest) ([]CurveTokenDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTokenDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveTokensCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/tokens/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveTransferOwnershipEventsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveTransferOwnershipEventsCurrentRequest) Execute() ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	return r.ApiService.CurveTransferOwnershipEventsCurrentExecute(r)
}

/*
CurveTransferOwnershipEventsCurrent TransferOwnershipEvents (current)

Gets transferOwnershipEvents.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveTransferOwnershipEventsCurrentRequest
*/
func (a *CurveApiService) CurveTransferOwnershipEventsCurrent(ctx context.Context) ApiCurveTransferOwnershipEventsCurrentRequest {
	return ApiCurveTransferOwnershipEventsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveTransferOwnershipEventDTO
func (a *CurveApiService) CurveTransferOwnershipEventsCurrentExecute(r ApiCurveTransferOwnershipEventsCurrentRequest) ([]CurveTransferOwnershipEventDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveTransferOwnershipEventDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveTransferOwnershipEventsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/transferOwnershipEvents/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveUnderlyingCoinsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveUnderlyingCoinsCurrentRequest) Execute() ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	return r.ApiService.CurveUnderlyingCoinsCurrentExecute(r)
}

/*
CurveUnderlyingCoinsCurrent UnderlyingCoins (current)

Gets underlyingCoins.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveUnderlyingCoinsCurrentRequest
*/
func (a *CurveApiService) CurveUnderlyingCoinsCurrent(ctx context.Context) ApiCurveUnderlyingCoinsCurrentRequest {
	return ApiCurveUnderlyingCoinsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveUnderlyingCoinDTO
func (a *CurveApiService) CurveUnderlyingCoinsCurrentExecute(r ApiCurveUnderlyingCoinsCurrentRequest) ([]CurveUnderlyingCoinDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveUnderlyingCoinDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveUnderlyingCoinsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/underlyingCoins/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveVotingAppsCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveVotingAppsCurrentRequest) Execute() ([]CurveVotingAppDTO, *http.Response, error) {
	return r.ApiService.CurveVotingAppsCurrentExecute(r)
}

/*
CurveVotingAppsCurrent VotingApps (current)

Gets votingApps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveVotingAppsCurrentRequest
*/
func (a *CurveApiService) CurveVotingAppsCurrent(ctx context.Context) ApiCurveVotingAppsCurrentRequest {
	return ApiCurveVotingAppsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveVotingAppDTO
func (a *CurveApiService) CurveVotingAppsCurrentExecute(r ApiCurveVotingAppsCurrentRequest) ([]CurveVotingAppDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveVotingAppDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveVotingAppsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/votingApps/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCurveWeeklyVolumesCurrentRequest struct {
	ctx context.Context
	ApiService *CurveApiService
}

func (r ApiCurveWeeklyVolumesCurrentRequest) Execute() ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	return r.ApiService.CurveWeeklyVolumesCurrentExecute(r)
}

/*
CurveWeeklyVolumesCurrent WeeklyVolumes (current)

Gets weeklyVolumes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCurveWeeklyVolumesCurrentRequest
*/
func (a *CurveApiService) CurveWeeklyVolumesCurrent(ctx context.Context) ApiCurveWeeklyVolumesCurrentRequest {
	return ApiCurveWeeklyVolumesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CurveWeeklyVolumeDTO
func (a *CurveApiService) CurveWeeklyVolumesCurrentExecute(r ApiCurveWeeklyVolumesCurrentRequest) ([]CurveWeeklyVolumeDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CurveWeeklyVolumeDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CurveApiService.CurveWeeklyVolumesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/curve/weeklyVolumes/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
