/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// UniswapV3ApiService UniswapV3Api service
type UniswapV3ApiService service

type ApiUniswapV3GetBundlesCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
}

func (r ApiUniswapV3GetBundlesCurrentRequest) Execute() ([]UniswapV3BundleV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetBundlesCurrentExecute(r)
}

/*
UniswapV3GetBundlesCurrent Bundles (current)

Gets bundles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetBundlesCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetBundlesCurrent(ctx context.Context) ApiUniswapV3GetBundlesCurrentRequest {
	return ApiUniswapV3GetBundlesCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3BundleV3DTO
func (a *UniswapV3ApiService) UniswapV3GetBundlesCurrentExecute(r ApiUniswapV3GetBundlesCurrentRequest) ([]UniswapV3BundleV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3BundleV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetBundlesCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/bundles/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetBundlesHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV3GetBundlesHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetBundlesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetBundlesHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetBundlesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetBundlesHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetBundlesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetBundlesHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetBundlesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV3GetBundlesHistoricalRequest) Execute() ([]UniswapV3BundleV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetBundlesHistoricalExecute(r)
}

/*
UniswapV3GetBundlesHistorical Bundles (historical)

Gets bundles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetBundlesHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetBundlesHistorical(ctx context.Context) ApiUniswapV3GetBundlesHistoricalRequest {
	return ApiUniswapV3GetBundlesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3BundleV3DTO
func (a *UniswapV3ApiService) UniswapV3GetBundlesHistoricalExecute(r ApiUniswapV3GetBundlesHistoricalRequest) ([]UniswapV3BundleV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3BundleV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetBundlesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/bundles/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetBurnsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetBurnsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetBurnsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetBurnsCurrentRequest) Execute() ([]UniswapV3BurnV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetBurnsCurrentExecute(r)
}

/*
UniswapV3GetBurnsCurrent Burns (current)

Gets burns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetBurnsCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetBurnsCurrent(ctx context.Context) ApiUniswapV3GetBurnsCurrentRequest {
	return ApiUniswapV3GetBurnsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3BurnV3DTO
func (a *UniswapV3ApiService) UniswapV3GetBurnsCurrentExecute(r ApiUniswapV3GetBurnsCurrentRequest) ([]UniswapV3BurnV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3BurnV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetBurnsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/burns/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetBurnsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetBurnsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetBurnsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetBurnsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetBurnsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetBurnsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetBurnsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetBurnsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetBurnsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetBurnsHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetBurnsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetBurnsHistoricalRequest) Execute() ([]UniswapV3BurnV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetBurnsHistoricalExecute(r)
}

/*
UniswapV3GetBurnsHistorical Burns (historical)

Gets burns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetBurnsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetBurnsHistorical(ctx context.Context) ApiUniswapV3GetBurnsHistoricalRequest {
	return ApiUniswapV3GetBurnsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3BurnV3DTO
func (a *UniswapV3ApiService) UniswapV3GetBurnsHistoricalExecute(r ApiUniswapV3GetBurnsHistoricalRequest) ([]UniswapV3BurnV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3BurnV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetBurnsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/burns/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
}

func (r ApiUniswapV3GetDayDataCurrentRequest) Execute() ([]UniswapV3UniswapDayDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetDayDataCurrentExecute(r)
}

/*
UniswapV3GetDayDataCurrent DayData (current)

Gets uniswapv3 day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetDayDataCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetDayDataCurrent(ctx context.Context) ApiUniswapV3GetDayDataCurrentRequest {
	return ApiUniswapV3GetDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3UniswapDayDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetDayDataCurrentExecute(r ApiUniswapV3GetDayDataCurrentRequest) ([]UniswapV3UniswapDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3UniswapDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/dayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV3GetDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV3GetDayDataHistoricalRequest) Execute() ([]UniswapV3UniswapDayDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetDayDataHistoricalExecute(r)
}

/*
UniswapV3GetDayDataHistorical DayData (historical)

Gets uniswapv3 day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetDayDataHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetDayDataHistorical(ctx context.Context) ApiUniswapV3GetDayDataHistoricalRequest {
	return ApiUniswapV3GetDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3UniswapDayDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetDayDataHistoricalExecute(r ApiUniswapV3GetDayDataHistoricalRequest) ([]UniswapV3UniswapDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3UniswapDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/dayData/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetFactoryCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
}

func (r ApiUniswapV3GetFactoryCurrentRequest) Execute() ([]UniswapV3FactoryV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetFactoryCurrentExecute(r)
}

/*
UniswapV3GetFactoryCurrent Factory (current)

Gets factory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetFactoryCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetFactoryCurrent(ctx context.Context) ApiUniswapV3GetFactoryCurrentRequest {
	return ApiUniswapV3GetFactoryCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3FactoryV3DTO
func (a *UniswapV3ApiService) UniswapV3GetFactoryCurrentExecute(r ApiUniswapV3GetFactoryCurrentRequest) ([]UniswapV3FactoryV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3FactoryV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetFactoryCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/factory/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetFactoryHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV3GetFactoryHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetFactoryHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetFactoryHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetFactoryHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetFactoryHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetFactoryHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetFactoryHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetFactoryHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV3GetFactoryHistoricalRequest) Execute() ([]UniswapV3FactoryV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetFactoryHistoricalExecute(r)
}

/*
UniswapV3GetFactoryHistorical Factory (historical)

Gets factory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetFactoryHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetFactoryHistorical(ctx context.Context) ApiUniswapV3GetFactoryHistoricalRequest {
	return ApiUniswapV3GetFactoryHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3FactoryV3DTO
func (a *UniswapV3ApiService) UniswapV3GetFactoryHistoricalExecute(r ApiUniswapV3GetFactoryHistoricalRequest) ([]UniswapV3FactoryV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3FactoryV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetFactoryHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/factory/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetMintsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetMintsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetMintsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetMintsCurrentRequest) Execute() ([]UniswapV3MintV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetMintsCurrentExecute(r)
}

/*
UniswapV3GetMintsCurrent Mints (current)

Gets mints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetMintsCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetMintsCurrent(ctx context.Context) ApiUniswapV3GetMintsCurrentRequest {
	return ApiUniswapV3GetMintsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3MintV3DTO
func (a *UniswapV3ApiService) UniswapV3GetMintsCurrentExecute(r ApiUniswapV3GetMintsCurrentRequest) ([]UniswapV3MintV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3MintV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetMintsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/mints/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetMintsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetMintsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetMintsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetMintsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetMintsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetMintsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetMintsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetMintsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetMintsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetMintsHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetMintsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetMintsHistoricalRequest) Execute() ([]UniswapV3MintV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetMintsHistoricalExecute(r)
}

/*
UniswapV3GetMintsHistorical Mints (historical)

Gets mints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetMintsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetMintsHistorical(ctx context.Context) ApiUniswapV3GetMintsHistoricalRequest {
	return ApiUniswapV3GetMintsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3MintV3DTO
func (a *UniswapV3ApiService) UniswapV3GetMintsHistoricalExecute(r ApiUniswapV3GetMintsHistoricalRequest) ([]UniswapV3MintV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3MintV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetMintsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/mints/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPoolsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetPoolsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetPoolsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetPoolsCurrentRequest) Execute() ([]UniswapV3PoolV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPoolsCurrentExecute(r)
}

/*
UniswapV3GetPoolsCurrent Pools (current) ðŸ”¥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPoolsCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPoolsCurrent(ctx context.Context) ApiUniswapV3GetPoolsCurrentRequest {
	return ApiUniswapV3GetPoolsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PoolV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPoolsCurrentExecute(r ApiUniswapV3GetPoolsCurrentRequest) ([]UniswapV3PoolV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PoolV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPoolsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/pools/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPoolsDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetPoolsDayDataCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetPoolsDayDataCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetPoolsDayDataCurrentRequest) Execute() ([]UniswapV3PoolDayDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPoolsDayDataCurrentExecute(r)
}

/*
UniswapV3GetPoolsDayDataCurrent PoolsDayData (current)

Gets pools day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPoolsDayDataCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPoolsDayDataCurrent(ctx context.Context) ApiUniswapV3GetPoolsDayDataCurrentRequest {
	return ApiUniswapV3GetPoolsDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PoolDayDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPoolsDayDataCurrentExecute(r ApiUniswapV3GetPoolsDayDataCurrentRequest) ([]UniswapV3PoolDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PoolDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPoolsDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/poolsDayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPoolsDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetPoolsDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetPoolsDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetPoolsDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetPoolsDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetPoolsDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetPoolsDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetPoolsDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetPoolsDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetPoolsDayDataHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetPoolsDayDataHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetPoolsDayDataHistoricalRequest) Execute() ([]UniswapV3PoolDayDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPoolsDayDataHistoricalExecute(r)
}

/*
UniswapV3GetPoolsDayDataHistorical PoolsDayData (historical)

Gets pools day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPoolsDayDataHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPoolsDayDataHistorical(ctx context.Context) ApiUniswapV3GetPoolsDayDataHistoricalRequest {
	return ApiUniswapV3GetPoolsDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PoolDayDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPoolsDayDataHistoricalExecute(r ApiUniswapV3GetPoolsDayDataHistoricalRequest) ([]UniswapV3PoolDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PoolDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPoolsDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/poolsDayData/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPoolsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetPoolsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetPoolsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetPoolsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetPoolsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetPoolsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetPoolsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetPoolsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetPoolsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetPoolsHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetPoolsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetPoolsHistoricalRequest) Execute() ([]UniswapV3PoolV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPoolsHistoricalExecute(r)
}

/*
UniswapV3GetPoolsHistorical Pools (historical) ðŸ”¥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPoolsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPoolsHistorical(ctx context.Context) ApiUniswapV3GetPoolsHistoricalRequest {
	return ApiUniswapV3GetPoolsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PoolV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPoolsHistoricalExecute(r ApiUniswapV3GetPoolsHistoricalRequest) ([]UniswapV3PoolV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PoolV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPoolsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/pools/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPoolsHourDataCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetPoolsHourDataCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetPoolsHourDataCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetPoolsHourDataCurrentRequest) Execute() ([]UniswapV3PoolHourDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPoolsHourDataCurrentExecute(r)
}

/*
UniswapV3GetPoolsHourDataCurrent PoolsHourData (current)

Gets pools hour data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPoolsHourDataCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPoolsHourDataCurrent(ctx context.Context) ApiUniswapV3GetPoolsHourDataCurrentRequest {
	return ApiUniswapV3GetPoolsHourDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PoolHourDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPoolsHourDataCurrentExecute(r ApiUniswapV3GetPoolsHourDataCurrentRequest) ([]UniswapV3PoolHourDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PoolHourDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPoolsHourDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/poolsHourData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPoolsHourDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetPoolsHourDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetPoolsHourDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetPoolsHourDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetPoolsHourDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetPoolsHourDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetPoolsHourDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetPoolsHourDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetPoolsHourDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetPoolsHourDataHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetPoolsHourDataHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetPoolsHourDataHistoricalRequest) Execute() ([]UniswapV3PoolHourDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPoolsHourDataHistoricalExecute(r)
}

/*
UniswapV3GetPoolsHourDataHistorical PoolsHourData (historical)

Gets pools hour data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPoolsHourDataHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPoolsHourDataHistorical(ctx context.Context) ApiUniswapV3GetPoolsHourDataHistoricalRequest {
	return ApiUniswapV3GetPoolsHourDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PoolHourDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPoolsHourDataHistoricalExecute(r ApiUniswapV3GetPoolsHourDataHistoricalRequest) ([]UniswapV3PoolHourDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PoolHourDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPoolsHourDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/poolsHourData/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPositionsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetPositionsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetPositionsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetPositionsCurrentRequest) Execute() ([]UniswapV3PositionV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPositionsCurrentExecute(r)
}

/*
UniswapV3GetPositionsCurrent Positions (current)

Gets positions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPositionsCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPositionsCurrent(ctx context.Context) ApiUniswapV3GetPositionsCurrentRequest {
	return ApiUniswapV3GetPositionsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PositionV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPositionsCurrentExecute(r ApiUniswapV3GetPositionsCurrentRequest) ([]UniswapV3PositionV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PositionV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPositionsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/positions/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPositionsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetPositionsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetPositionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetPositionsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetPositionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetPositionsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetPositionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetPositionsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetPositionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetPositionsHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetPositionsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetPositionsHistoricalRequest) Execute() ([]UniswapV3PositionV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPositionsHistoricalExecute(r)
}

/*
UniswapV3GetPositionsHistorical Positions (historical)

Gets positions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPositionsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPositionsHistorical(ctx context.Context) ApiUniswapV3GetPositionsHistoricalRequest {
	return ApiUniswapV3GetPositionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PositionV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPositionsHistoricalExecute(r ApiUniswapV3GetPositionsHistoricalRequest) ([]UniswapV3PositionV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PositionV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPositionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/positions/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPositionsSnaphotsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetPositionsSnaphotsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetPositionsSnaphotsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetPositionsSnaphotsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetPositionsSnaphotsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetPositionsSnaphotsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) Execute() ([]UniswapV3PositionSnapshotV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPositionsSnaphotsHistoricalExecute(r)
}

/*
UniswapV3GetPositionsSnaphotsHistorical PositionsSnaphots (historical)

Gets positions snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPositionsSnaphotsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPositionsSnaphotsHistorical(ctx context.Context) ApiUniswapV3GetPositionsSnaphotsHistoricalRequest {
	return ApiUniswapV3GetPositionsSnaphotsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PositionSnapshotV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPositionsSnaphotsHistoricalExecute(r ApiUniswapV3GetPositionsSnaphotsHistoricalRequest) ([]UniswapV3PositionSnapshotV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PositionSnapshotV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPositionsSnaphotsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/positionsSnapshots/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetPositionsSnapshotsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetPositionsSnapshotsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetPositionsSnapshotsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetPositionsSnapshotsCurrentRequest) Execute() ([]UniswapV3PositionSnapshotV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetPositionsSnapshotsCurrentExecute(r)
}

/*
UniswapV3GetPositionsSnapshotsCurrent PositionsSnapshots (current)

Gets positions snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetPositionsSnapshotsCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetPositionsSnapshotsCurrent(ctx context.Context) ApiUniswapV3GetPositionsSnapshotsCurrentRequest {
	return ApiUniswapV3GetPositionsSnapshotsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3PositionSnapshotV3DTO
func (a *UniswapV3ApiService) UniswapV3GetPositionsSnapshotsCurrentExecute(r ApiUniswapV3GetPositionsSnapshotsCurrentRequest) ([]UniswapV3PositionSnapshotV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3PositionSnapshotV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetPositionsSnapshotsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/positionSnapshots/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetSwapsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetSwapsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetSwapsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetSwapsCurrentRequest) Execute() ([]UniswapV3SwapV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetSwapsCurrentExecute(r)
}

/*
UniswapV3GetSwapsCurrent Swaps (current) ðŸ”¥

Gets swaps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetSwapsCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetSwapsCurrent(ctx context.Context) ApiUniswapV3GetSwapsCurrentRequest {
	return ApiUniswapV3GetSwapsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3SwapV3DTO
func (a *UniswapV3ApiService) UniswapV3GetSwapsCurrentExecute(r ApiUniswapV3GetSwapsCurrentRequest) ([]UniswapV3SwapV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3SwapV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetSwapsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/swaps/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetSwapsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetSwapsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetSwapsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetSwapsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetSwapsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetSwapsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetSwapsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetSwapsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetSwapsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetSwapsHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetSwapsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetSwapsHistoricalRequest) Execute() ([]UniswapV3SwapV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetSwapsHistoricalExecute(r)
}

/*
UniswapV3GetSwapsHistorical Swaps (historical) ðŸ”¥

Gets swaps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetSwapsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetSwapsHistorical(ctx context.Context) ApiUniswapV3GetSwapsHistoricalRequest {
	return ApiUniswapV3GetSwapsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3SwapV3DTO
func (a *UniswapV3ApiService) UniswapV3GetSwapsHistoricalExecute(r ApiUniswapV3GetSwapsHistoricalRequest) ([]UniswapV3SwapV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3SwapV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetSwapsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/swaps/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTicksCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetTicksCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetTicksCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetTicksCurrentRequest) Execute() ([]UniswapV3TickV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTicksCurrentExecute(r)
}

/*
UniswapV3GetTicksCurrent Ticks (current)

Gets ticks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTicksCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTicksCurrent(ctx context.Context) ApiUniswapV3GetTicksCurrentRequest {
	return ApiUniswapV3GetTicksCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TickV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTicksCurrentExecute(r ApiUniswapV3GetTicksCurrentRequest) ([]UniswapV3TickV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TickV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTicksCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/ticks/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTicksDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterPoolId *string
}

func (r ApiUniswapV3GetTicksDayDataCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV3GetTicksDayDataCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV3GetTicksDayDataCurrentRequest) Execute() ([]UniswapV3TickDayDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTicksDayDataCurrentExecute(r)
}

/*
UniswapV3GetTicksDayDataCurrent TicksDayData (current)

Gets ticks day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTicksDayDataCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTicksDayDataCurrent(ctx context.Context) ApiUniswapV3GetTicksDayDataCurrentRequest {
	return ApiUniswapV3GetTicksDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TickDayDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTicksDayDataCurrentExecute(r ApiUniswapV3GetTicksDayDataCurrentRequest) ([]UniswapV3TickDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TickDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTicksDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/ticksDayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTicksDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetTicksDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetTicksDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetTicksDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetTicksDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetTicksDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetTicksDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetTicksDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetTicksDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetTicksDayDataHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetTicksDayDataHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetTicksDayDataHistoricalRequest) Execute() ([]UniswapV3TickDayDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTicksDayDataHistoricalExecute(r)
}

/*
UniswapV3GetTicksDayDataHistorical TicksDayData (historical)

Gets ticks day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTicksDayDataHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTicksDayDataHistorical(ctx context.Context) ApiUniswapV3GetTicksDayDataHistoricalRequest {
	return ApiUniswapV3GetTicksDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TickDayDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTicksDayDataHistoricalExecute(r ApiUniswapV3GetTicksDayDataHistoricalRequest) ([]UniswapV3TickDayDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TickDayDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTicksDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/ticksDayData/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTicksHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV3GetTicksHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetTicksHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetTicksHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetTicksHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetTicksHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetTicksHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetTicksHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetTicksHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetTicksHistoricalRequest) PoolId(poolId string) ApiUniswapV3GetTicksHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV3GetTicksHistoricalRequest) Execute() ([]UniswapV3TickV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTicksHistoricalExecute(r)
}

/*
UniswapV3GetTicksHistorical Ticks (historical)

Gets ticks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTicksHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTicksHistorical(ctx context.Context) ApiUniswapV3GetTicksHistoricalRequest {
	return ApiUniswapV3GetTicksHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TickV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTicksHistoricalExecute(r ApiUniswapV3GetTicksHistoricalRequest) ([]UniswapV3TickV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TickV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTicksHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/ticks/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTokensCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterTokenId *string
}

func (r ApiUniswapV3GetTokensCurrentRequest) FilterTokenId(filterTokenId string) ApiUniswapV3GetTokensCurrentRequest {
	r.filterTokenId = &filterTokenId
	return r
}

func (r ApiUniswapV3GetTokensCurrentRequest) Execute() ([]UniswapV3TokenV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTokensCurrentExecute(r)
}

/*
UniswapV3GetTokensCurrent Tokens (current) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTokensCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTokensCurrent(ctx context.Context) ApiUniswapV3GetTokensCurrentRequest {
	return ApiUniswapV3GetTokensCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TokenV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTokensCurrentExecute(r ApiUniswapV3GetTokensCurrentRequest) ([]UniswapV3TokenV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TokenV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTokensCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/tokens/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTokenId != nil {
		localVarQueryParams.Add("filter_token_id", parameterToString(*r.filterTokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTokensDayDataCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterTokenId *string
}

func (r ApiUniswapV3GetTokensDayDataCurrentRequest) FilterTokenId(filterTokenId string) ApiUniswapV3GetTokensDayDataCurrentRequest {
	r.filterTokenId = &filterTokenId
	return r
}

func (r ApiUniswapV3GetTokensDayDataCurrentRequest) Execute() ([]UniswapV3TokenV3DayDataDTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTokensDayDataCurrentExecute(r)
}

/*
UniswapV3GetTokensDayDataCurrent TokensDayData (current)

Gets tokens day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTokensDayDataCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTokensDayDataCurrent(ctx context.Context) ApiUniswapV3GetTokensDayDataCurrentRequest {
	return ApiUniswapV3GetTokensDayDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TokenV3DayDataDTO
func (a *UniswapV3ApiService) UniswapV3GetTokensDayDataCurrentExecute(r ApiUniswapV3GetTokensDayDataCurrentRequest) ([]UniswapV3TokenV3DayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TokenV3DayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTokensDayDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/tokensDayData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTokenId != nil {
		localVarQueryParams.Add("filter_token_id", parameterToString(*r.filterTokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTokensDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiUniswapV3GetTokensDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetTokensDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetTokensDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetTokensDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetTokensDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetTokensDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetTokensDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetTokensDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetTokensDayDataHistoricalRequest) TokenId(tokenId string) ApiUniswapV3GetTokensDayDataHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiUniswapV3GetTokensDayDataHistoricalRequest) Execute() ([]UniswapV3TokenV3DayDataDTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTokensDayDataHistoricalExecute(r)
}

/*
UniswapV3GetTokensDayDataHistorical TokensDayData (historical)

Gets tokens day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTokensDayDataHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTokensDayDataHistorical(ctx context.Context) ApiUniswapV3GetTokensDayDataHistoricalRequest {
	return ApiUniswapV3GetTokensDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TokenV3DayDataDTO
func (a *UniswapV3ApiService) UniswapV3GetTokensDayDataHistoricalExecute(r ApiUniswapV3GetTokensDayDataHistoricalRequest) ([]UniswapV3TokenV3DayDataDTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TokenV3DayDataDTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTokensDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/tokensDayData/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiUniswapV3GetTokensHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetTokensHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetTokensHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetTokensHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetTokensHistoricalRequest) TokenId(tokenId string) ApiUniswapV3GetTokensHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiUniswapV3GetTokensHistoricalRequest) Execute() ([]UniswapV3TokenV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTokensHistoricalExecute(r)
}

/*
UniswapV3GetTokensHistorical Tokens (historical) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTokensHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTokensHistorical(ctx context.Context) ApiUniswapV3GetTokensHistoricalRequest {
	return ApiUniswapV3GetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TokenV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTokensHistoricalExecute(r ApiUniswapV3GetTokensHistoricalRequest) ([]UniswapV3TokenV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TokenV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/tokens/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTokensHourDataCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	filterTokenId *string
}

func (r ApiUniswapV3GetTokensHourDataCurrentRequest) FilterTokenId(filterTokenId string) ApiUniswapV3GetTokensHourDataCurrentRequest {
	r.filterTokenId = &filterTokenId
	return r
}

func (r ApiUniswapV3GetTokensHourDataCurrentRequest) Execute() ([]UniswapV3TokenHourDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTokensHourDataCurrentExecute(r)
}

/*
UniswapV3GetTokensHourDataCurrent TokensHourData (current)

Gets tokens hour data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTokensHourDataCurrentRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTokensHourDataCurrent(ctx context.Context) ApiUniswapV3GetTokensHourDataCurrentRequest {
	return ApiUniswapV3GetTokensHourDataCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TokenHourDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTokensHourDataCurrentExecute(r ApiUniswapV3GetTokensHourDataCurrentRequest) ([]UniswapV3TokenHourDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TokenHourDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTokensHourDataCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/tokensHourData/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterTokenId != nil {
		localVarQueryParams.Add("filter_token_id", parameterToString(*r.filterTokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTokensHourDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiUniswapV3GetTokensHourDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetTokensHourDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetTokensHourDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetTokensHourDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetTokensHourDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetTokensHourDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetTokensHourDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetTokensHourDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV3GetTokensHourDataHistoricalRequest) TokenId(tokenId string) ApiUniswapV3GetTokensHourDataHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiUniswapV3GetTokensHourDataHistoricalRequest) Execute() ([]UniswapV3TokenHourDataV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTokensHourDataHistoricalExecute(r)
}

/*
UniswapV3GetTokensHourDataHistorical TokensHourData (historical)

Gets tokens hour data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTokensHourDataHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTokensHourDataHistorical(ctx context.Context) ApiUniswapV3GetTokensHourDataHistoricalRequest {
	return ApiUniswapV3GetTokensHourDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TokenHourDataV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTokensHourDataHistoricalExecute(r ApiUniswapV3GetTokensHourDataHistoricalRequest) ([]UniswapV3TokenHourDataV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TokenHourDataV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTokensHourDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/tokensHourData/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV3GetTransactionsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV3ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV3GetTransactionsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV3GetTransactionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV3GetTransactionsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV3GetTransactionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV3GetTransactionsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV3GetTransactionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV3GetTransactionsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV3GetTransactionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV3GetTransactionsHistoricalRequest) Execute() ([]UniswapV3TransactionV3DTO, *http.Response, error) {
	return r.ApiService.UniswapV3GetTransactionsHistoricalExecute(r)
}

/*
UniswapV3GetTransactionsHistorical Transactions (historical)

Gets transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV3GetTransactionsHistoricalRequest
*/
func (a *UniswapV3ApiService) UniswapV3GetTransactionsHistorical(ctx context.Context) ApiUniswapV3GetTransactionsHistoricalRequest {
	return ApiUniswapV3GetTransactionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV3TransactionV3DTO
func (a *UniswapV3ApiService) UniswapV3GetTransactionsHistoricalExecute(r ApiUniswapV3GetTransactionsHistoricalRequest) ([]UniswapV3TransactionV3DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV3TransactionV3DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV3ApiService.UniswapV3GetTransactionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv3/transactions/historical-manual"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
