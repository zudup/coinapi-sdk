/*
OnChain API

 This section will provide necessary information about the `OnChain API` protocol.  <br/><br/> Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.                             

API version: v1
Contact: support@coinapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"time"
)


// UniswapV2ApiService UniswapV2Api service
type UniswapV2ApiService service

type ApiUniswapV2GetBundlesHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV2GetBundlesHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetBundlesHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetBundlesHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetBundlesHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetBundlesHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetBundlesHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetBundlesHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetBundlesHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV2GetBundlesHistoricalRequest) Execute() ([]UniswapV2BundleV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetBundlesHistoricalExecute(r)
}

/*
UniswapV2GetBundlesHistorical GetBundles (historical)

Gets bundles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetBundlesHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetBundlesHistorical(ctx context.Context) ApiUniswapV2GetBundlesHistoricalRequest {
	return ApiUniswapV2GetBundlesHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2BundleV2DTO
func (a *UniswapV2ApiService) UniswapV2GetBundlesHistoricalExecute(r ApiUniswapV2GetBundlesHistoricalRequest) ([]UniswapV2BundleV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2BundleV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetBundlesHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/bundles/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetBurnsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetBurnsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetBurnsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetBurnsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetBurnsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetBurnsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetBurnsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetBurnsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetBurnsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetBurnsHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetBurnsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetBurnsHistoricalRequest) Execute() ([]UniswapV2BurnV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetBurnsHistoricalExecute(r)
}

/*
UniswapV2GetBurnsHistorical GetBurns (historical)

Gets burns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetBurnsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetBurnsHistorical(ctx context.Context) ApiUniswapV2GetBurnsHistoricalRequest {
	return ApiUniswapV2GetBurnsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2BurnV2DTO
func (a *UniswapV2ApiService) UniswapV2GetBurnsHistoricalExecute(r ApiUniswapV2GetBurnsHistoricalRequest) ([]UniswapV2BurnV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2BurnV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetBurnsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/burns/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV2GetDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV2GetDayDataHistoricalRequest) Execute() ([]UniswapV2UniswapDayDataV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetDayDataHistoricalExecute(r)
}

/*
UniswapV2GetDayDataHistorical GetDayData (historical)

Gets uniswapv2 day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetDayDataHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetDayDataHistorical(ctx context.Context) ApiUniswapV2GetDayDataHistoricalRequest {
	return ApiUniswapV2GetDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2UniswapDayDataV2DTO
func (a *UniswapV2ApiService) UniswapV2GetDayDataHistoricalExecute(r ApiUniswapV2GetDayDataHistoricalRequest) ([]UniswapV2UniswapDayDataV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2UniswapDayDataV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/dayData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetFactoryHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV2GetFactoryHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetFactoryHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetFactoryHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetFactoryHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetFactoryHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetFactoryHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetFactoryHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetFactoryHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV2GetFactoryHistoricalRequest) Execute() ([]UniswapV2UniswapFactoryV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetFactoryHistoricalExecute(r)
}

/*
UniswapV2GetFactoryHistorical GetFactory (historical)

Gets factory.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetFactoryHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetFactoryHistorical(ctx context.Context) ApiUniswapV2GetFactoryHistoricalRequest {
	return ApiUniswapV2GetFactoryHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2UniswapFactoryV2DTO
func (a *UniswapV2ApiService) UniswapV2GetFactoryHistoricalExecute(r ApiUniswapV2GetFactoryHistoricalRequest) ([]UniswapV2UniswapFactoryV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2UniswapFactoryV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetFactoryHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/factory/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetLiquidityPositionsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetLiquidityPositionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetLiquidityPositionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetLiquidityPositionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetLiquidityPositionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetLiquidityPositionsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) Execute() ([]UniswapV2LiquidityPositionV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetLiquidityPositionsHistoricalExecute(r)
}

/*
UniswapV2GetLiquidityPositionsHistorical GetLiquidityPositions (historical)

Gets liquidity positions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetLiquidityPositionsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetLiquidityPositionsHistorical(ctx context.Context) ApiUniswapV2GetLiquidityPositionsHistoricalRequest {
	return ApiUniswapV2GetLiquidityPositionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2LiquidityPositionV2DTO
func (a *UniswapV2ApiService) UniswapV2GetLiquidityPositionsHistoricalExecute(r ApiUniswapV2GetLiquidityPositionsHistoricalRequest) ([]UniswapV2LiquidityPositionV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2LiquidityPositionV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetLiquidityPositionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/liquidityPositions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) Execute() ([]UniswapV2LiquidityPositionSnapshotV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetLiquidityPositionsSnapshotsHistoricalExecute(r)
}

/*
UniswapV2GetLiquidityPositionsSnapshotsHistorical GetLiquidityPositionsSnapshots (historical)

Gets liquidity positions snapshots.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetLiquidityPositionsSnapshotsHistorical(ctx context.Context) ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest {
	return ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2LiquidityPositionSnapshotV2DTO
func (a *UniswapV2ApiService) UniswapV2GetLiquidityPositionsSnapshotsHistoricalExecute(r ApiUniswapV2GetLiquidityPositionsSnapshotsHistoricalRequest) ([]UniswapV2LiquidityPositionSnapshotV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2LiquidityPositionSnapshotV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetLiquidityPositionsSnapshotsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/liquidityPositionsSnapshots/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetMintsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetMintsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetMintsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetMintsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetMintsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetMintsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetMintsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetMintsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetMintsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetMintsHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetMintsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetMintsHistoricalRequest) Execute() ([]UniswapV2MintV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetMintsHistoricalExecute(r)
}

/*
UniswapV2GetMintsHistorical GetMints (historical)

Gets mints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetMintsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetMintsHistorical(ctx context.Context) ApiUniswapV2GetMintsHistoricalRequest {
	return ApiUniswapV2GetMintsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2MintV2DTO
func (a *UniswapV2ApiService) UniswapV2GetMintsHistoricalExecute(r ApiUniswapV2GetMintsHistoricalRequest) ([]UniswapV2MintV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2MintV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetMintsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/mints/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetPoolsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	filterPoolId *string
}

func (r ApiUniswapV2GetPoolsCurrentRequest) FilterPoolId(filterPoolId string) ApiUniswapV2GetPoolsCurrentRequest {
	r.filterPoolId = &filterPoolId
	return r
}

func (r ApiUniswapV2GetPoolsCurrentRequest) Execute() ([]UniswapV2PairV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetPoolsCurrentExecute(r)
}

/*
UniswapV2GetPoolsCurrent GetPools (current) ðŸ”¥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetPoolsCurrentRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetPoolsCurrent(ctx context.Context) ApiUniswapV2GetPoolsCurrentRequest {
	return ApiUniswapV2GetPoolsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2PairV2DTO
func (a *UniswapV2ApiService) UniswapV2GetPoolsCurrentExecute(r ApiUniswapV2GetPoolsCurrentRequest) ([]UniswapV2PairV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2PairV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetPoolsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/pools/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filterPoolId != nil {
		localVarQueryParams.Add("filter_pool_id", parameterToString(*r.filterPoolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetPoolsDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetPoolsDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetPoolsDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetPoolsDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetPoolsDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetPoolsDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetPoolsDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetPoolsDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetPoolsDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetPoolsDayDataHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetPoolsDayDataHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetPoolsDayDataHistoricalRequest) Execute() ([]UniswapV2PairDayDataV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetPoolsDayDataHistoricalExecute(r)
}

/*
UniswapV2GetPoolsDayDataHistorical GetPoolsDayData (historical)

Gets pools day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetPoolsDayDataHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetPoolsDayDataHistorical(ctx context.Context) ApiUniswapV2GetPoolsDayDataHistoricalRequest {
	return ApiUniswapV2GetPoolsDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2PairDayDataV2DTO
func (a *UniswapV2ApiService) UniswapV2GetPoolsDayDataHistoricalExecute(r ApiUniswapV2GetPoolsDayDataHistoricalRequest) ([]UniswapV2PairDayDataV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2PairDayDataV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetPoolsDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/poolsDayData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetPoolsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetPoolsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetPoolsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetPoolsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetPoolsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetPoolsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetPoolsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetPoolsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetPoolsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetPoolsHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetPoolsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetPoolsHistoricalRequest) Execute() ([]UniswapV2PairV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetPoolsHistoricalExecute(r)
}

/*
UniswapV2GetPoolsHistorical GetPools (historical) ðŸ”¥

Gets pools.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetPoolsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetPoolsHistorical(ctx context.Context) ApiUniswapV2GetPoolsHistoricalRequest {
	return ApiUniswapV2GetPoolsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2PairV2DTO
func (a *UniswapV2ApiService) UniswapV2GetPoolsHistoricalExecute(r ApiUniswapV2GetPoolsHistoricalRequest) ([]UniswapV2PairV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2PairV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetPoolsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/pools/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetPoolsHourDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetPoolsHourDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetPoolsHourDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetPoolsHourDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetPoolsHourDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetPoolsHourDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetPoolsHourDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetPoolsHourDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetPoolsHourDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetPoolsHourDataHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetPoolsHourDataHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetPoolsHourDataHistoricalRequest) Execute() ([]UniswapV2PairHourDataV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetPoolsHourDataHistoricalExecute(r)
}

/*
UniswapV2GetPoolsHourDataHistorical GetPoolsHourData (historical)

Gets pools tracked each our.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetPoolsHourDataHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetPoolsHourDataHistorical(ctx context.Context) ApiUniswapV2GetPoolsHourDataHistoricalRequest {
	return ApiUniswapV2GetPoolsHourDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2PairHourDataV2DTO
func (a *UniswapV2ApiService) UniswapV2GetPoolsHourDataHistoricalExecute(r ApiUniswapV2GetPoolsHourDataHistoricalRequest) ([]UniswapV2PairHourDataV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2PairHourDataV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetPoolsHourDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/poolsHourData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetSwapsCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
}

func (r ApiUniswapV2GetSwapsCurrentRequest) Execute() ([]UniswapV2SwapV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetSwapsCurrentExecute(r)
}

/*
UniswapV2GetSwapsCurrent GetSwaps (current) ðŸ”¥

Gets swaps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetSwapsCurrentRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetSwapsCurrent(ctx context.Context) ApiUniswapV2GetSwapsCurrentRequest {
	return ApiUniswapV2GetSwapsCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2SwapV2DTO
func (a *UniswapV2ApiService) UniswapV2GetSwapsCurrentExecute(r ApiUniswapV2GetSwapsCurrentRequest) ([]UniswapV2SwapV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2SwapV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetSwapsCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/swaps/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetSwapsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	poolId *string
}

// 
func (r ApiUniswapV2GetSwapsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetSwapsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetSwapsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetSwapsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetSwapsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetSwapsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetSwapsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetSwapsHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetSwapsHistoricalRequest) PoolId(poolId string) ApiUniswapV2GetSwapsHistoricalRequest {
	r.poolId = &poolId
	return r
}

func (r ApiUniswapV2GetSwapsHistoricalRequest) Execute() ([]UniswapV2SwapV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetSwapsHistoricalExecute(r)
}

/*
UniswapV2GetSwapsHistorical GetSwaps (historical) ðŸ”¥

Gets swaps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetSwapsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetSwapsHistorical(ctx context.Context) ApiUniswapV2GetSwapsHistoricalRequest {
	return ApiUniswapV2GetSwapsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2SwapV2DTO
func (a *UniswapV2ApiService) UniswapV2GetSwapsHistoricalExecute(r ApiUniswapV2GetSwapsHistoricalRequest) ([]UniswapV2SwapV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2SwapV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetSwapsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/swaps/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetTokensCurrentRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
}

func (r ApiUniswapV2GetTokensCurrentRequest) Execute() ([]UniswapV2TokenV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetTokensCurrentExecute(r)
}

/*
UniswapV2GetTokensCurrent GetTokens (current) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetTokensCurrentRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetTokensCurrent(ctx context.Context) ApiUniswapV2GetTokensCurrentRequest {
	return ApiUniswapV2GetTokensCurrentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2TokenV2DTO
func (a *UniswapV2ApiService) UniswapV2GetTokensCurrentExecute(r ApiUniswapV2GetTokensCurrentRequest) ([]UniswapV2TokenV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2TokenV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetTokensCurrent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/tokens/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetTokensDayDataHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiUniswapV2GetTokensDayDataHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetTokensDayDataHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetTokensDayDataHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetTokensDayDataHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetTokensDayDataHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetTokensDayDataHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetTokensDayDataHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetTokensDayDataHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetTokensDayDataHistoricalRequest) TokenId(tokenId string) ApiUniswapV2GetTokensDayDataHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiUniswapV2GetTokensDayDataHistoricalRequest) Execute() ([]UniswapV2TokenDayDataV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetTokensDayDataHistoricalExecute(r)
}

/*
UniswapV2GetTokensDayDataHistorical GetTokensDayData (historical)

Gets tokens day data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetTokensDayDataHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetTokensDayDataHistorical(ctx context.Context) ApiUniswapV2GetTokensDayDataHistoricalRequest {
	return ApiUniswapV2GetTokensDayDataHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2TokenDayDataV2DTO
func (a *UniswapV2ApiService) UniswapV2GetTokensDayDataHistoricalExecute(r ApiUniswapV2GetTokensDayDataHistoricalRequest) ([]UniswapV2TokenDayDataV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2TokenDayDataV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetTokensDayDataHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/tokensDayData/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetTokensHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
	tokenId *string
}

// 
func (r ApiUniswapV2GetTokensHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetTokensHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetTokensHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetTokensHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetTokensHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetTokensHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetTokensHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetTokensHistoricalRequest {
	r.endDate = &endDate
	return r
}

// 
func (r ApiUniswapV2GetTokensHistoricalRequest) TokenId(tokenId string) ApiUniswapV2GetTokensHistoricalRequest {
	r.tokenId = &tokenId
	return r
}

func (r ApiUniswapV2GetTokensHistoricalRequest) Execute() ([]UniswapV2TokenV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetTokensHistoricalExecute(r)
}

/*
UniswapV2GetTokensHistorical GetTokens (historical) ðŸ”¥

Gets tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetTokensHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetTokensHistorical(ctx context.Context) ApiUniswapV2GetTokensHistoricalRequest {
	return ApiUniswapV2GetTokensHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2TokenV2DTO
func (a *UniswapV2ApiService) UniswapV2GetTokensHistoricalExecute(r ApiUniswapV2GetTokensHistoricalRequest) ([]UniswapV2TokenV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2TokenV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetTokensHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/tokens/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.tokenId != nil {
		localVarQueryParams.Add("tokenId", parameterToString(*r.tokenId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetTransactionsHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV2GetTransactionsHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetTransactionsHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetTransactionsHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetTransactionsHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetTransactionsHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetTransactionsHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetTransactionsHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetTransactionsHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV2GetTransactionsHistoricalRequest) Execute() ([]UniswapV2TransactionV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetTransactionsHistoricalExecute(r)
}

/*
UniswapV2GetTransactionsHistorical GetTransactions (historical)

Gets transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetTransactionsHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetTransactionsHistorical(ctx context.Context) ApiUniswapV2GetTransactionsHistoricalRequest {
	return ApiUniswapV2GetTransactionsHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2TransactionV2DTO
func (a *UniswapV2ApiService) UniswapV2GetTransactionsHistoricalExecute(r ApiUniswapV2GetTransactionsHistoricalRequest) ([]UniswapV2TransactionV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2TransactionV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetTransactionsHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/transactions/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUniswapV2GetUsersHistoricalRequest struct {
	ctx context.Context
	ApiService *UniswapV2ApiService
	startBlock *int64
	endBlock *int64
	startDate *time.Time
	endDate *time.Time
}

// 
func (r ApiUniswapV2GetUsersHistoricalRequest) StartBlock(startBlock int64) ApiUniswapV2GetUsersHistoricalRequest {
	r.startBlock = &startBlock
	return r
}

// 
func (r ApiUniswapV2GetUsersHistoricalRequest) EndBlock(endBlock int64) ApiUniswapV2GetUsersHistoricalRequest {
	r.endBlock = &endBlock
	return r
}

// 
func (r ApiUniswapV2GetUsersHistoricalRequest) StartDate(startDate time.Time) ApiUniswapV2GetUsersHistoricalRequest {
	r.startDate = &startDate
	return r
}

// 
func (r ApiUniswapV2GetUsersHistoricalRequest) EndDate(endDate time.Time) ApiUniswapV2GetUsersHistoricalRequest {
	r.endDate = &endDate
	return r
}

func (r ApiUniswapV2GetUsersHistoricalRequest) Execute() ([]UniswapV2UserV2DTO, *http.Response, error) {
	return r.ApiService.UniswapV2GetUsersHistoricalExecute(r)
}

/*
UniswapV2GetUsersHistorical GetUsers (historical)

Gets users.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUniswapV2GetUsersHistoricalRequest
*/
func (a *UniswapV2ApiService) UniswapV2GetUsersHistorical(ctx context.Context) ApiUniswapV2GetUsersHistoricalRequest {
	return ApiUniswapV2GetUsersHistoricalRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UniswapV2UserV2DTO
func (a *UniswapV2ApiService) UniswapV2GetUsersHistoricalExecute(r ApiUniswapV2GetUsersHistoricalRequest) ([]UniswapV2UserV2DTO, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UniswapV2UserV2DTO
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UniswapV2ApiService.UniswapV2GetUsersHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dapps/uniswapv2/users/historical"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startBlock != nil {
		localVarQueryParams.Add("startBlock", parameterToString(*r.startBlock, ""))
	}
	if r.endBlock != nil {
		localVarQueryParams.Add("endBlock", parameterToString(*r.endBlock, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
