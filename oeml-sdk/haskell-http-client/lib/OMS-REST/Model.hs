{-
   OMS - REST API

   OMS Project

   OpenAPI Version: 3.0.0
   OMS - REST API API version: v1
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OMS-REST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OMS-REST.Model where

import OMS-REST.Core
import OMS-REST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Balance
-- | Balance
data Balance = Balance
  { balanceType :: !(Maybe Text) -- ^ "type" - Result type.
  , balanceExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Exchange name.
  , balanceData :: !(Maybe [BalanceData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Balance
instance A.FromJSON Balance where
  parseJSON = A.withObject "Balance" $ \o ->
    Balance
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Balance
instance A.ToJSON Balance where
  toJSON Balance {..} =
   _omitNulls
      [ "type" .= balanceType
      , "exchange_name" .= balanceExchangeName
      , "data" .= balanceData
      ]


-- | Construct a value of type 'Balance' (by applying it's required fields, if any)
mkBalance
  :: Balance
mkBalance =
  Balance
  { balanceType = Nothing
  , balanceExchangeName = Nothing
  , balanceData = Nothing
  }

-- ** BalanceData
-- | BalanceData
data BalanceData = BalanceData
  { balanceDataId :: !(Maybe Text) -- ^ "id" - symbol_exchange
  , balanceDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - Currency code.
  , balanceDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - CoinAPI currency code.
  , balanceDataBalance :: !(Maybe Float) -- ^ "balance" - The current balance.
  , balanceDataAvailable :: !(Maybe Float) -- ^ "available" - The amount that is available to trade.
  , balanceDataLocked :: !(Maybe Float) -- ^ "locked" - Blocked funds.
  , balanceDataUpdateOrigin :: !(Maybe E'UpdateOrigin) -- ^ "update_origin" - Source of last modification. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceData
instance A.FromJSON BalanceData where
  parseJSON = A.withObject "BalanceData" $ \o ->
    BalanceData
      <$> (o .:? "id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "balance")
      <*> (o .:? "available")
      <*> (o .:? "locked")
      <*> (o .:? "update_origin")

-- | ToJSON BalanceData
instance A.ToJSON BalanceData where
  toJSON BalanceData {..} =
   _omitNulls
      [ "id" .= balanceDataId
      , "symbol_exchange" .= balanceDataSymbolExchange
      , "symbol_coinapi" .= balanceDataSymbolCoinapi
      , "balance" .= balanceDataBalance
      , "available" .= balanceDataAvailable
      , "locked" .= balanceDataLocked
      , "update_origin" .= balanceDataUpdateOrigin
      ]


-- | Construct a value of type 'BalanceData' (by applying it's required fields, if any)
mkBalanceData
  :: BalanceData
mkBalanceData =
  BalanceData
  { balanceDataId = Nothing
  , balanceDataSymbolExchange = Nothing
  , balanceDataSymbolCoinapi = Nothing
  , balanceDataBalance = Nothing
  , balanceDataAvailable = Nothing
  , balanceDataLocked = Nothing
  , balanceDataUpdateOrigin = Nothing
  }

-- ** CancelAllOrder
-- | CancelAllOrder
data CancelAllOrder = CancelAllOrder
  { cancelAllOrderExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CancelAllOrder
instance A.FromJSON CancelAllOrder where
  parseJSON = A.withObject "CancelAllOrder" $ \o ->
    CancelAllOrder
      <$> (o .:? "exchange_id")

-- | ToJSON CancelAllOrder
instance A.ToJSON CancelAllOrder where
  toJSON CancelAllOrder {..} =
   _omitNulls
      [ "exchange_id" .= cancelAllOrderExchangeId
      ]


-- | Construct a value of type 'CancelAllOrder' (by applying it's required fields, if any)
mkCancelAllOrder
  :: CancelAllOrder
mkCancelAllOrder =
  CancelAllOrder
  { cancelAllOrderExchangeId = Nothing
  }

-- ** CancelOrder
-- | CancelOrder
data CancelOrder = CancelOrder
  { cancelOrderExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , cancelOrderExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Order Id
  , cancelOrderClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - Client order Id
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CancelOrder
instance A.FromJSON CancelOrder where
  parseJSON = A.withObject "CancelOrder" $ \o ->
    CancelOrder
      <$> (o .:? "exchange_id")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "client_order_id")

-- | ToJSON CancelOrder
instance A.ToJSON CancelOrder where
  toJSON CancelOrder {..} =
   _omitNulls
      [ "exchange_id" .= cancelOrderExchangeId
      , "exchange_order_id" .= cancelOrderExchangeOrderId
      , "client_order_id" .= cancelOrderClientOrderId
      ]


-- | Construct a value of type 'CancelOrder' (by applying it's required fields, if any)
mkCancelOrder
  :: CancelOrder
mkCancelOrder =
  CancelOrder
  { cancelOrderExchangeId = Nothing
  , cancelOrderExchangeOrderId = Nothing
  , cancelOrderClientOrderId = Nothing
  }

-- ** CreateOrder400
-- | CreateOrder400
-- Create order validation error (response)
-- 
data CreateOrder400 = CreateOrder400
  { createOrder400Type :: !(Maybe Text) -- ^ "type"
  , createOrder400Title :: !(Maybe Text) -- ^ "title"
  , createOrder400Status :: !(Maybe Double) -- ^ "status"
  , createOrder400TraceId :: !(Maybe Text) -- ^ "traceId"
  , createOrder400Errors :: !(Maybe Text) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOrder400
instance A.FromJSON CreateOrder400 where
  parseJSON = A.withObject "CreateOrder400" $ \o ->
    CreateOrder400
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "traceId")
      <*> (o .:? "errors")

-- | ToJSON CreateOrder400
instance A.ToJSON CreateOrder400 where
  toJSON CreateOrder400 {..} =
   _omitNulls
      [ "type" .= createOrder400Type
      , "title" .= createOrder400Title
      , "status" .= createOrder400Status
      , "traceId" .= createOrder400TraceId
      , "errors" .= createOrder400Errors
      ]


-- | Construct a value of type 'CreateOrder400' (by applying it's required fields, if any)
mkCreateOrder400
  :: CreateOrder400
mkCreateOrder400 =
  CreateOrder400
  { createOrder400Type = Nothing
  , createOrder400Title = Nothing
  , createOrder400Status = Nothing
  , createOrder400TraceId = Nothing
  , createOrder400Errors = Nothing
  }

-- ** Messages
-- | Messages
-- Message
-- 
data Messages = Messages
  { messagesType :: !(Maybe Text) -- ^ "type" - Type of message
  , messagesExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , messagesMessage :: !(Maybe Text) -- ^ "message" - Message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Messages
instance A.FromJSON Messages where
  parseJSON = A.withObject "Messages" $ \o ->
    Messages
      <$> (o .:? "type")
      <*> (o .:? "exchange_id")
      <*> (o .:? "message")

-- | ToJSON Messages
instance A.ToJSON Messages where
  toJSON Messages {..} =
   _omitNulls
      [ "type" .= messagesType
      , "exchange_id" .= messagesExchangeId
      , "message" .= messagesMessage
      ]


-- | Construct a value of type 'Messages' (by applying it's required fields, if any)
mkMessages
  :: Messages
mkMessages =
  Messages
  { messagesType = Nothing
  , messagesExchangeId = Nothing
  , messagesMessage = Nothing
  }

-- ** MessagesInfo
-- | MessagesInfo
-- Message info
-- 
data MessagesInfo = MessagesInfo
  { messagesInfoType :: !(Maybe Text) -- ^ "type" - Type of message
  , messagesInfoExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , messagesInfoErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessagesInfo
instance A.FromJSON MessagesInfo where
  parseJSON = A.withObject "MessagesInfo" $ \o ->
    MessagesInfo
      <$> (o .:? "type")
      <*> (o .:? "exchange_id")
      <*> (o .:? "error_message")

-- | ToJSON MessagesInfo
instance A.ToJSON MessagesInfo where
  toJSON MessagesInfo {..} =
   _omitNulls
      [ "type" .= messagesInfoType
      , "exchange_id" .= messagesInfoExchangeId
      , "error_message" .= messagesInfoErrorMessage
      ]


-- | Construct a value of type 'MessagesInfo' (by applying it's required fields, if any)
mkMessagesInfo
  :: MessagesInfo
mkMessagesInfo =
  MessagesInfo
  { messagesInfoType = Nothing
  , messagesInfoExchangeId = Nothing
  , messagesInfoErrorMessage = Nothing
  }

-- ** MessagesOk
-- | MessagesOk
-- Message ok
-- 
data MessagesOk = MessagesOk
  { messagesOkType :: !(Maybe Text) -- ^ "type" - Type of message
  , messagesOkExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , messagesOkMessage :: !(Maybe Text) -- ^ "message" - Message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessagesOk
instance A.FromJSON MessagesOk where
  parseJSON = A.withObject "MessagesOk" $ \o ->
    MessagesOk
      <$> (o .:? "type")
      <*> (o .:? "exchange_id")
      <*> (o .:? "message")

-- | ToJSON MessagesOk
instance A.ToJSON MessagesOk where
  toJSON MessagesOk {..} =
   _omitNulls
      [ "type" .= messagesOkType
      , "exchange_id" .= messagesOkExchangeId
      , "message" .= messagesOkMessage
      ]


-- | Construct a value of type 'MessagesOk' (by applying it's required fields, if any)
mkMessagesOk
  :: MessagesOk
mkMessagesOk =
  MessagesOk
  { messagesOkType = Nothing
  , messagesOkExchangeId = Nothing
  , messagesOkMessage = Nothing
  }

-- ** NewOrder
-- | NewOrder
data NewOrder = NewOrder
  { newOrderExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , newOrderClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - Client unique identifier for the trade.
  , newOrderSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - The symbol of the order.
  , newOrderSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - The CoinAPI symbol of the order.
  , newOrderAmountOrder :: !(Maybe Double) -- ^ "amount_order" - Quoted decimal amount to purchase.
  , newOrderPrice :: !(Maybe Double) -- ^ "price" - Quoted decimal amount to spend per unit.
  , newOrderSide :: !(Maybe E'Side) -- ^ "side" - Buy or Sell
  , newOrderOrderType :: !(Maybe E'OrderType) -- ^ "order_type" - The order type.
  , newOrderTimeInForce :: !(Maybe TimeInForce) -- ^ "time_in_force"
  , newOrderExpireTime :: !(Maybe Date) -- ^ "expire_time" - Required for orders with time_in_force &#x3D; GOOD_TILL_TIME_EXCHANGE, GOOD_TILL_TIME_OMS
  , newOrderExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - TODO: description exec inst  | Parameter | Description | |-----------|--------| | &#x60;MAKER_OR_CANCEL&#x60; | Rests on the continuous order book at a specified price. If any quantity can be filled immediately, the entire order is canceled. | ##### Exec inst options  | Exchange | MAKER_OR_CANCEL | | --- | --- | | BINANCE | X | | BITFINEX | X | | BITMEX | X | | BLOCKCHAINEXCHANGE | X | | BITSTAMP |  | | COINBASE | X | | GEMINI | X | | KRAKEN | X | | POLONIEX | X | | HITBTC |  | | KRAKENFTS | X | 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NewOrder
instance A.FromJSON NewOrder where
  parseJSON = A.withObject "NewOrder" $ \o ->
    NewOrder
      <$> (o .:? "exchange_id")
      <*> (o .:? "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "amount_order")
      <*> (o .:? "price")
      <*> (o .:? "side")
      <*> (o .:? "order_type")
      <*> (o .:? "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON NewOrder
instance A.ToJSON NewOrder where
  toJSON NewOrder {..} =
   _omitNulls
      [ "exchange_id" .= newOrderExchangeId
      , "client_order_id" .= newOrderClientOrderId
      , "symbol_exchange" .= newOrderSymbolExchange
      , "symbol_coinapi" .= newOrderSymbolCoinapi
      , "amount_order" .= newOrderAmountOrder
      , "price" .= newOrderPrice
      , "side" .= newOrderSide
      , "order_type" .= newOrderOrderType
      , "time_in_force" .= newOrderTimeInForce
      , "expire_time" .= newOrderExpireTime
      , "exec_inst" .= newOrderExecInst
      ]


-- | Construct a value of type 'NewOrder' (by applying it's required fields, if any)
mkNewOrder
  :: NewOrder
mkNewOrder =
  NewOrder
  { newOrderExchangeId = Nothing
  , newOrderClientOrderId = Nothing
  , newOrderSymbolExchange = Nothing
  , newOrderSymbolCoinapi = Nothing
  , newOrderAmountOrder = Nothing
  , newOrderPrice = Nothing
  , newOrderSide = Nothing
  , newOrderOrderType = Nothing
  , newOrderTimeInForce = Nothing
  , newOrderExpireTime = Nothing
  , newOrderExecInst = Nothing
  }

-- ** Order
-- | Order
data Order = Order
  { orderType :: !(Maybe Text) -- ^ "type" - null
  , orderExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Exchange name
  , orderData :: !(Maybe [OrderData]) -- ^ "data" - Orders array
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Order
instance A.FromJSON Order where
  parseJSON = A.withObject "Order" $ \o ->
    Order
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Order
instance A.ToJSON Order where
  toJSON Order {..} =
   _omitNulls
      [ "type" .= orderType
      , "exchange_name" .= orderExchangeName
      , "data" .= orderData
      ]


-- | Construct a value of type 'Order' (by applying it's required fields, if any)
mkOrder
  :: Order
mkOrder =
  Order
  { orderType = Nothing
  , orderExchangeName = Nothing
  , orderData = Nothing
  }

-- ** OrderData
-- | OrderData
data OrderData = OrderData
  { orderDataExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , orderDataId :: !(Maybe Text) -- ^ "id" - Client unique identifier for the trade.
  , orderDataClientOrderIdFormatExchange :: !(Maybe Text) -- ^ "client_order_id_format_exchange" - Hash client id
  , orderDataExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Exchange order id
  , orderDataAmountOpen :: !(Maybe Double) -- ^ "amount_open" - Amount open
  , orderDataAmountFilled :: !(Maybe Double) -- ^ "amount_filled" - Amount filled
  , orderDataStatus :: !(Maybe OrderStatus) -- ^ "status"
  , orderDataTimeOrder :: !(Maybe [[Text]]) -- ^ "time_order" - History of order status changes
  , orderDataErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  , orderDataClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - Client unique identifier for the trade.
  , orderDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - The symbol of the order.
  , orderDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - The CoinAPI symbol of the order.
  , orderDataAmountOrder :: !(Maybe Double) -- ^ "amount_order" - Quoted decimal amount to purchase.
  , orderDataPrice :: !(Maybe Double) -- ^ "price" - Quoted decimal amount to spend per unit.
  , orderDataSide :: !(Maybe E'Side) -- ^ "side" - Buy or Sell
  , orderDataOrderType :: !(Maybe E'OrderType) -- ^ "order_type" - The order type.
  , orderDataTimeInForce :: !(Maybe TimeInForce) -- ^ "time_in_force"
  , orderDataExpireTime :: !(Maybe Date) -- ^ "expire_time" - Required for orders with time_in_force &#x3D; GOOD_TILL_TIME_EXCHANGE, GOOD_TILL_TIME_OMS
  , orderDataExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - TODO: description exec inst  | Parameter | Description | |-----------|--------| | &#x60;MAKER_OR_CANCEL&#x60; | Rests on the continuous order book at a specified price. If any quantity can be filled immediately, the entire order is canceled. | ##### Exec inst options  | Exchange | MAKER_OR_CANCEL | | --- | --- | | BINANCE | X | | BITFINEX | X | | BITMEX | X | | BLOCKCHAINEXCHANGE | X | | BITSTAMP |  | | COINBASE | X | | GEMINI | X | | KRAKEN | X | | POLONIEX | X | | HITBTC |  | | KRAKENFTS | X | 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderData
instance A.FromJSON OrderData where
  parseJSON = A.withObject "OrderData" $ \o ->
    OrderData
      <$> (o .:? "exchange_id")
      <*> (o .:? "id")
      <*> (o .:? "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "amount_open")
      <*> (o .:? "amount_filled")
      <*> (o .:? "status")
      <*> (o .:? "time_order")
      <*> (o .:? "error_message")
      <*> (o .:? "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "amount_order")
      <*> (o .:? "price")
      <*> (o .:? "side")
      <*> (o .:? "order_type")
      <*> (o .:? "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON OrderData
instance A.ToJSON OrderData where
  toJSON OrderData {..} =
   _omitNulls
      [ "exchange_id" .= orderDataExchangeId
      , "id" .= orderDataId
      , "client_order_id_format_exchange" .= orderDataClientOrderIdFormatExchange
      , "exchange_order_id" .= orderDataExchangeOrderId
      , "amount_open" .= orderDataAmountOpen
      , "amount_filled" .= orderDataAmountFilled
      , "status" .= orderDataStatus
      , "time_order" .= orderDataTimeOrder
      , "error_message" .= orderDataErrorMessage
      , "client_order_id" .= orderDataClientOrderId
      , "symbol_exchange" .= orderDataSymbolExchange
      , "symbol_coinapi" .= orderDataSymbolCoinapi
      , "amount_order" .= orderDataAmountOrder
      , "price" .= orderDataPrice
      , "side" .= orderDataSide
      , "order_type" .= orderDataOrderType
      , "time_in_force" .= orderDataTimeInForce
      , "expire_time" .= orderDataExpireTime
      , "exec_inst" .= orderDataExecInst
      ]


-- | Construct a value of type 'OrderData' (by applying it's required fields, if any)
mkOrderData
  :: OrderData
mkOrderData =
  OrderData
  { orderDataExchangeId = Nothing
  , orderDataId = Nothing
  , orderDataClientOrderIdFormatExchange = Nothing
  , orderDataExchangeOrderId = Nothing
  , orderDataAmountOpen = Nothing
  , orderDataAmountFilled = Nothing
  , orderDataStatus = Nothing
  , orderDataTimeOrder = Nothing
  , orderDataErrorMessage = Nothing
  , orderDataClientOrderId = Nothing
  , orderDataSymbolExchange = Nothing
  , orderDataSymbolCoinapi = Nothing
  , orderDataAmountOrder = Nothing
  , orderDataPrice = Nothing
  , orderDataSide = Nothing
  , orderDataOrderType = Nothing
  , orderDataTimeInForce = Nothing
  , orderDataExpireTime = Nothing
  , orderDataExecInst = Nothing
  }

-- ** OrderLive
-- | OrderLive
data OrderLive = OrderLive
  { orderLiveType :: !(Maybe Text) -- ^ "type" - Result type name
  , orderLiveExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange name
  , orderLiveId :: !(Maybe Text) -- ^ "id" - Client unique identifier for the trade.
  , orderLiveClientOrderIdFormatExchange :: !(Maybe Text) -- ^ "client_order_id_format_exchange" - Hash client id
  , orderLiveExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Exchange order id
  , orderLiveAmountOpen :: !(Maybe Double) -- ^ "amount_open" - Amount open
  , orderLiveAmountFilled :: !(Maybe Double) -- ^ "amount_filled" - Amount filled
  , orderLiveStatus :: !(Maybe OrderStatus) -- ^ "status"
  , orderLiveTimeOrder :: !(Maybe [[Text]]) -- ^ "time_order" - History of order status changes
  , orderLiveErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  , orderLiveClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - Client unique identifier for the trade.
  , orderLiveSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - The symbol of the order.
  , orderLiveSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - The CoinAPI symbol of the order.
  , orderLiveAmountOrder :: !(Maybe Double) -- ^ "amount_order" - Quoted decimal amount to purchase.
  , orderLivePrice :: !(Maybe Double) -- ^ "price" - Quoted decimal amount to spend per unit.
  , orderLiveSide :: !(Maybe E'Side) -- ^ "side" - Buy or Sell
  , orderLiveOrderType :: !(Maybe E'OrderType) -- ^ "order_type" - The order type.
  , orderLiveTimeInForce :: !(Maybe TimeInForce) -- ^ "time_in_force"
  , orderLiveExpireTime :: !(Maybe Date) -- ^ "expire_time" - Required for orders with time_in_force &#x3D; GOOD_TILL_TIME_EXCHANGE, GOOD_TILL_TIME_OMS
  , orderLiveExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - TODO: description exec inst  | Parameter | Description | |-----------|--------| | &#x60;MAKER_OR_CANCEL&#x60; | Rests on the continuous order book at a specified price. If any quantity can be filled immediately, the entire order is canceled. | ##### Exec inst options  | Exchange | MAKER_OR_CANCEL | | --- | --- | | BINANCE | X | | BITFINEX | X | | BITMEX | X | | BLOCKCHAINEXCHANGE | X | | BITSTAMP |  | | COINBASE | X | | GEMINI | X | | KRAKEN | X | | POLONIEX | X | | HITBTC |  | | KRAKENFTS | X | 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderLive
instance A.FromJSON OrderLive where
  parseJSON = A.withObject "OrderLive" $ \o ->
    OrderLive
      <$> (o .:? "type")
      <*> (o .:? "exchange_id")
      <*> (o .:? "id")
      <*> (o .:? "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "amount_open")
      <*> (o .:? "amount_filled")
      <*> (o .:? "status")
      <*> (o .:? "time_order")
      <*> (o .:? "error_message")
      <*> (o .:? "client_order_id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "amount_order")
      <*> (o .:? "price")
      <*> (o .:? "side")
      <*> (o .:? "order_type")
      <*> (o .:? "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON OrderLive
instance A.ToJSON OrderLive where
  toJSON OrderLive {..} =
   _omitNulls
      [ "type" .= orderLiveType
      , "exchange_id" .= orderLiveExchangeId
      , "id" .= orderLiveId
      , "client_order_id_format_exchange" .= orderLiveClientOrderIdFormatExchange
      , "exchange_order_id" .= orderLiveExchangeOrderId
      , "amount_open" .= orderLiveAmountOpen
      , "amount_filled" .= orderLiveAmountFilled
      , "status" .= orderLiveStatus
      , "time_order" .= orderLiveTimeOrder
      , "error_message" .= orderLiveErrorMessage
      , "client_order_id" .= orderLiveClientOrderId
      , "symbol_exchange" .= orderLiveSymbolExchange
      , "symbol_coinapi" .= orderLiveSymbolCoinapi
      , "amount_order" .= orderLiveAmountOrder
      , "price" .= orderLivePrice
      , "side" .= orderLiveSide
      , "order_type" .= orderLiveOrderType
      , "time_in_force" .= orderLiveTimeInForce
      , "expire_time" .= orderLiveExpireTime
      , "exec_inst" .= orderLiveExecInst
      ]


-- | Construct a value of type 'OrderLive' (by applying it's required fields, if any)
mkOrderLive
  :: OrderLive
mkOrderLive =
  OrderLive
  { orderLiveType = Nothing
  , orderLiveExchangeId = Nothing
  , orderLiveId = Nothing
  , orderLiveClientOrderIdFormatExchange = Nothing
  , orderLiveExchangeOrderId = Nothing
  , orderLiveAmountOpen = Nothing
  , orderLiveAmountFilled = Nothing
  , orderLiveStatus = Nothing
  , orderLiveTimeOrder = Nothing
  , orderLiveErrorMessage = Nothing
  , orderLiveClientOrderId = Nothing
  , orderLiveSymbolExchange = Nothing
  , orderLiveSymbolCoinapi = Nothing
  , orderLiveAmountOrder = Nothing
  , orderLivePrice = Nothing
  , orderLiveSide = Nothing
  , orderLiveOrderType = Nothing
  , orderLiveTimeInForce = Nothing
  , orderLiveExpireTime = Nothing
  , orderLiveExecInst = Nothing
  }

-- ** Position
-- | Position
data Position = Position
  { positionType :: !(Maybe Text) -- ^ "type" - Result type.
  , positionExchangeName :: !(Maybe Text) -- ^ "exchange_name" - Name of exchange.
  , positionData :: !(Maybe [PositionData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Position
instance A.FromJSON Position where
  parseJSON = A.withObject "Position" $ \o ->
    Position
      <$> (o .:? "type")
      <*> (o .:? "exchange_name")
      <*> (o .:? "data")

-- | ToJSON Position
instance A.ToJSON Position where
  toJSON Position {..} =
   _omitNulls
      [ "type" .= positionType
      , "exchange_name" .= positionExchangeName
      , "data" .= positionData
      ]


-- | Construct a value of type 'Position' (by applying it's required fields, if any)
mkPosition
  :: Position
mkPosition =
  Position
  { positionType = Nothing
  , positionExchangeName = Nothing
  , positionData = Nothing
  }

-- ** PositionData
-- | PositionData
data PositionData = PositionData
  { positionDataId :: !(Maybe Text) -- ^ "id" - Unique position ID
  , positionDataSymbolExchange :: !(Maybe Text) -- ^ "symbol_exchange" - The contract for this position.
  , positionDataSymbolCoinapi :: !(Maybe Text) -- ^ "symbol_coinapi" - The coinapi contract for this position.
  , positionDataAvgEntryPrice :: !(Maybe Double) -- ^ "avg_entry_price"
  , positionDataQuantity :: !(Maybe Double) -- ^ "quantity" - The current position amount in contracts.
  , positionDataIsBuy :: !(Maybe Bool) -- ^ "is_buy"
  , positionDataUnrealisedPnL :: !(Maybe Double) -- ^ "unrealised_pn_l" - Unrealised PNL is all the unrealised profit or loss coming from your portfolio&#39;s open positions.
  , positionDataLeverage :: !(Maybe Double) -- ^ "leverage" - 1 / initMarginReq.
  , positionDataCrossMargin :: !(Maybe Bool) -- ^ "cross_margin" - True/false depending on whether you set cross margin on this position.
  , positionDataLiquidationPrice :: !(Maybe Double) -- ^ "liquidation_price" - Once markPrice reaches this price, this position will be liquidated.
  , positionDataRawData :: !(Maybe Text) -- ^ "raw_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionData
instance A.FromJSON PositionData where
  parseJSON = A.withObject "PositionData" $ \o ->
    PositionData
      <$> (o .:? "id")
      <*> (o .:? "symbol_exchange")
      <*> (o .:? "symbol_coinapi")
      <*> (o .:? "avg_entry_price")
      <*> (o .:? "quantity")
      <*> (o .:? "is_buy")
      <*> (o .:? "unrealised_pn_l")
      <*> (o .:? "leverage")
      <*> (o .:? "cross_margin")
      <*> (o .:? "liquidation_price")
      <*> (o .:? "raw_data")

-- | ToJSON PositionData
instance A.ToJSON PositionData where
  toJSON PositionData {..} =
   _omitNulls
      [ "id" .= positionDataId
      , "symbol_exchange" .= positionDataSymbolExchange
      , "symbol_coinapi" .= positionDataSymbolCoinapi
      , "avg_entry_price" .= positionDataAvgEntryPrice
      , "quantity" .= positionDataQuantity
      , "is_buy" .= positionDataIsBuy
      , "unrealised_pn_l" .= positionDataUnrealisedPnL
      , "leverage" .= positionDataLeverage
      , "cross_margin" .= positionDataCrossMargin
      , "liquidation_price" .= positionDataLiquidationPrice
      , "raw_data" .= positionDataRawData
      ]


-- | Construct a value of type 'PositionData' (by applying it's required fields, if any)
mkPositionData
  :: PositionData
mkPositionData =
  PositionData
  { positionDataId = Nothing
  , positionDataSymbolExchange = Nothing
  , positionDataSymbolCoinapi = Nothing
  , positionDataAvgEntryPrice = Nothing
  , positionDataQuantity = Nothing
  , positionDataIsBuy = Nothing
  , positionDataUnrealisedPnL = Nothing
  , positionDataLeverage = Nothing
  , positionDataCrossMargin = Nothing
  , positionDataLiquidationPrice = Nothing
  , positionDataRawData = Nothing
  }


-- * Enums


-- ** E'ExecInst

-- | Enum of 'Text'
data E'ExecInst
  = E'ExecInst'MAKER_OR_CANCEL -- ^ @"MAKER_OR_CANCEL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ExecInst where toJSON = A.toJSON . fromE'ExecInst
instance A.FromJSON E'ExecInst where parseJSON o = P.either P.fail (pure . P.id) . toE'ExecInst =<< A.parseJSON o
instance WH.ToHttpApiData E'ExecInst where toQueryParam = WH.toQueryParam . fromE'ExecInst
instance WH.FromHttpApiData E'ExecInst where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ExecInst
instance MimeRender MimeMultipartFormData E'ExecInst where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ExecInst' enum
fromE'ExecInst :: E'ExecInst -> Text
fromE'ExecInst = \case
  E'ExecInst'MAKER_OR_CANCEL -> "MAKER_OR_CANCEL"

-- | parse 'E'ExecInst' enum
toE'ExecInst :: Text -> P.Either String E'ExecInst
toE'ExecInst = \case
  "MAKER_OR_CANCEL" -> P.Right E'ExecInst'MAKER_OR_CANCEL
  s -> P.Left $ "toE'ExecInst: enum parse failure: " P.++ P.show s


-- ** E'OrderType

-- | Enum of 'Text' . 
-- The order type.
data E'OrderType
  = E'OrderType'LIMIT -- ^ @"LIMIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OrderType where toJSON = A.toJSON . fromE'OrderType
instance A.FromJSON E'OrderType where parseJSON o = P.either P.fail (pure . P.id) . toE'OrderType =<< A.parseJSON o
instance WH.ToHttpApiData E'OrderType where toQueryParam = WH.toQueryParam . fromE'OrderType
instance WH.FromHttpApiData E'OrderType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OrderType
instance MimeRender MimeMultipartFormData E'OrderType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OrderType' enum
fromE'OrderType :: E'OrderType -> Text
fromE'OrderType = \case
  E'OrderType'LIMIT -> "LIMIT"

-- | parse 'E'OrderType' enum
toE'OrderType :: Text -> P.Either String E'OrderType
toE'OrderType = \case
  "LIMIT" -> P.Right E'OrderType'LIMIT
  s -> P.Left $ "toE'OrderType: enum parse failure: " P.++ P.show s


-- ** E'Side

-- | Enum of 'Text' . 
-- Buy or Sell
data E'Side
  = E'Side'BUY -- ^ @"BUY"@
  | E'Side'SELL -- ^ @"SELL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Side where toJSON = A.toJSON . fromE'Side
instance A.FromJSON E'Side where parseJSON o = P.either P.fail (pure . P.id) . toE'Side =<< A.parseJSON o
instance WH.ToHttpApiData E'Side where toQueryParam = WH.toQueryParam . fromE'Side
instance WH.FromHttpApiData E'Side where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Side
instance MimeRender MimeMultipartFormData E'Side where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Side' enum
fromE'Side :: E'Side -> Text
fromE'Side = \case
  E'Side'BUY -> "BUY"
  E'Side'SELL -> "SELL"

-- | parse 'E'Side' enum
toE'Side :: Text -> P.Either String E'Side
toE'Side = \case
  "BUY" -> P.Right E'Side'BUY
  "SELL" -> P.Right E'Side'SELL
  s -> P.Left $ "toE'Side: enum parse failure: " P.++ P.show s


-- ** E'UpdateOrigin

-- | Enum of 'Text' . 
-- Source of last modification. 
data E'UpdateOrigin
  = E'UpdateOrigin'INITIALIZATION -- ^ @"INITIALIZATION"@
  | E'UpdateOrigin'BALANCE_MANAGER -- ^ @"BALANCE_MANAGER"@
  | E'UpdateOrigin'EXCHANGE -- ^ @"EXCHANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'UpdateOrigin where toJSON = A.toJSON . fromE'UpdateOrigin
instance A.FromJSON E'UpdateOrigin where parseJSON o = P.either P.fail (pure . P.id) . toE'UpdateOrigin =<< A.parseJSON o
instance WH.ToHttpApiData E'UpdateOrigin where toQueryParam = WH.toQueryParam . fromE'UpdateOrigin
instance WH.FromHttpApiData E'UpdateOrigin where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'UpdateOrigin
instance MimeRender MimeMultipartFormData E'UpdateOrigin where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'UpdateOrigin' enum
fromE'UpdateOrigin :: E'UpdateOrigin -> Text
fromE'UpdateOrigin = \case
  E'UpdateOrigin'INITIALIZATION -> "INITIALIZATION"
  E'UpdateOrigin'BALANCE_MANAGER -> "BALANCE_MANAGER"
  E'UpdateOrigin'EXCHANGE -> "EXCHANGE"

-- | parse 'E'UpdateOrigin' enum
toE'UpdateOrigin :: Text -> P.Either String E'UpdateOrigin
toE'UpdateOrigin = \case
  "INITIALIZATION" -> P.Right E'UpdateOrigin'INITIALIZATION
  "BALANCE_MANAGER" -> P.Right E'UpdateOrigin'BALANCE_MANAGER
  "EXCHANGE" -> P.Right E'UpdateOrigin'EXCHANGE
  s -> P.Left $ "toE'UpdateOrigin: enum parse failure: " P.++ P.show s


-- ** OrderStatus

-- | Enum of 'Text' . 
-- Order statuses ##### Status description  | Name | Possible transitions to | Status description  | --- | --- | --- | | RECEIVED | REJECTED, ROUTING | We received an order and will send it to the exchange immedaitely | ROUTING | ROUTED | We are in the process of sending order to the exchange | ROUTED | REJECTED, NEW, PARTIALLY_FILLED, FILLED, CANCELED | Order was sent to the exchange from our side, but it's not yet active in order book | NEW | PARTIALLY_FILLED, FILLED, PENDING_CANCEL, CANCELED | Order is active in the order book and it's untouched | PENDING_CANCEL | NEW, PARTIALLY_FILLED, FILLED, CANCELED | We received order cancel request and relayed it succesfully to the exchange.  | PARTIALLY_FILLED | FILLED, PENDING_CANCEL, CANCELED | Order is active in the order book and it's partially filled | FILLED | | Order is no longer active in the order book as was completely filled  | CANCELED | | Order is no longer active in the order book as was canceled | REJECTED | | Order was rejected by OMS or exchange. ##### Status transitions  | Source Status | Destination status | Description | --- | --- | --- | | | RECEIVED | OMS received new order from you | | NEW | OMS received unseen new order from the exchange (order was relayed to the exchnage outside the OMS) | | PARTIALLY_FILLED | OMS received unseen partially filled order from the exchange (order was relayed to the exchnage outside the OMS) | RECEIVED | REJECTED | OMS rejected your order | RECEIVED | ROUTING | We started relaying order to the exchange | ROUTING | ROUTED | Order was relayed to the exchange and we are waiting to be active in the order book | ROUTED | REJECTED | Exchange rejected your order | ROUTED | NEW | Exchange accepted your passive order into order book | ROUTED | PARTIALLY_FILLED | Exchange actively filled part of your order and the remaining was accepted into order book | ROUTED | FILLED | Exchange actively filled your order in whole. | ROUTED | CANCELED | Exchange canceled your order before accepting it to the order book. | NEW | PARTIALLY_FILLED | Part of your order was filled. | NEW | FILLED | Whole order was filled. | NEW | PENDING_CANCEL | We received cancel request and successfully relayed it to the exchange. | NEW | CANCELED | Your order was canceled. | PARTIALLY_FILLED | FILLED | Remaining active part of the order was filled succesfully. | PARTIALLY_FILLED | PENDING_CANCEL | We received cancel request and successfully relayed it to the exchange. | PARTIALLY_FILLED | CANCELED | Your order was canceled. | PENDING_CANCEL | NEW | Exchange responded to the cancelation message that your order is fully active in the order book. | PENDING_CANCEL | PARTIALLY_FILLED | Your order was filled partially after we relayed cancelation message to the exchange. | PENDING_CANCEL | FILLED | Your order was completely filled before the cancel was executed by the exchange. | PENDING_CANCEL | CANCELED | Your order was canceled. 
data OrderStatus
  = OrderStatus'RECEIVED -- ^ @"RECEIVED"@
  | OrderStatus'ROUTING -- ^ @"ROUTING"@
  | OrderStatus'ROUTED -- ^ @"ROUTED"@
  | OrderStatus'NEW -- ^ @"NEW"@
  | OrderStatus'PENDING_CANCEL -- ^ @"PENDING_CANCEL"@
  | OrderStatus'PARTIALLY_FILLED -- ^ @"PARTIALLY_FILLED"@
  | OrderStatus'FILLED -- ^ @"FILLED"@
  | OrderStatus'CANCELED -- ^ @"CANCELED"@
  | OrderStatus'REJECTED -- ^ @"REJECTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrderStatus where toJSON = A.toJSON . fromOrderStatus
instance A.FromJSON OrderStatus where parseJSON o = P.either P.fail (pure . P.id) . toOrderStatus =<< A.parseJSON o
instance WH.ToHttpApiData OrderStatus where toQueryParam = WH.toQueryParam . fromOrderStatus
instance WH.FromHttpApiData OrderStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrderStatus
instance MimeRender MimeMultipartFormData OrderStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrderStatus' enum
fromOrderStatus :: OrderStatus -> Text
fromOrderStatus = \case
  OrderStatus'RECEIVED -> "RECEIVED"
  OrderStatus'ROUTING -> "ROUTING"
  OrderStatus'ROUTED -> "ROUTED"
  OrderStatus'NEW -> "NEW"
  OrderStatus'PENDING_CANCEL -> "PENDING_CANCEL"
  OrderStatus'PARTIALLY_FILLED -> "PARTIALLY_FILLED"
  OrderStatus'FILLED -> "FILLED"
  OrderStatus'CANCELED -> "CANCELED"
  OrderStatus'REJECTED -> "REJECTED"

-- | parse 'OrderStatus' enum
toOrderStatus :: Text -> P.Either String OrderStatus
toOrderStatus = \case
  "RECEIVED" -> P.Right OrderStatus'RECEIVED
  "ROUTING" -> P.Right OrderStatus'ROUTING
  "ROUTED" -> P.Right OrderStatus'ROUTED
  "NEW" -> P.Right OrderStatus'NEW
  "PENDING_CANCEL" -> P.Right OrderStatus'PENDING_CANCEL
  "PARTIALLY_FILLED" -> P.Right OrderStatus'PARTIALLY_FILLED
  "FILLED" -> P.Right OrderStatus'FILLED
  "CANCELED" -> P.Right OrderStatus'CANCELED
  "REJECTED" -> P.Right OrderStatus'REJECTED
  s -> P.Left $ "toOrderStatus: enum parse failure: " P.++ P.show s


-- ** TimeInForce

-- | Enum of 'Text' . 
-- Time in force is a special instruction used when placing a trade to indicate how long an order will remain active before it is executed or expires. These options are especially important for active traders and allow them to be more specific about the time parameters.  | Parameter | Description | |-----------|--------| | `GOOD_TILL_CANCEL` | A Good-Til-Cancelled (GTC) order is an order to buy or sell a stock that lasts until the order is completed or canceled. Brokerage firms typically limit the length of time an investor can leave a GTC order open.  This time frame may vary from broker to broker.  Investors should contact their brokerage firms to determine what time limit would apply to GTC orders. | | `GOOD_TILL_TIME_EXCHANGE` | The GTTE (Good-til-Date/Time) time in force lets you select an expiration date and time up until which an order will continue to work. Setting this attribute requires both a time in force selection of GTD, a date entry in the Expiration Date field, and a time entry in the Expiration Time field if that level of detail is required. Note that if you only enter a good-till date, the unfilled order will cancel at the close of the market on the specified day. | | `GOOD_TILL_TIME_OMS` | The GTT (GTTO) supported by OMS. | | `FILL_OR_KILL` | Fill or kill (FOK) is a type of time-in-force designation used in securities trading that instructs a brokerage to execute a transaction immediately and completely or not at all. This type of order is most often used by active traders and is usually for a large quantity of stock. The order must be filled in its entirety or canceled (killed). | | `IMMEDIATE_OR_CANCEL` | An immediate or cancel order (IOC) is an order to buy or sell a security that executes all or part immediately and cancels any unfilled portion of the order. An IOC order is one of several \"duration orders\" that investors can use to specify how long the order remains active in the market and under what conditions the order is canceled. Other commonly used duration order types include fill or kill (FOK), all or none (AON) and good ‘till canceled (GTC). Most online trading platforms allow IOC orders to be placed manually or programmed into automated trading strategies. | | `AUCTION_ONLY` | This order will be added to the auction-only (AO) book for the next auction for this symbol. | | `INDICATION_OF_INTEREST` | An indication of interest (IOI) is an underwriting expression showing a conditional, non-binding interest in buying a security that is currently in registration—awaiting approval by the Securities and Exchange Commission (SEC). The investor's broker is required to provide the investor with a preliminary prospectus. However, IOIs in the mergers and acquisitions world has similar intent but is done differently. |  ##### Time in force options  | Exchange | GTC | GTTE | GTTO | FOK | IOC | AO | IOI | | --- | --- | --- | ---- | --- | --- | --- | --- | | BINANCE | X | X |  | X | X |  |  | | BITFINEX | X | X |  | X | X |  |  | | BITMEX | X | X |  |  | X |  |  | | BLOCKCHAINEXCHANGE | X | X |  |  | X |  |  | | BITSTAMP | X | X |  |  | X |  |  | | COINBASE | X |  | X | X | X |  |  | | GEMINI | X | X |  | X | X | X | X | | KRAKEN | X |  | X |  |  |  |  | | POLONIEX | X | X |  | X | X |  |  | | HITBTC | X | X |  | X | X |  |  | | KRAKENFTS | X | X |  |  | X |  |  | 
data TimeInForce
  = TimeInForce'GOOD_TILL_CANCEL -- ^ @"GOOD_TILL_CANCEL"@
  | TimeInForce'GOOD_TILL_TIME_EXCHANGE -- ^ @"GOOD_TILL_TIME_EXCHANGE"@
  | TimeInForce'GOOD_TILL_TIME_OMS -- ^ @"GOOD_TILL_TIME_OMS"@
  | TimeInForce'FILL_OR_KILL -- ^ @"FILL_OR_KILL"@
  | TimeInForce'IMMEDIATE_OR_CANCEL -- ^ @"IMMEDIATE_OR_CANCEL"@
  | TimeInForce'AUCTION_ONLY -- ^ @"AUCTION_ONLY"@
  | TimeInForce'INDICATION_OF_INTEREST -- ^ @"INDICATION_OF_INTEREST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForce where toJSON = A.toJSON . fromTimeInForce
instance A.FromJSON TimeInForce where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForce =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForce where toQueryParam = WH.toQueryParam . fromTimeInForce
instance WH.FromHttpApiData TimeInForce where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForce
instance MimeRender MimeMultipartFormData TimeInForce where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForce' enum
fromTimeInForce :: TimeInForce -> Text
fromTimeInForce = \case
  TimeInForce'GOOD_TILL_CANCEL -> "GOOD_TILL_CANCEL"
  TimeInForce'GOOD_TILL_TIME_EXCHANGE -> "GOOD_TILL_TIME_EXCHANGE"
  TimeInForce'GOOD_TILL_TIME_OMS -> "GOOD_TILL_TIME_OMS"
  TimeInForce'FILL_OR_KILL -> "FILL_OR_KILL"
  TimeInForce'IMMEDIATE_OR_CANCEL -> "IMMEDIATE_OR_CANCEL"
  TimeInForce'AUCTION_ONLY -> "AUCTION_ONLY"
  TimeInForce'INDICATION_OF_INTEREST -> "INDICATION_OF_INTEREST"

-- | parse 'TimeInForce' enum
toTimeInForce :: Text -> P.Either String TimeInForce
toTimeInForce = \case
  "GOOD_TILL_CANCEL" -> P.Right TimeInForce'GOOD_TILL_CANCEL
  "GOOD_TILL_TIME_EXCHANGE" -> P.Right TimeInForce'GOOD_TILL_TIME_EXCHANGE
  "GOOD_TILL_TIME_OMS" -> P.Right TimeInForce'GOOD_TILL_TIME_OMS
  "FILL_OR_KILL" -> P.Right TimeInForce'FILL_OR_KILL
  "IMMEDIATE_OR_CANCEL" -> P.Right TimeInForce'IMMEDIATE_OR_CANCEL
  "AUCTION_ONLY" -> P.Right TimeInForce'AUCTION_ONLY
  "INDICATION_OF_INTEREST" -> P.Right TimeInForce'INDICATION_OF_INTEREST
  s -> P.Left $ "toTimeInForce: enum parse failure: " P.++ P.show s



