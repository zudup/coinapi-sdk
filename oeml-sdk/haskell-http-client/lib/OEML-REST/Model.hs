{-
   OEML - REST API

   This section will provide necessary information about the `CoinAPI OEML REST API` protocol. This API is also available in the Postman application: <a href=\"https://postman.coinapi.io/\" target=\"_blank\">https://postman.coinapi.io/</a>       

   OpenAPI Version: 3.0.0
   OEML - REST API API version: v1
   Contact: support@coinapi.io
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OEML-REST.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OEML-REST.Model where

import OEML-REST.Core
import OEML-REST.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** ClientOrderId
newtype ClientOrderId = ClientOrderId { unClientOrderId :: Text } deriving (P.Eq, P.Show)

-- ** ExchangeId
newtype ExchangeId = ExchangeId { unExchangeId :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Balance
-- | Balance
data Balance = Balance
  { balanceExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier used to identify the routing destination.
  , balanceData :: !(Maybe [BalanceData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Balance
instance A.FromJSON Balance where
  parseJSON = A.withObject "Balance" $ \o ->
    Balance
      <$> (o .:? "exchange_id")
      <*> (o .:? "data")

-- | ToJSON Balance
instance A.ToJSON Balance where
  toJSON Balance {..} =
   _omitNulls
      [ "exchange_id" .= balanceExchangeId
      , "data" .= balanceData
      ]


-- | Construct a value of type 'Balance' (by applying it's required fields, if any)
mkBalance
  :: Balance
mkBalance =
  Balance
  { balanceExchangeId = Nothing
  , balanceData = Nothing
  }

-- ** BalanceData
-- | BalanceData
data BalanceData = BalanceData
  { balanceDataAssetIdExchange :: !(Maybe Text) -- ^ "asset_id_exchange" - Exchange currency code.
  , balanceDataAssetIdCoinapi :: !(Maybe Text) -- ^ "asset_id_coinapi" - CoinAPI currency code.
  , balanceDataBalance :: !(Maybe Float) -- ^ "balance" - Value of the current total currency balance on the exchange.
  , balanceDataAvailable :: !(Maybe Float) -- ^ "available" - Value of the current available currency balance on the exchange that can be used as collateral.
  , balanceDataLocked :: !(Maybe Float) -- ^ "locked" - Value of the current locked currency balance by the exchange.
  , balanceDataLastUpdatedBy :: !(Maybe E'LastUpdatedBy) -- ^ "last_updated_by" - Source of the last modification. 
  , balanceDataRateUsd :: !(Maybe Float) -- ^ "rate_usd" - Current exchange rate to the USD for the single unit of the currency. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON BalanceData
instance A.FromJSON BalanceData where
  parseJSON = A.withObject "BalanceData" $ \o ->
    BalanceData
      <$> (o .:? "asset_id_exchange")
      <*> (o .:? "asset_id_coinapi")
      <*> (o .:? "balance")
      <*> (o .:? "available")
      <*> (o .:? "locked")
      <*> (o .:? "last_updated_by")
      <*> (o .:? "rate_usd")

-- | ToJSON BalanceData
instance A.ToJSON BalanceData where
  toJSON BalanceData {..} =
   _omitNulls
      [ "asset_id_exchange" .= balanceDataAssetIdExchange
      , "asset_id_coinapi" .= balanceDataAssetIdCoinapi
      , "balance" .= balanceDataBalance
      , "available" .= balanceDataAvailable
      , "locked" .= balanceDataLocked
      , "last_updated_by" .= balanceDataLastUpdatedBy
      , "rate_usd" .= balanceDataRateUsd
      ]


-- | Construct a value of type 'BalanceData' (by applying it's required fields, if any)
mkBalanceData
  :: BalanceData
mkBalanceData =
  BalanceData
  { balanceDataAssetIdExchange = Nothing
  , balanceDataAssetIdCoinapi = Nothing
  , balanceDataBalance = Nothing
  , balanceDataAvailable = Nothing
  , balanceDataLocked = Nothing
  , balanceDataLastUpdatedBy = Nothing
  , balanceDataRateUsd = Nothing
  }

-- ** Message
-- | Message
-- Message object.
-- 
data Message = Message
  { messageType :: !(Maybe Text) -- ^ "type" - Type of message.
  , messageSeverity :: !(Maybe Severity) -- ^ "severity"
  , messageExchangeId :: !(Maybe Text) -- ^ "exchange_id" - If the message related to exchange, then the identifier of the exchange will be provided.
  , messageMessage :: !(Maybe Text) -- ^ "message" - Message text.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Message
instance A.FromJSON Message where
  parseJSON = A.withObject "Message" $ \o ->
    Message
      <$> (o .:? "type")
      <*> (o .:? "severity")
      <*> (o .:? "exchange_id")
      <*> (o .:? "message")

-- | ToJSON Message
instance A.ToJSON Message where
  toJSON Message {..} =
   _omitNulls
      [ "type" .= messageType
      , "severity" .= messageSeverity
      , "exchange_id" .= messageExchangeId
      , "message" .= messageMessage
      ]


-- | Construct a value of type 'Message' (by applying it's required fields, if any)
mkMessage
  :: Message
mkMessage =
  Message
  { messageType = Nothing
  , messageSeverity = Nothing
  , messageExchangeId = Nothing
  , messageMessage = Nothing
  }

-- ** OrderCancelAllRequest
-- | OrderCancelAllRequest
-- Cancel all orders request object.
data OrderCancelAllRequest = OrderCancelAllRequest
  { orderCancelAllRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Identifier of the exchange from which active orders should be canceled.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCancelAllRequest
instance A.FromJSON OrderCancelAllRequest where
  parseJSON = A.withObject "OrderCancelAllRequest" $ \o ->
    OrderCancelAllRequest
      <$> (o .:  "exchange_id")

-- | ToJSON OrderCancelAllRequest
instance A.ToJSON OrderCancelAllRequest where
  toJSON OrderCancelAllRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderCancelAllRequestExchangeId
      ]


-- | Construct a value of type 'OrderCancelAllRequest' (by applying it's required fields, if any)
mkOrderCancelAllRequest
  :: Text -- ^ 'orderCancelAllRequestExchangeId': Identifier of the exchange from which active orders should be canceled.
  -> OrderCancelAllRequest
mkOrderCancelAllRequest orderCancelAllRequestExchangeId =
  OrderCancelAllRequest
  { orderCancelAllRequestExchangeId
  }

-- ** OrderCancelSingleRequest
-- | OrderCancelSingleRequest
-- Cancel single order request object.
data OrderCancelSingleRequest = OrderCancelSingleRequest
  { orderCancelSingleRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier used to identify the routing destination.
  , orderCancelSingleRequestExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Unique identifier of the order assigned by the exchange or executing system. One of the properties (&#x60;exchange_order_id&#x60;, &#x60;client_order_id&#x60;) is required to identify the new order.
  , orderCancelSingleRequestClientOrderId :: !(Maybe Text) -- ^ "client_order_id" - The unique identifier of the order assigned by the client. One of the properties (&#x60;exchange_order_id&#x60;, &#x60;client_order_id&#x60;) is required to identify the new order.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderCancelSingleRequest
instance A.FromJSON OrderCancelSingleRequest where
  parseJSON = A.withObject "OrderCancelSingleRequest" $ \o ->
    OrderCancelSingleRequest
      <$> (o .:  "exchange_id")
      <*> (o .:? "exchange_order_id")
      <*> (o .:? "client_order_id")

-- | ToJSON OrderCancelSingleRequest
instance A.ToJSON OrderCancelSingleRequest where
  toJSON OrderCancelSingleRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderCancelSingleRequestExchangeId
      , "exchange_order_id" .= orderCancelSingleRequestExchangeOrderId
      , "client_order_id" .= orderCancelSingleRequestClientOrderId
      ]


-- | Construct a value of type 'OrderCancelSingleRequest' (by applying it's required fields, if any)
mkOrderCancelSingleRequest
  :: Text -- ^ 'orderCancelSingleRequestExchangeId': Exchange identifier used to identify the routing destination.
  -> OrderCancelSingleRequest
mkOrderCancelSingleRequest orderCancelSingleRequestExchangeId =
  OrderCancelSingleRequest
  { orderCancelSingleRequestExchangeId
  , orderCancelSingleRequestExchangeOrderId = Nothing
  , orderCancelSingleRequestClientOrderId = Nothing
  }

-- ** OrderExecutionReport
-- | OrderExecutionReport
-- The order execution report object.
data OrderExecutionReport = OrderExecutionReport
  { orderExecutionReportExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier used to identify the routing destination.
  , orderExecutionReportClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - The unique identifier of the order assigned by the client.
  , orderExecutionReportSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - Exchange symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderExecutionReportSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderExecutionReportAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , orderExecutionReportPrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , orderExecutionReportSide :: !(OrdSide) -- ^ /Required/ "side"
  , orderExecutionReportOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , orderExecutionReportTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , orderExecutionReportExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , orderExecutionReportExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#oeml-order-params-exec\&quot;&gt;OEML / Starter Guide / Order parameters / Execution instructions&lt;/a&gt; 
  , orderExecutionReportClientOrderIdFormatExchange :: !(Text) -- ^ /Required/ "client_order_id_format_exchange" - The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  , orderExecutionReportExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Unique identifier of the order assigned by the exchange or executing system.
  , orderExecutionReportAmountOpen :: !(Double) -- ^ /Required/ "amount_open" - Quantity open for further execution. &#x60;amount_open&#x60; &#x3D; &#x60;amount_order&#x60; - &#x60;amount_filled&#x60;
  , orderExecutionReportAmountFilled :: !(Double) -- ^ /Required/ "amount_filled" - Total quantity filled.
  , orderExecutionReportStatus :: !(OrdStatus) -- ^ /Required/ "status"
  , orderExecutionReportTimeOrder :: !([[Text]]) -- ^ /Required/ "time_order" - Timestamped history of order status changes.
  , orderExecutionReportErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderExecutionReport
instance A.FromJSON OrderExecutionReport where
  parseJSON = A.withObject "OrderExecutionReport" $ \o ->
    OrderExecutionReport
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")
      <*> (o .:  "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:  "amount_open")
      <*> (o .:  "amount_filled")
      <*> (o .:  "status")
      <*> (o .:  "time_order")
      <*> (o .:? "error_message")

-- | ToJSON OrderExecutionReport
instance A.ToJSON OrderExecutionReport where
  toJSON OrderExecutionReport {..} =
   _omitNulls
      [ "exchange_id" .= orderExecutionReportExchangeId
      , "client_order_id" .= orderExecutionReportClientOrderId
      , "symbol_id_exchange" .= orderExecutionReportSymbolIdExchange
      , "symbol_id_coinapi" .= orderExecutionReportSymbolIdCoinapi
      , "amount_order" .= orderExecutionReportAmountOrder
      , "price" .= orderExecutionReportPrice
      , "side" .= orderExecutionReportSide
      , "order_type" .= orderExecutionReportOrderType
      , "time_in_force" .= orderExecutionReportTimeInForce
      , "expire_time" .= orderExecutionReportExpireTime
      , "exec_inst" .= orderExecutionReportExecInst
      , "client_order_id_format_exchange" .= orderExecutionReportClientOrderIdFormatExchange
      , "exchange_order_id" .= orderExecutionReportExchangeOrderId
      , "amount_open" .= orderExecutionReportAmountOpen
      , "amount_filled" .= orderExecutionReportAmountFilled
      , "status" .= orderExecutionReportStatus
      , "time_order" .= orderExecutionReportTimeOrder
      , "error_message" .= orderExecutionReportErrorMessage
      ]


-- | Construct a value of type 'OrderExecutionReport' (by applying it's required fields, if any)
mkOrderExecutionReport
  :: Text -- ^ 'orderExecutionReportExchangeId': Exchange identifier used to identify the routing destination.
  -> Text -- ^ 'orderExecutionReportClientOrderId': The unique identifier of the order assigned by the client.
  -> Double -- ^ 'orderExecutionReportAmountOrder': Order quantity.
  -> Double -- ^ 'orderExecutionReportPrice': Order price.
  -> OrdSide -- ^ 'orderExecutionReportSide' 
  -> OrdType -- ^ 'orderExecutionReportOrderType' 
  -> TimeInForce -- ^ 'orderExecutionReportTimeInForce' 
  -> Text -- ^ 'orderExecutionReportClientOrderIdFormatExchange': The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  -> Double -- ^ 'orderExecutionReportAmountOpen': Quantity open for further execution. `amount_open` = `amount_order` - `amount_filled`
  -> Double -- ^ 'orderExecutionReportAmountFilled': Total quantity filled.
  -> OrdStatus -- ^ 'orderExecutionReportStatus' 
  -> [[Text]] -- ^ 'orderExecutionReportTimeOrder': Timestamped history of order status changes.
  -> OrderExecutionReport
mkOrderExecutionReport orderExecutionReportExchangeId orderExecutionReportClientOrderId orderExecutionReportAmountOrder orderExecutionReportPrice orderExecutionReportSide orderExecutionReportOrderType orderExecutionReportTimeInForce orderExecutionReportClientOrderIdFormatExchange orderExecutionReportAmountOpen orderExecutionReportAmountFilled orderExecutionReportStatus orderExecutionReportTimeOrder =
  OrderExecutionReport
  { orderExecutionReportExchangeId
  , orderExecutionReportClientOrderId
  , orderExecutionReportSymbolIdExchange = Nothing
  , orderExecutionReportSymbolIdCoinapi = Nothing
  , orderExecutionReportAmountOrder
  , orderExecutionReportPrice
  , orderExecutionReportSide
  , orderExecutionReportOrderType
  , orderExecutionReportTimeInForce
  , orderExecutionReportExpireTime = Nothing
  , orderExecutionReportExecInst = Nothing
  , orderExecutionReportClientOrderIdFormatExchange
  , orderExecutionReportExchangeOrderId = Nothing
  , orderExecutionReportAmountOpen
  , orderExecutionReportAmountFilled
  , orderExecutionReportStatus
  , orderExecutionReportTimeOrder
  , orderExecutionReportErrorMessage = Nothing
  }

-- ** OrderExecutionReportAllOf
-- | OrderExecutionReportAllOf
-- The order execution report message.
data OrderExecutionReportAllOf = OrderExecutionReportAllOf
  { orderExecutionReportAllOfClientOrderIdFormatExchange :: !(Text) -- ^ /Required/ "client_order_id_format_exchange" - The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  , orderExecutionReportAllOfExchangeOrderId :: !(Maybe Text) -- ^ "exchange_order_id" - Unique identifier of the order assigned by the exchange or executing system.
  , orderExecutionReportAllOfAmountOpen :: !(Double) -- ^ /Required/ "amount_open" - Quantity open for further execution. &#x60;amount_open&#x60; &#x3D; &#x60;amount_order&#x60; - &#x60;amount_filled&#x60;
  , orderExecutionReportAllOfAmountFilled :: !(Double) -- ^ /Required/ "amount_filled" - Total quantity filled.
  , orderExecutionReportAllOfStatus :: !(OrdStatus) -- ^ /Required/ "status"
  , orderExecutionReportAllOfTimeOrder :: !([[Text]]) -- ^ /Required/ "time_order" - Timestamped history of order status changes.
  , orderExecutionReportAllOfErrorMessage :: !(Maybe Text) -- ^ "error_message" - Error message
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderExecutionReportAllOf
instance A.FromJSON OrderExecutionReportAllOf where
  parseJSON = A.withObject "OrderExecutionReportAllOf" $ \o ->
    OrderExecutionReportAllOf
      <$> (o .:  "client_order_id_format_exchange")
      <*> (o .:? "exchange_order_id")
      <*> (o .:  "amount_open")
      <*> (o .:  "amount_filled")
      <*> (o .:  "status")
      <*> (o .:  "time_order")
      <*> (o .:? "error_message")

-- | ToJSON OrderExecutionReportAllOf
instance A.ToJSON OrderExecutionReportAllOf where
  toJSON OrderExecutionReportAllOf {..} =
   _omitNulls
      [ "client_order_id_format_exchange" .= orderExecutionReportAllOfClientOrderIdFormatExchange
      , "exchange_order_id" .= orderExecutionReportAllOfExchangeOrderId
      , "amount_open" .= orderExecutionReportAllOfAmountOpen
      , "amount_filled" .= orderExecutionReportAllOfAmountFilled
      , "status" .= orderExecutionReportAllOfStatus
      , "time_order" .= orderExecutionReportAllOfTimeOrder
      , "error_message" .= orderExecutionReportAllOfErrorMessage
      ]


-- | Construct a value of type 'OrderExecutionReportAllOf' (by applying it's required fields, if any)
mkOrderExecutionReportAllOf
  :: Text -- ^ 'orderExecutionReportAllOfClientOrderIdFormatExchange': The unique identifier of the order assigned by the client converted to the exchange order tag format for the purpose of tracking it.
  -> Double -- ^ 'orderExecutionReportAllOfAmountOpen': Quantity open for further execution. `amount_open` = `amount_order` - `amount_filled`
  -> Double -- ^ 'orderExecutionReportAllOfAmountFilled': Total quantity filled.
  -> OrdStatus -- ^ 'orderExecutionReportAllOfStatus' 
  -> [[Text]] -- ^ 'orderExecutionReportAllOfTimeOrder': Timestamped history of order status changes.
  -> OrderExecutionReportAllOf
mkOrderExecutionReportAllOf orderExecutionReportAllOfClientOrderIdFormatExchange orderExecutionReportAllOfAmountOpen orderExecutionReportAllOfAmountFilled orderExecutionReportAllOfStatus orderExecutionReportAllOfTimeOrder =
  OrderExecutionReportAllOf
  { orderExecutionReportAllOfClientOrderIdFormatExchange
  , orderExecutionReportAllOfExchangeOrderId = Nothing
  , orderExecutionReportAllOfAmountOpen
  , orderExecutionReportAllOfAmountFilled
  , orderExecutionReportAllOfStatus
  , orderExecutionReportAllOfTimeOrder
  , orderExecutionReportAllOfErrorMessage = Nothing
  }

-- ** OrderNewSingleRequest
-- | OrderNewSingleRequest
-- The new order message.
data OrderNewSingleRequest = OrderNewSingleRequest
  { orderNewSingleRequestExchangeId :: !(Text) -- ^ /Required/ "exchange_id" - Exchange identifier used to identify the routing destination.
  , orderNewSingleRequestClientOrderId :: !(Text) -- ^ /Required/ "client_order_id" - The unique identifier of the order assigned by the client.
  , orderNewSingleRequestSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - Exchange symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderNewSingleRequestSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi" - CoinAPI symbol. One of the properties (&#x60;symbol_id_exchange&#x60;, &#x60;symbol_id_coinapi&#x60;) is required to identify the market for the new order.
  , orderNewSingleRequestAmountOrder :: !(Double) -- ^ /Required/ "amount_order" - Order quantity.
  , orderNewSingleRequestPrice :: !(Double) -- ^ /Required/ "price" - Order price.
  , orderNewSingleRequestSide :: !(OrdSide) -- ^ /Required/ "side"
  , orderNewSingleRequestOrderType :: !(OrdType) -- ^ /Required/ "order_type"
  , orderNewSingleRequestTimeInForce :: !(TimeInForce) -- ^ /Required/ "time_in_force"
  , orderNewSingleRequestExpireTime :: !(Maybe Date) -- ^ "expire_time" - Expiration time. Conditionaly required for orders with time_in_force &#x3D; &#x60;GOOD_TILL_TIME_EXCHANGE&#x60; or &#x60;GOOD_TILL_TIME_OEML&#x60;.
  , orderNewSingleRequestExecInst :: !(Maybe [E'ExecInst]) -- ^ "exec_inst" - Order execution instructions are documented in the separate section: &lt;a href&#x3D;\&quot;#oeml-order-params-exec\&quot;&gt;OEML / Starter Guide / Order parameters / Execution instructions&lt;/a&gt; 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OrderNewSingleRequest
instance A.FromJSON OrderNewSingleRequest where
  parseJSON = A.withObject "OrderNewSingleRequest" $ \o ->
    OrderNewSingleRequest
      <$> (o .:  "exchange_id")
      <*> (o .:  "client_order_id")
      <*> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")
      <*> (o .:  "amount_order")
      <*> (o .:  "price")
      <*> (o .:  "side")
      <*> (o .:  "order_type")
      <*> (o .:  "time_in_force")
      <*> (o .:? "expire_time")
      <*> (o .:? "exec_inst")

-- | ToJSON OrderNewSingleRequest
instance A.ToJSON OrderNewSingleRequest where
  toJSON OrderNewSingleRequest {..} =
   _omitNulls
      [ "exchange_id" .= orderNewSingleRequestExchangeId
      , "client_order_id" .= orderNewSingleRequestClientOrderId
      , "symbol_id_exchange" .= orderNewSingleRequestSymbolIdExchange
      , "symbol_id_coinapi" .= orderNewSingleRequestSymbolIdCoinapi
      , "amount_order" .= orderNewSingleRequestAmountOrder
      , "price" .= orderNewSingleRequestPrice
      , "side" .= orderNewSingleRequestSide
      , "order_type" .= orderNewSingleRequestOrderType
      , "time_in_force" .= orderNewSingleRequestTimeInForce
      , "expire_time" .= orderNewSingleRequestExpireTime
      , "exec_inst" .= orderNewSingleRequestExecInst
      ]


-- | Construct a value of type 'OrderNewSingleRequest' (by applying it's required fields, if any)
mkOrderNewSingleRequest
  :: Text -- ^ 'orderNewSingleRequestExchangeId': Exchange identifier used to identify the routing destination.
  -> Text -- ^ 'orderNewSingleRequestClientOrderId': The unique identifier of the order assigned by the client.
  -> Double -- ^ 'orderNewSingleRequestAmountOrder': Order quantity.
  -> Double -- ^ 'orderNewSingleRequestPrice': Order price.
  -> OrdSide -- ^ 'orderNewSingleRequestSide' 
  -> OrdType -- ^ 'orderNewSingleRequestOrderType' 
  -> TimeInForce -- ^ 'orderNewSingleRequestTimeInForce' 
  -> OrderNewSingleRequest
mkOrderNewSingleRequest orderNewSingleRequestExchangeId orderNewSingleRequestClientOrderId orderNewSingleRequestAmountOrder orderNewSingleRequestPrice orderNewSingleRequestSide orderNewSingleRequestOrderType orderNewSingleRequestTimeInForce =
  OrderNewSingleRequest
  { orderNewSingleRequestExchangeId
  , orderNewSingleRequestClientOrderId
  , orderNewSingleRequestSymbolIdExchange = Nothing
  , orderNewSingleRequestSymbolIdCoinapi = Nothing
  , orderNewSingleRequestAmountOrder
  , orderNewSingleRequestPrice
  , orderNewSingleRequestSide
  , orderNewSingleRequestOrderType
  , orderNewSingleRequestTimeInForce
  , orderNewSingleRequestExpireTime = Nothing
  , orderNewSingleRequestExecInst = Nothing
  }

-- ** Position
-- | Position
data Position = Position
  { positionExchangeId :: !(Maybe Text) -- ^ "exchange_id" - Exchange identifier used to identify the routing destination.
  , positionData :: !(Maybe [PositionData]) -- ^ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Position
instance A.FromJSON Position where
  parseJSON = A.withObject "Position" $ \o ->
    Position
      <$> (o .:? "exchange_id")
      <*> (o .:? "data")

-- | ToJSON Position
instance A.ToJSON Position where
  toJSON Position {..} =
   _omitNulls
      [ "exchange_id" .= positionExchangeId
      , "data" .= positionData
      ]


-- | Construct a value of type 'Position' (by applying it's required fields, if any)
mkPosition
  :: Position
mkPosition =
  Position
  { positionExchangeId = Nothing
  , positionData = Nothing
  }

-- ** PositionData
-- | PositionData
-- The Position object.
data PositionData = PositionData
  { positionDataSymbolIdExchange :: !(Maybe Text) -- ^ "symbol_id_exchange" - Exchange symbol.
  , positionDataSymbolIdCoinapi :: !(Maybe Text) -- ^ "symbol_id_coinapi" - CoinAPI symbol.
  , positionDataAvgEntryPrice :: !(Maybe Double) -- ^ "avg_entry_price" - Calculated average price of all fills on this position.
  , positionDataQuantity :: !(Maybe Double) -- ^ "quantity" - The current position quantity.
  , positionDataSide :: !(Maybe OrdSide) -- ^ "side"
  , positionDataUnrealizedPnl :: !(Maybe Double) -- ^ "unrealized_pnl" - Unrealised profit or loss (PNL) of this position.
  , positionDataLeverage :: !(Maybe Double) -- ^ "leverage" - Leverage for this position reported by the exchange.
  , positionDataCrossMargin :: !(Maybe Bool) -- ^ "cross_margin" - Is cross margin mode enable for this position?
  , positionDataLiquidationPrice :: !(Maybe Double) -- ^ "liquidation_price" - Liquidation price. If mark price will reach this value, the position will be liquidated.
  , positionDataRawData :: !(Maybe A.Value) -- ^ "raw_data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON PositionData
instance A.FromJSON PositionData where
  parseJSON = A.withObject "PositionData" $ \o ->
    PositionData
      <$> (o .:? "symbol_id_exchange")
      <*> (o .:? "symbol_id_coinapi")
      <*> (o .:? "avg_entry_price")
      <*> (o .:? "quantity")
      <*> (o .:? "side")
      <*> (o .:? "unrealized_pnl")
      <*> (o .:? "leverage")
      <*> (o .:? "cross_margin")
      <*> (o .:? "liquidation_price")
      <*> (o .:? "raw_data")

-- | ToJSON PositionData
instance A.ToJSON PositionData where
  toJSON PositionData {..} =
   _omitNulls
      [ "symbol_id_exchange" .= positionDataSymbolIdExchange
      , "symbol_id_coinapi" .= positionDataSymbolIdCoinapi
      , "avg_entry_price" .= positionDataAvgEntryPrice
      , "quantity" .= positionDataQuantity
      , "side" .= positionDataSide
      , "unrealized_pnl" .= positionDataUnrealizedPnl
      , "leverage" .= positionDataLeverage
      , "cross_margin" .= positionDataCrossMargin
      , "liquidation_price" .= positionDataLiquidationPrice
      , "raw_data" .= positionDataRawData
      ]


-- | Construct a value of type 'PositionData' (by applying it's required fields, if any)
mkPositionData
  :: PositionData
mkPositionData =
  PositionData
  { positionDataSymbolIdExchange = Nothing
  , positionDataSymbolIdCoinapi = Nothing
  , positionDataAvgEntryPrice = Nothing
  , positionDataQuantity = Nothing
  , positionDataSide = Nothing
  , positionDataUnrealizedPnl = Nothing
  , positionDataLeverage = Nothing
  , positionDataCrossMargin = Nothing
  , positionDataLiquidationPrice = Nothing
  , positionDataRawData = Nothing
  }

-- ** ValidationError
-- | ValidationError
-- JSON validation error.
-- 
data ValidationError = ValidationError
  { validationErrorType :: !(Maybe Text) -- ^ "type"
  , validationErrorTitle :: !(Maybe Text) -- ^ "title"
  , validationErrorStatus :: !(Maybe Double) -- ^ "status"
  , validationErrorTraceId :: !(Maybe Text) -- ^ "traceId"
  , validationErrorErrors :: !(Maybe Text) -- ^ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ValidationError
instance A.FromJSON ValidationError where
  parseJSON = A.withObject "ValidationError" $ \o ->
    ValidationError
      <$> (o .:? "type")
      <*> (o .:? "title")
      <*> (o .:? "status")
      <*> (o .:? "traceId")
      <*> (o .:? "errors")

-- | ToJSON ValidationError
instance A.ToJSON ValidationError where
  toJSON ValidationError {..} =
   _omitNulls
      [ "type" .= validationErrorType
      , "title" .= validationErrorTitle
      , "status" .= validationErrorStatus
      , "traceId" .= validationErrorTraceId
      , "errors" .= validationErrorErrors
      ]


-- | Construct a value of type 'ValidationError' (by applying it's required fields, if any)
mkValidationError
  :: ValidationError
mkValidationError =
  ValidationError
  { validationErrorType = Nothing
  , validationErrorTitle = Nothing
  , validationErrorStatus = Nothing
  , validationErrorTraceId = Nothing
  , validationErrorErrors = Nothing
  }


-- * Enums


-- ** E'ExecInst

-- | Enum of 'Text'
data E'ExecInst
  = E'ExecInst'MAKER_OR_CANCEL -- ^ @"MAKER_OR_CANCEL"@
  | E'ExecInst'AUCTION_ONLY -- ^ @"AUCTION_ONLY"@
  | E'ExecInst'INDICATION_OF_INTEREST -- ^ @"INDICATION_OF_INTEREST"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ExecInst where toJSON = A.toJSON . fromE'ExecInst
instance A.FromJSON E'ExecInst where parseJSON o = P.either P.fail (pure . P.id) . toE'ExecInst =<< A.parseJSON o
instance WH.ToHttpApiData E'ExecInst where toQueryParam = WH.toQueryParam . fromE'ExecInst
instance WH.FromHttpApiData E'ExecInst where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ExecInst
instance MimeRender MimeMultipartFormData E'ExecInst where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ExecInst' enum
fromE'ExecInst :: E'ExecInst -> Text
fromE'ExecInst = \case
  E'ExecInst'MAKER_OR_CANCEL -> "MAKER_OR_CANCEL"
  E'ExecInst'AUCTION_ONLY -> "AUCTION_ONLY"
  E'ExecInst'INDICATION_OF_INTEREST -> "INDICATION_OF_INTEREST"

-- | parse 'E'ExecInst' enum
toE'ExecInst :: Text -> P.Either String E'ExecInst
toE'ExecInst = \case
  "MAKER_OR_CANCEL" -> P.Right E'ExecInst'MAKER_OR_CANCEL
  "AUCTION_ONLY" -> P.Right E'ExecInst'AUCTION_ONLY
  "INDICATION_OF_INTEREST" -> P.Right E'ExecInst'INDICATION_OF_INTEREST
  s -> P.Left $ "toE'ExecInst: enum parse failure: " P.++ P.show s


-- ** E'LastUpdatedBy

-- | Enum of 'Text' . 
-- Source of the last modification. 
data E'LastUpdatedBy
  = E'LastUpdatedBy'INITIALIZATION -- ^ @"INITIALIZATION"@
  | E'LastUpdatedBy'BALANCE_MANAGER -- ^ @"BALANCE_MANAGER"@
  | E'LastUpdatedBy'EXCHANGE -- ^ @"EXCHANGE"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'LastUpdatedBy where toJSON = A.toJSON . fromE'LastUpdatedBy
instance A.FromJSON E'LastUpdatedBy where parseJSON o = P.either P.fail (pure . P.id) . toE'LastUpdatedBy =<< A.parseJSON o
instance WH.ToHttpApiData E'LastUpdatedBy where toQueryParam = WH.toQueryParam . fromE'LastUpdatedBy
instance WH.FromHttpApiData E'LastUpdatedBy where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'LastUpdatedBy
instance MimeRender MimeMultipartFormData E'LastUpdatedBy where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'LastUpdatedBy' enum
fromE'LastUpdatedBy :: E'LastUpdatedBy -> Text
fromE'LastUpdatedBy = \case
  E'LastUpdatedBy'INITIALIZATION -> "INITIALIZATION"
  E'LastUpdatedBy'BALANCE_MANAGER -> "BALANCE_MANAGER"
  E'LastUpdatedBy'EXCHANGE -> "EXCHANGE"

-- | parse 'E'LastUpdatedBy' enum
toE'LastUpdatedBy :: Text -> P.Either String E'LastUpdatedBy
toE'LastUpdatedBy = \case
  "INITIALIZATION" -> P.Right E'LastUpdatedBy'INITIALIZATION
  "BALANCE_MANAGER" -> P.Right E'LastUpdatedBy'BALANCE_MANAGER
  "EXCHANGE" -> P.Right E'LastUpdatedBy'EXCHANGE
  s -> P.Left $ "toE'LastUpdatedBy: enum parse failure: " P.++ P.show s


-- ** OrdSide

-- | Enum of 'Text' . 
-- Side of order. 
data OrdSide
  = OrdSide'BUY -- ^ @"BUY"@
  | OrdSide'SELL -- ^ @"SELL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdSide where toJSON = A.toJSON . fromOrdSide
instance A.FromJSON OrdSide where parseJSON o = P.either P.fail (pure . P.id) . toOrdSide =<< A.parseJSON o
instance WH.ToHttpApiData OrdSide where toQueryParam = WH.toQueryParam . fromOrdSide
instance WH.FromHttpApiData OrdSide where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdSide
instance MimeRender MimeMultipartFormData OrdSide where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdSide' enum
fromOrdSide :: OrdSide -> Text
fromOrdSide = \case
  OrdSide'BUY -> "BUY"
  OrdSide'SELL -> "SELL"

-- | parse 'OrdSide' enum
toOrdSide :: Text -> P.Either String OrdSide
toOrdSide = \case
  "BUY" -> P.Right OrdSide'BUY
  "SELL" -> P.Right OrdSide'SELL
  s -> P.Left $ "toOrdSide: enum parse failure: " P.++ P.show s


-- ** OrdStatus

-- | Enum of 'Text' . 
-- Order statuses and the lifecycle are documented in the separate section: <a href=\"#oeml-order-lifecycle\">OEML / Starter Guide / Order Lifecycle</a> 
data OrdStatus
  = OrdStatus'RECEIVED -- ^ @"RECEIVED"@
  | OrdStatus'ROUTING -- ^ @"ROUTING"@
  | OrdStatus'ROUTED -- ^ @"ROUTED"@
  | OrdStatus'NEW -- ^ @"NEW"@
  | OrdStatus'PENDING_CANCEL -- ^ @"PENDING_CANCEL"@
  | OrdStatus'PARTIALLY_FILLED -- ^ @"PARTIALLY_FILLED"@
  | OrdStatus'FILLED -- ^ @"FILLED"@
  | OrdStatus'CANCELED -- ^ @"CANCELED"@
  | OrdStatus'REJECTED -- ^ @"REJECTED"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdStatus where toJSON = A.toJSON . fromOrdStatus
instance A.FromJSON OrdStatus where parseJSON o = P.either P.fail (pure . P.id) . toOrdStatus =<< A.parseJSON o
instance WH.ToHttpApiData OrdStatus where toQueryParam = WH.toQueryParam . fromOrdStatus
instance WH.FromHttpApiData OrdStatus where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdStatus
instance MimeRender MimeMultipartFormData OrdStatus where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdStatus' enum
fromOrdStatus :: OrdStatus -> Text
fromOrdStatus = \case
  OrdStatus'RECEIVED -> "RECEIVED"
  OrdStatus'ROUTING -> "ROUTING"
  OrdStatus'ROUTED -> "ROUTED"
  OrdStatus'NEW -> "NEW"
  OrdStatus'PENDING_CANCEL -> "PENDING_CANCEL"
  OrdStatus'PARTIALLY_FILLED -> "PARTIALLY_FILLED"
  OrdStatus'FILLED -> "FILLED"
  OrdStatus'CANCELED -> "CANCELED"
  OrdStatus'REJECTED -> "REJECTED"

-- | parse 'OrdStatus' enum
toOrdStatus :: Text -> P.Either String OrdStatus
toOrdStatus = \case
  "RECEIVED" -> P.Right OrdStatus'RECEIVED
  "ROUTING" -> P.Right OrdStatus'ROUTING
  "ROUTED" -> P.Right OrdStatus'ROUTED
  "NEW" -> P.Right OrdStatus'NEW
  "PENDING_CANCEL" -> P.Right OrdStatus'PENDING_CANCEL
  "PARTIALLY_FILLED" -> P.Right OrdStatus'PARTIALLY_FILLED
  "FILLED" -> P.Right OrdStatus'FILLED
  "CANCELED" -> P.Right OrdStatus'CANCELED
  "REJECTED" -> P.Right OrdStatus'REJECTED
  s -> P.Left $ "toOrdStatus: enum parse failure: " P.++ P.show s


-- ** OrdType

-- | Enum of 'Text' . 
-- Order types are documented in the separate section: <a href=\"#oeml-order-params-type\">OEML / Starter Guide / Order parameters / Order type</a> 
data OrdType
  = OrdType'LIMIT -- ^ @"LIMIT"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON OrdType where toJSON = A.toJSON . fromOrdType
instance A.FromJSON OrdType where parseJSON o = P.either P.fail (pure . P.id) . toOrdType =<< A.parseJSON o
instance WH.ToHttpApiData OrdType where toQueryParam = WH.toQueryParam . fromOrdType
instance WH.FromHttpApiData OrdType where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toOrdType
instance MimeRender MimeMultipartFormData OrdType where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'OrdType' enum
fromOrdType :: OrdType -> Text
fromOrdType = \case
  OrdType'LIMIT -> "LIMIT"

-- | parse 'OrdType' enum
toOrdType :: Text -> P.Either String OrdType
toOrdType = \case
  "LIMIT" -> P.Right OrdType'LIMIT
  s -> P.Left $ "toOrdType: enum parse failure: " P.++ P.show s


-- ** Severity

-- | Enum of 'Text' . 
-- Severity of the message.
data Severity
  = Severity'INFO -- ^ @"INFO"@
  | Severity'WARNING -- ^ @"WARNING"@
  | Severity'ERROR -- ^ @"ERROR"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON Severity where toJSON = A.toJSON . fromSeverity
instance A.FromJSON Severity where parseJSON o = P.either P.fail (pure . P.id) . toSeverity =<< A.parseJSON o
instance WH.ToHttpApiData Severity where toQueryParam = WH.toQueryParam . fromSeverity
instance WH.FromHttpApiData Severity where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSeverity
instance MimeRender MimeMultipartFormData Severity where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'Severity' enum
fromSeverity :: Severity -> Text
fromSeverity = \case
  Severity'INFO -> "INFO"
  Severity'WARNING -> "WARNING"
  Severity'ERROR -> "ERROR"

-- | parse 'Severity' enum
toSeverity :: Text -> P.Either String Severity
toSeverity = \case
  "INFO" -> P.Right Severity'INFO
  "WARNING" -> P.Right Severity'WARNING
  "ERROR" -> P.Right Severity'ERROR
  s -> P.Left $ "toSeverity: enum parse failure: " P.++ P.show s


-- ** TimeInForce

-- | Enum of 'Text' . 
-- Order time in force options are documented in the separate section: <a href=\"#oeml-order-params-tif\">OEML / Starter Guide / Order parameters / Time in force</a> 
data TimeInForce
  = TimeInForce'GOOD_TILL_CANCEL -- ^ @"GOOD_TILL_CANCEL"@
  | TimeInForce'GOOD_TILL_TIME_EXCHANGE -- ^ @"GOOD_TILL_TIME_EXCHANGE"@
  | TimeInForce'GOOD_TILL_TIME_OMS -- ^ @"GOOD_TILL_TIME_OMS"@
  | TimeInForce'FILL_OR_KILL -- ^ @"FILL_OR_KILL"@
  | TimeInForce'IMMEDIATE_OR_CANCEL -- ^ @"IMMEDIATE_OR_CANCEL"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON TimeInForce where toJSON = A.toJSON . fromTimeInForce
instance A.FromJSON TimeInForce where parseJSON o = P.either P.fail (pure . P.id) . toTimeInForce =<< A.parseJSON o
instance WH.ToHttpApiData TimeInForce where toQueryParam = WH.toQueryParam . fromTimeInForce
instance WH.FromHttpApiData TimeInForce where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toTimeInForce
instance MimeRender MimeMultipartFormData TimeInForce where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'TimeInForce' enum
fromTimeInForce :: TimeInForce -> Text
fromTimeInForce = \case
  TimeInForce'GOOD_TILL_CANCEL -> "GOOD_TILL_CANCEL"
  TimeInForce'GOOD_TILL_TIME_EXCHANGE -> "GOOD_TILL_TIME_EXCHANGE"
  TimeInForce'GOOD_TILL_TIME_OMS -> "GOOD_TILL_TIME_OMS"
  TimeInForce'FILL_OR_KILL -> "FILL_OR_KILL"
  TimeInForce'IMMEDIATE_OR_CANCEL -> "IMMEDIATE_OR_CANCEL"

-- | parse 'TimeInForce' enum
toTimeInForce :: Text -> P.Either String TimeInForce
toTimeInForce = \case
  "GOOD_TILL_CANCEL" -> P.Right TimeInForce'GOOD_TILL_CANCEL
  "GOOD_TILL_TIME_EXCHANGE" -> P.Right TimeInForce'GOOD_TILL_TIME_EXCHANGE
  "GOOD_TILL_TIME_OMS" -> P.Right TimeInForce'GOOD_TILL_TIME_OMS
  "FILL_OR_KILL" -> P.Right TimeInForce'FILL_OR_KILL
  "IMMEDIATE_OR_CANCEL" -> P.Right TimeInForce'IMMEDIATE_OR_CANCEL
  s -> P.Left $ "toTimeInForce: enum parse failure: " P.++ P.show s



